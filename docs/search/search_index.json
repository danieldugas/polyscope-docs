{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polyscope is a C++ viewer and user interface for the rapid prototyping and debugging of geometric algorithms in 3D geometry processing, scientific computing, and computer graphics/vision. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code. Polyscope uses a paradigm of structures and quantities . A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field. When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling the display of various data, colormapping data and editing maps, providing \u201cpicking\u201d support to click in the scene and display numerical quantities, and generating histograms of scalar values. A simple workflow for visualizing data in Polyscope looks like: #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" // Initialize polyscope polyscope :: init (); // Register a surface mesh structure polyscope :: registerSurfaceMesh ( \"my mesh\" , mesh . vertices , mesh . faces ); // Add a scalar and a vector function to the mesh polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addQuantity ( \"my_scalar\" , scalarQuantity ); polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addQuantity ( \"my_vector\" , vectorQuantity ); // Show the gui polyscope :: show (); The last line creates a UI window allowing you to inspect and visualize the data! For details on the API, see the documentation. Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Home"},{"location":"basics/array_adaptors/","text":"Template magic!","title":"Array adaptors"},{"location":"basics/camera_controls/","text":"","title":"Camera Controls"},{"location":"basics/initializing/","text":"Initializing Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: #include \"polyscope/polyscope.h\" // Initialize polyscope, creating openGL context and constructing a window. // Should be called exactly once. polyscope :: init (); /* * build visualizations, here or in distant code * */ // Pass control flow to polyscope, displaying the interactive window. // Function will return when user closes the window. polyscope :: show (); Functions #include \"polyscope/polyscope.h\" init() init() Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show() show() Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window.","title":"Initializing"},{"location":"basics/initializing/#initializing","text":"Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: #include \"polyscope/polyscope.h\" // Initialize polyscope, creating openGL context and constructing a window. // Should be called exactly once. polyscope :: init (); /* * build visualizations, here or in distant code * */ // Pass control flow to polyscope, displaying the interactive window. // Function will return when user closes the window. polyscope :: show ();","title":"Initializing"},{"location":"basics/initializing/#functions","text":"#include \"polyscope/polyscope.h\" init()","title":"Functions"},{"location":"basics/initializing/#init","text":"Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show()","title":"init()"},{"location":"basics/initializing/#show","text":"Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window.","title":"show()"},{"location":"basics/messages/","text":"Using messages We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. terminating error Like error , but terminates the program after being dismissed. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); // Generating an error. // The UI will block and show this error immediately. After // the error is dismissed, the call will return. polyscope :: error ( \"Resistance is futile.\" ); // Generate a fatal error. // After the error is dismissed, the program will terminate. polyscope :: terminatingError ( \"Resistance is futile.\" ); Messages void polyscope :: info ( std :: string message ) info Simply logs a message to stdout . void polyscope :: warning ( std :: string baseMessage , std :: string detailMessage = \"\" ) warning Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detailMessage field need not be used. However, if issuing warnings in a loop, warnings with the same baseMessage are batched together, so the UI doesn\u2019t get completely overwhelmed. Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); void polyscope :: error ( std :: string message ) error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns. void polyscope :: terminatingError ( std :: string message ) terminating error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, the program terminates.","title":"Messages"},{"location":"basics/messages/#using-messages","text":"We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. terminating error Like error , but terminates the program after being dismissed. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); // Generating an error. // The UI will block and show this error immediately. After // the error is dismissed, the call will return. polyscope :: error ( \"Resistance is futile.\" ); // Generate a fatal error. // After the error is dismissed, the program will terminate. polyscope :: terminatingError ( \"Resistance is futile.\" );","title":"Using messages"},{"location":"basics/messages/#messages","text":"void polyscope :: info ( std :: string message )","title":"Messages"},{"location":"basics/messages/#info","text":"Simply logs a message to stdout . void polyscope :: warning ( std :: string baseMessage , std :: string detailMessage = \"\" )","title":"info"},{"location":"basics/messages/#warning","text":"Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detailMessage field need not be used. However, if issuing warnings in a loop, warnings with the same baseMessage are batched together, so the UI doesn\u2019t get completely overwhelmed. Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); void polyscope :: error ( std :: string message )","title":"warning"},{"location":"basics/messages/#error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns. void polyscope :: terminatingError ( std :: string message )","title":"error"},{"location":"basics/messages/#terminating-error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, the program terminates.","title":"terminating error"},{"location":"basics/program_options/","text":"These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling polyscope::init , but they may set be anywhere. #include \"polyscope/polyscope.h\" // a few options polyscope :: options :: programName = \"important app\" ; polyscope :: options :: verbosity = 0 ; polyscope :: options :: usePrefsFile = false ; // initialize polyscope :: init (); Options std :: string options :: programName program name A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: polyscope :: options :: programName = \"important app\" ; int options :: verbosity verbosity How much useful info should polyscope print to std::cout ? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: polyscope :: options :: verbosity = 1 ; std :: string options :: printPrefix print prefix A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: polyscope :: options :: printPrefix = \"[MYAPP] \" ; // prints now look like \"[MYAPP] loaded openGL\" bool options :: errorsThrowExceptions errors throw execptions If true, errors in polyscope throw execptions. If false, a polyscope::error is shown in the UI, but processing attempts to continue. Default: false . int options :: maxFPS max fps The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . bool options :: usePrefsFile use prefs file Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If false , if will be neither written nor read. Default: true . bool options :: alwaysRedraw always redraw Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is true , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: false . bool options :: openImGuiWindowForUserCallback open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"Program Options"},{"location":"basics/program_options/#options","text":"std :: string options :: programName","title":"Options"},{"location":"basics/program_options/#program-name","text":"A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: polyscope :: options :: programName = \"important app\" ; int options :: verbosity","title":"program name"},{"location":"basics/program_options/#verbosity","text":"How much useful info should polyscope print to std::cout ? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: polyscope :: options :: verbosity = 1 ; std :: string options :: printPrefix","title":"verbosity"},{"location":"basics/program_options/#print-prefix","text":"A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: polyscope :: options :: printPrefix = \"[MYAPP] \" ; // prints now look like \"[MYAPP] loaded openGL\" bool options :: errorsThrowExceptions","title":"print prefix"},{"location":"basics/program_options/#errors-throw-execptions","text":"If true, errors in polyscope throw execptions. If false, a polyscope::error is shown in the UI, but processing attempts to continue. Default: false . int options :: maxFPS","title":"errors throw execptions"},{"location":"basics/program_options/#max-fps","text":"The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . bool options :: usePrefsFile","title":"max fps"},{"location":"basics/program_options/#use-prefs-file","text":"Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If false , if will be neither written nor read. Default: true . bool options :: alwaysRedraw","title":"use prefs file"},{"location":"basics/program_options/#always-redraw","text":"Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is true , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: false . bool options :: openImGuiWindowForUserCallback","title":"always redraw"},{"location":"basics/program_options/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"open imgui window for user callback"},{"location":"basics/scene_options/","text":"These are settings which affect the visual display of the scene. It is often convenient to set them just before calling polyscope::init , but they may set be anywhere. #include \"polyscope/polyscope.h\" // a few options polyscope :: options :: autocenterStructures = true ; // initialize polyscope :: init (); bool options :: autocenterStructures autocenter structures If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: false .","title":"Scene Options"},{"location":"basics/scene_options/#autocenter-structures","text":"If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: false .","title":"autocenter structures"},{"location":"basics/screenshots/","text":"Taking screenshots Polyscope includes simple functionality for saving screenshots of the UI to disk. The imGUI windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [screenshot] button in the options UI window, or programmatically using the functions below. Clicking the UI button is equivalent to calling screenshot() below, generating a numbered screenshot file in the current directory. Messages void polyscope :: screenshot ( bool transparentBG = true ) numbered screenshot Saves a screenshot to the current directory, with file names screenshot_000000.png , numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent. void polyscope :: screenshot ( std :: string filename , bool transparentBG = true ) named screenshot Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be one of .png , .tga , or .bmp . If transparentBG is true , the background will be rendered as transparent.","title":"Screenshots"},{"location":"basics/screenshots/#taking-screenshots","text":"Polyscope includes simple functionality for saving screenshots of the UI to disk. The imGUI windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [screenshot] button in the options UI window, or programmatically using the functions below. Clicking the UI button is equivalent to calling screenshot() below, generating a numbered screenshot file in the current directory.","title":"Taking screenshots"},{"location":"basics/screenshots/#messages","text":"void polyscope :: screenshot ( bool transparentBG = true )","title":"Messages"},{"location":"basics/screenshots/#numbered-screenshot","text":"Saves a screenshot to the current directory, with file names screenshot_000000.png , numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent. void polyscope :: screenshot ( std :: string filename , bool transparentBG = true )","title":"numbered screenshot"},{"location":"basics/screenshots/#named-screenshot","text":"Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be one of .png , .tga , or .bmp . If transparentBG is true , the background will be rendered as transparent.","title":"named screenshot"},{"location":"basics/user_callback/","text":"Intro When polyscope::show() has been called, Polyscope will optionally invoke user-supplied callback function on every loop iteration. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc. See ImGui for documentation of UI commands. std :: function < void () > polyscope :: state :: userCallback user callback A function which will be invoked on every main loop iteration by Polyscope, once show() has been called. If null, nothing will be invoked. Example The code below creates the following UI using a callback. #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" // Parameters which we will set in the callback UI. int nPts = 2000 ; float anotherParam = 3.14 ; void mySubroutine () { // do something useful... // Register a structure std :: vector < glm :: vec3 > points ; for ( int i = 0 ; i < nPts ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit () }); } polyscope :: registerPointCloud ( \"my point cloud\" , points ); } // Your callback functions void myCallback () { // Since options::openImGuiWindowForUserCallback == true by default, // we can immediately start using ImGui commands to build a UI ImGui :: PushItemWidth ( 100 ); // Make ui elements 100 pixels wide, // instead of full width. Must have // matching PopItemWidth() below. ImGui :: InputInt ( \"num points\" , & nPts ); // set a int variable ImGui :: InputFloat ( \"param value\" , & anotherParam ); // set a float variable if ( ImGui :: Button ( \"run subroutine\" )) { // executes when button is pressed mySubroutine (); } ImGui :: SameLine (); if ( ImGui :: Button ( \"hi\" )) { polyscope :: warning ( \"hi\" ); } ImGui :: PopItemWidth (); } int main ( int argc , char ** argv ) { /* ...your program setup... */ // Initialize polyscope polyscope :: init (); // Specify the callback polyscope :: state :: userCallback = callback ; // Give control to the polyscope gui polyscope :: show (); return EXIT_SUCCESS ; } Options bool options :: openImGuiWindowForUserCallback open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"User Callback"},{"location":"basics/user_callback/#intro","text":"When polyscope::show() has been called, Polyscope will optionally invoke user-supplied callback function on every loop iteration. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc. See ImGui for documentation of UI commands. std :: function < void () > polyscope :: state :: userCallback","title":"Intro"},{"location":"basics/user_callback/#user-callback","text":"A function which will be invoked on every main loop iteration by Polyscope, once show() has been called. If null, nothing will be invoked.","title":"user callback"},{"location":"basics/user_callback/#example","text":"The code below creates the following UI using a callback. #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" // Parameters which we will set in the callback UI. int nPts = 2000 ; float anotherParam = 3.14 ; void mySubroutine () { // do something useful... // Register a structure std :: vector < glm :: vec3 > points ; for ( int i = 0 ; i < nPts ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit () }); } polyscope :: registerPointCloud ( \"my point cloud\" , points ); } // Your callback functions void myCallback () { // Since options::openImGuiWindowForUserCallback == true by default, // we can immediately start using ImGui commands to build a UI ImGui :: PushItemWidth ( 100 ); // Make ui elements 100 pixels wide, // instead of full width. Must have // matching PopItemWidth() below. ImGui :: InputInt ( \"num points\" , & nPts ); // set a int variable ImGui :: InputFloat ( \"param value\" , & anotherParam ); // set a float variable if ( ImGui :: Button ( \"run subroutine\" )) { // executes when button is pressed mySubroutine (); } ImGui :: SameLine (); if ( ImGui :: Button ( \"hi\" )) { polyscope :: warning ( \"hi\" ); } ImGui :: PopItemWidth (); } int main ( int argc , char ** argv ) { /* ...your program setup... */ // Initialize polyscope polyscope :: init (); // Specify the callback polyscope :: state :: userCallback = callback ; // Give control to the polyscope gui polyscope :: show (); return EXIT_SUCCESS ; }","title":"Example"},{"location":"basics/user_callback/#options","text":"bool options :: openImGuiWindowForUserCallback","title":"Options"},{"location":"basics/user_callback/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"open imgui window for user callback"},{"location":"building/","text":"","title":"Build"},{"location":"integrations/cgal/","text":"","title":"CGAL"},{"location":"integrations/geometry_central/","text":"This section demonstrates using Polyscope with geometry-central ! Note that a few useful adaptor functions are included in geometrycentral/surface/meshio.h . Registering a surface mesh #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include \"geometrycentral/surface/halfedge_mesh.h\" #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"geometrycentral/surface/meshio.h using namespace geometrycentral :: surface ; HalfedgeMesh & mesh = /* your mesh */ ; EmbeddedGeometryInterface & geom = /* your geometry */ ; // Be sure your mesh has vertex positions available geom . requireVertexPositions (); // Register the mesh with polyscope polyscope :: registerSurfaceMesh ( \"myMesh\" , geom . vertexPositions , mesh . getFaceVertexList ()); // Note: for a VertexPositionGeometry, one could instead use: VertexPositionGeometry & posGeom = /* your geometry */ ; polyscope :: registerSurfaceMesh ( \"myMesh\" , posGeom . inputVertexPositions , mesh . getFaceVertexList ()); Meshdata containers Geometry-central\u2019s Meshdata<> containers can be passed directly to Polyscope for visualization. /* (continuing up from the Registering example above) */ VertexData < double > myScalar = /* some scalar on vertices */ ; polyscope :: getMesh ( \"myMesh\" ) -> addVertexScalarQuantity ( \"myScalar\" , myScalar ); FaceData < double > otherScalar = /* another scalar on faces*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addFaceScalarQuantity ( \"otherScalar\" , otherScalar ); FaceData < double > anotherScalar = /* another scalar on edges*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addEdgeScalarQuantity ( \"super important edge scalar\" , anotherScalar ); // Containers holding `Vector3`s can be used for 3D vectors at faces and vertices // Example: vertex normals as computed in geometry-central posGeom -> requireVertexNormals (); polyscope :: getMesh ( \"myMesh\" ) -> addVertexVectorQuantity ( \"vertex normals\" , posGeom -> vertexNormals ); Custom ordering Geometry-central\u2019s ordering of mesh halfedges and corners is different from Polyscope\u2019s default ordering (see indexing convention ). As such, you must tell Polyscope about this ordering for halfedge or corner-valued visualizations to work properly. The geometry-central function polyscopePermutations(HalfedgeMesh& mesh) from meshio.h generates the ordering data in an approriate form for Polyscope, and can be passed either at construction time or after. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // could alternately pass polyscopePermutations(*mesh) as additional // last parameter of constructor polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh )); Tangent vector data 1-forms To communicate the canonical edge orientation when passing a 1-form, use polyscopeEdgeOrientations(mesh) from meshio.h . Example: #include \"geometrycentral/surface/meshio.h\" HalfedgeMesh & mesh = /* your mesh */ ; EdgeData < double > myForm = /* your 1-form */ ; polyscope :: getSurfaceMesh ( \"myMesh\" ) -> addOneFormIntrinsicVectorQuantity ( \"my form\" , myForm , polyscopeEdgeOrientations ( mesh ));","title":"Geometry Central"},{"location":"integrations/geometry_central/#registering-a-surface-mesh","text":"#include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include \"geometrycentral/surface/halfedge_mesh.h\" #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"geometrycentral/surface/meshio.h using namespace geometrycentral :: surface ; HalfedgeMesh & mesh = /* your mesh */ ; EmbeddedGeometryInterface & geom = /* your geometry */ ; // Be sure your mesh has vertex positions available geom . requireVertexPositions (); // Register the mesh with polyscope polyscope :: registerSurfaceMesh ( \"myMesh\" , geom . vertexPositions , mesh . getFaceVertexList ()); // Note: for a VertexPositionGeometry, one could instead use: VertexPositionGeometry & posGeom = /* your geometry */ ; polyscope :: registerSurfaceMesh ( \"myMesh\" , posGeom . inputVertexPositions , mesh . getFaceVertexList ());","title":"Registering a surface mesh"},{"location":"integrations/geometry_central/#meshdata-containers","text":"Geometry-central\u2019s Meshdata<> containers can be passed directly to Polyscope for visualization. /* (continuing up from the Registering example above) */ VertexData < double > myScalar = /* some scalar on vertices */ ; polyscope :: getMesh ( \"myMesh\" ) -> addVertexScalarQuantity ( \"myScalar\" , myScalar ); FaceData < double > otherScalar = /* another scalar on faces*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addFaceScalarQuantity ( \"otherScalar\" , otherScalar ); FaceData < double > anotherScalar = /* another scalar on edges*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addEdgeScalarQuantity ( \"super important edge scalar\" , anotherScalar ); // Containers holding `Vector3`s can be used for 3D vectors at faces and vertices // Example: vertex normals as computed in geometry-central posGeom -> requireVertexNormals (); polyscope :: getMesh ( \"myMesh\" ) -> addVertexVectorQuantity ( \"vertex normals\" , posGeom -> vertexNormals );","title":"Meshdata containers"},{"location":"integrations/geometry_central/#custom-ordering","text":"Geometry-central\u2019s ordering of mesh halfedges and corners is different from Polyscope\u2019s default ordering (see indexing convention ). As such, you must tell Polyscope about this ordering for halfedge or corner-valued visualizations to work properly. The geometry-central function polyscopePermutations(HalfedgeMesh& mesh) from meshio.h generates the ordering data in an approriate form for Polyscope, and can be passed either at construction time or after. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // could alternately pass polyscopePermutations(*mesh) as additional // last parameter of constructor polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh ));","title":"Custom ordering"},{"location":"integrations/geometry_central/#tangent-vector-data","text":"","title":"Tangent vector data"},{"location":"integrations/geometry_central/#1-forms","text":"To communicate the canonical edge orientation when passing a 1-form, use polyscopeEdgeOrientations(mesh) from meshio.h . Example: #include \"geometrycentral/surface/meshio.h\" HalfedgeMesh & mesh = /* your mesh */ ; EdgeData < double > myForm = /* your 1-form */ ; polyscope :: getSurfaceMesh ( \"myMesh\" ) -> addOneFormIntrinsicVectorQuantity ( \"my form\" , myForm , polyscopeEdgeOrientations ( mesh ));","title":"1-forms"},{"location":"structures/structure_management/","text":"Intro A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); Then, in a distant part of your code, add a scalar function to it with: polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); This avoids the need to pass a pointer to the structure you created around your entire codebase. Memory management As a general policy, Polyscope always manages its own memory, and will take care of deleting anything it allocated. Whenever a routine returns a pointer (like getStructure() ), it is a non-owning pointer. You should never delete one of these pointers. To delete a structure and free memory, see the removeStructure() methods below. The following structures available in Polyscope. Many more structures are in developement! Surface Mesh Point Cloud in progress : Camera View in progress : Curve in progress : Tet Mesh Registering structures Each structure offers a register___(name, ...) function (like registerPointCloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a Structure* pointer which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. By default, these functions will error-out if a structure with that name is already in use. However, they take an optional boolean argument allowReplacement argument, which can be set to true to replace an existing structure of the same name. The general form is for registering structures is below; it may be useful if you are implementing your own structures. bool registerStructure ( Structure * structure , bool replaceIfPresent = true ) Register a new structure with Polyscope. The structure must have a Structure::name which is unique amongst all registered structures of that type. Polyscope takes ownership of the memory when the structure is registered, and will delete it when no longer needed. Note: most users will create structures via the individual registerPointCloud() (etc) functions, rather than this general form. Accessing structures Polyscope offers two patterns for calling methods on a registered structure: you can either use the pointer returned after structure creation, or refer to the structure by name. #include \"polyscope/surface_mesh.h\" // register a structure polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); // with the pointer psMesh -> addScalarQuantity ( \"some values\" , values ); // by name polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); The former is concise and programmatic, while the latter avoids the need to keep track of a pointer. As before, each structure offers a get___(name) method, like getSurfaceMesh(name) which can be used to get pointer to a structure of that type by name. The general form below may be useful if you are implementing your own structures. Structure * getStructure ( std :: string type , std :: string name = \"\" ) Get a pointer to a registered structure. The type must be the unique string corresponding to the structure type. As a convenience, if the name may be argument omitted only if there is exactly one structure of that type. If not such structure is available, nullptr will be returned. Note: most users will get structures via the individual getPointCloud() (etc) functions, rather than this general form. Removing structures If no longer needed, structures can be removed by name or by pointer. The removing a structure frees the underlying objects, invalidating all references to the structure and its quantities. void removeStructure ( Structure * structure , bool errorIfAbsent = true ) Remove the specified structure and free objects associated with it. If errorIfAbsent == true , and error will be thrown if there is no such structure registered, otherwise the function will return silently. void removeStructure ( std :: string type , std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a type name and name instead. void removeStructure ( std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a name instead. Will fail unless there is exactly one structure with the given name across all structure types.","title":"Structure Management"},{"location":"structures/structure_management/#intro","text":"A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); Then, in a distant part of your code, add a scalar function to it with: polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); This avoids the need to pass a pointer to the structure you created around your entire codebase. Memory management As a general policy, Polyscope always manages its own memory, and will take care of deleting anything it allocated. Whenever a routine returns a pointer (like getStructure() ), it is a non-owning pointer. You should never delete one of these pointers. To delete a structure and free memory, see the removeStructure() methods below. The following structures available in Polyscope. Many more structures are in developement! Surface Mesh Point Cloud in progress : Camera View in progress : Curve in progress : Tet Mesh","title":"Intro"},{"location":"structures/structure_management/#registering-structures","text":"Each structure offers a register___(name, ...) function (like registerPointCloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a Structure* pointer which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. By default, these functions will error-out if a structure with that name is already in use. However, they take an optional boolean argument allowReplacement argument, which can be set to true to replace an existing structure of the same name. The general form is for registering structures is below; it may be useful if you are implementing your own structures. bool registerStructure ( Structure * structure , bool replaceIfPresent = true ) Register a new structure with Polyscope. The structure must have a Structure::name which is unique amongst all registered structures of that type. Polyscope takes ownership of the memory when the structure is registered, and will delete it when no longer needed. Note: most users will create structures via the individual registerPointCloud() (etc) functions, rather than this general form.","title":"Registering structures"},{"location":"structures/structure_management/#accessing-structures","text":"Polyscope offers two patterns for calling methods on a registered structure: you can either use the pointer returned after structure creation, or refer to the structure by name. #include \"polyscope/surface_mesh.h\" // register a structure polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); // with the pointer psMesh -> addScalarQuantity ( \"some values\" , values ); // by name polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); The former is concise and programmatic, while the latter avoids the need to keep track of a pointer. As before, each structure offers a get___(name) method, like getSurfaceMesh(name) which can be used to get pointer to a structure of that type by name. The general form below may be useful if you are implementing your own structures. Structure * getStructure ( std :: string type , std :: string name = \"\" ) Get a pointer to a registered structure. The type must be the unique string corresponding to the structure type. As a convenience, if the name may be argument omitted only if there is exactly one structure of that type. If not such structure is available, nullptr will be returned. Note: most users will get structures via the individual getPointCloud() (etc) functions, rather than this general form.","title":"Accessing structures"},{"location":"structures/structure_management/#removing-structures","text":"If no longer needed, structures can be removed by name or by pointer. The removing a structure frees the underlying objects, invalidating all references to the structure and its quantities. void removeStructure ( Structure * structure , bool errorIfAbsent = true ) Remove the specified structure and free objects associated with it. If errorIfAbsent == true , and error will be thrown if there is no such structure registered, otherwise the function will return silently. void removeStructure ( std :: string type , std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a type name and name instead. void removeStructure ( std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a name instead. Will fail unless there is exactly one structure with the given name across all structure types.","title":"Removing structures"},{"location":"structures/point_cloud/basics/","text":"","title":"Basics"},{"location":"structures/point_cloud/scalar_quantities/","text":"Warning This has not been written yet.","title":"Scalar Quantities"},{"location":"structures/surface_mesh/basics/","text":"","title":"Basics"},{"location":"structures/surface_mesh/indexing_convention/","text":"Default ordering Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors ). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering. Vertices The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setVertexPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for vertex-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Faces The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setFacePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for face-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Edges The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setEdgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for edge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Halfedges The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setHalfedgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Corners The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setCornerPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for corner-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. All at once As a convenience, you can alternately define a single function which passes all permutations needed at the same time. This is useful because you can write a single helper function which defines any necessary permutations for the mesh convention in your codebase; see the geometry-central integration for an example. The permutations should be passed as a std :: array < std :: pair < T , size_t > , 5 > , where T is any type that could be used in the set___Permutation() functions above\u2014one good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Each entry of this array is one of the permutations listed above: [vertices, faces, edges, halfedges, corners]. Any permutations which have size() == 0 will be untouched. The second entry of the pair is the optional size of the target index space, as in expectedSize above. These permutations can either be set with SurfaceMesh::setAllPermutations() , or at construction time via a third argument to registerSurfaceMesh() . SurfaceMesh :: setAllPermutations ( const std :: array < std :: pair < T , size_t > , 5 >& perms ) Set all of the ordering permutations at once, as described above. The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . If the size of your index space is different from size of the default index space, the second component of each pair must give this new size. Otherwise, the second component of the pair may be set to zero, to infer the size of the index space from the maximum index given. Must be set before any quantites are added. SurfaceMesh * polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices , const std :: array < std :: pair < P , size_t > , 5 >& perms , bool replaceIfPresent = true ) Register a mesh and immediately set all custom permutations, as described above. Equivalent to SurfaceMesh * s = registerSurfaceMesh ( name , vertexPositions , faceIndices , replaceIfPresent ); s -> setAllPermutations ( perms ); Other wise behave like the standard registerSurfaceMesh() . The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Must be set before any quantites are added.","title":"Indexing Convention"},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","text":"Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors ). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.","title":"Default ordering"},{"location":"structures/surface_mesh/indexing_convention/#vertices","text":"The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setVertexPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for vertex-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Vertices"},{"location":"structures/surface_mesh/indexing_convention/#faces","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setFacePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for face-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Faces"},{"location":"structures/surface_mesh/indexing_convention/#edges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setEdgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for edge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Edges"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setHalfedgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Halfedges"},{"location":"structures/surface_mesh/indexing_convention/#corners","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setCornerPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for corner-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Corners"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","text":"As a convenience, you can alternately define a single function which passes all permutations needed at the same time. This is useful because you can write a single helper function which defines any necessary permutations for the mesh convention in your codebase; see the geometry-central integration for an example. The permutations should be passed as a std :: array < std :: pair < T , size_t > , 5 > , where T is any type that could be used in the set___Permutation() functions above\u2014one good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Each entry of this array is one of the permutations listed above: [vertices, faces, edges, halfedges, corners]. Any permutations which have size() == 0 will be untouched. The second entry of the pair is the optional size of the target index space, as in expectedSize above. These permutations can either be set with SurfaceMesh::setAllPermutations() , or at construction time via a third argument to registerSurfaceMesh() . SurfaceMesh :: setAllPermutations ( const std :: array < std :: pair < T , size_t > , 5 >& perms ) Set all of the ordering permutations at once, as described above. The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . If the size of your index space is different from size of the default index space, the second component of each pair must give this new size. Otherwise, the second component of the pair may be set to zero, to infer the size of the index space from the maximum index given. Must be set before any quantites are added. SurfaceMesh * polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices , const std :: array < std :: pair < P , size_t > , 5 >& perms , bool replaceIfPresent = true ) Register a mesh and immediately set all custom permutations, as described above. Equivalent to SurfaceMesh * s = registerSurfaceMesh ( name , vertexPositions , faceIndices , replaceIfPresent ); s -> setAllPermutations ( perms ); Other wise behave like the standard registerSurfaceMesh() . The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Must be set before any quantites are added.","title":"All at once"},{"location":"structures/surface_mesh/scalar_quantities/","text":"","title":"Scalar Quantities"},{"location":"structures/surface_mesh/vector_quantities/","text":"","title":"Vector Quantities"}]}