{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polyscope is a C++/Python viewer and user interface for 3D data such as meshes and point clouds. It allows you to register your data and quickly generate informative and beautiful visualizations, either programmatically or via a dynamic GUI. Polyscope is designed to be lightweight\u2014it does not \u201ctake ownership\u201d over your entire program, and it is easy to integrate with existing codebases and popular libraries. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code. Polyscope uses a paradigm of structures and quantities . A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field. When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling visibility, color-mapping data and adjusting maps, \u201cpicking\u201d to click in the scene and query numerical quantities, etc. Note: There are two variants of this documentation, for C++ and Python. Use the buttons on the top bar to change language. A simple workflow for visualizing data in Polyscope looks like: C++ #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" // Initialize polyscope polyscope :: init (); // Register a point cloud // `points` is a Nx3 array-like container of points polyscope :: registerPointCloud ( \"my points\" , points ) // Register a surface mesh structure // `meshVerts` is a Vx3 array-like container of vertex positions // `meshFaces` is a Fx3 array-like container of face indices polyscope :: registerSurfaceMesh ( \"my mesh\" , meshVerts , meshFaces ); // Add a scalar and a vector function defined on the mesh // `scalarQuantity` is a length V array-like container of values // `vectorQuantity` is an Fx3 array-like container of vectors per face polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addVertexScalarQuantity ( \"my_scalar\" , scalarQuantity ); polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addFaceVectorQuantity ( \"my_vector\" , vectorQuantity ); // View the point cloud and mesh we just registered in the 3D UI polyscope :: show (); Python import polyscope as ps # Initialize polyscope ps . init () ### Register a point cloud # `my_points` is a Nx3 numpy array ps . register_point_cloud ( \"my points\" , my_points ) ### Register a mesh # `verts` is a Nx3 numpy array of vertex positions # `faces` is a Fx3 array of indices, or a nested list ps . register_surface_mesh ( \"my mesh\" , verts , faces , smooth_shade = True ) # Add a scalar function and a vector function defined on the mesh # vertex_scalar is a length V numpy array of values # face_vectors is an Fx3 array of vectors per face ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"my_scalar\" , vertex_scalar , defined_on = 'vertices' , cmap = 'blues' ) ps . get_surface_mesh ( \"my mesh\" ) . add_vector_quantity ( \"my_vector\" , face_vectors , defined_on = 'faces' , color = ( 0.2 , 0.5 , 0.5 )) # View the point cloud and mesh we just registered in the 3D UI ps . show () Polyscope is designed to make your life easier. It is simple to build, and fewer than 10 lines of code should be sufficient to start visualizing. In C++, some template magic means Polyscope can probably accept the data types you\u2019re already using! Author: Nicholas Sharp If Polyscope contributes to an academic publication, cite it as: @misc { polyscope , title = {Polyscope} , author = {Nicholas Sharp and others} , note = {www.polyscope.run} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"data_adaptors/","text":"Polyscope is designed as a lightweight general-purpose 3D visualization library. But there\u2019s a problem, because different codebases uses different C++ types to store their data: is an array of scalars a std::vector<double> or an Eigen::VectorXf or some other internal type? Codebases for 3D geometry are particularly guilty of this: there are probably several hundred distinct 3D vector x-y-z classes floating around github. Rather than forcing the user to manually convert their data types to some Polyscope types, we implement a series of templated adaptor functions, which attempt to read from the user types via a common set of strategies. These adaptors are applied to the inputs to nearly all Polyscope functions, allowing them to automatically accept user-defined types as inputs. You don\u2019t need to do anything special to use these adaptors! They are applied internally to the arguments of nearly every Polyscope function, like the vertices and faces arguments of registerSurfaceMesh(\"name\", vertices, faces) . This section outlines how the adaptors will try to read from your data, and how to extend them for unusual datatypes which are not automatically handled. These functions live in #include \"polyscope/standardize_data_array.h\" . It\u2019s fairly well-commented\u2014 check it out to see how all this works under the hood! Fixed size vector types These are 2D or 3D vectors whose size are known at compile time, commonly used to represent things like positions (3D), or UV coordinates (2D). Examples of 3D vector types that Polyscope can read from out of the box include glm::vec3 , Eigen::Vector3d , and std::array<double, 3> (likewise for 2D). Hierarchy Polyscope will attempt to access an input 2D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec[0] and vec[1] ) members x , y (like vec.x and vec.y ) members u , v (like vec.u and vec.v ) members functions real() / imag() (like vec.real() and vec.imag() ) Polyscope will attempt to access an input 3D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec[0] , vec[1] , and vec[2] ) members x , y , z (like vec.x , vec.y , and vec.z ) using Eigen fixed-size vectorizable types If you are using fixed-sized, vectorizable Eigen types like Eigen::Vector2f and Eigen::Vector4f as your 2D/3D vector types, there are special, tricky alignment rules imposed by Eigen which must be respected. For instance, a std::vector<Eigen::Vector2f> is not a valid type; using it will lead to tricky-to-debug segfaults. Polyscope makes a best effort to avoid problems when the caller\u2019s fixed vector type has alignment constraints, but beware\u2014these are dangerous waters. See Eigen\u2019s documentation here and here for more information. extending vector access Extending Suppose you have an in-house vector type which cannot be accessed by any strategy in the hierarchy above. You can define a custom function that accesses the elements of your type: YOUR_TYPES_SCALAR adaptorF_custom_accessVector2Value ( const YOUR_TYPE & v , unsigned int ind ); The array adaptors will pick up this function and use it to access your type. Example: // A vector2 type with unusual access struct UserVector2Custom { double foo ; double bar ; }; // Define an accessor to teach Polyscope to read from your type double adaptorF_custom_accessVector2Value ( const UserVector2Custom & v , unsigned int ind ) { if ( ind == 0 ) return v . foo ; if ( ind == 1 ) return v . bar ; throw std :: logic_error ( \"bad access\" ); return -1. ; } // Now Polyscope functions can take this type as input! The same principle applies for 3D vectors, where the relevant function is named YOUR_TYPES_SCALAR adaptorF_custom_accessVector3Value ( const YOUR_TYPE & v , unsigned int ind ); Array size The three array adaptor variants below (scalar array, vector array, and nested array) all assume the ability to read the size of an input array. Hierarchy Polyscope will attempt to read the length of an input array in the following ways, in decreasing order of precedence: any user-defined function (see below) a .rows() member function (like inputData.rows() ) a .size() member function (like inputData.size() ) extending array size Extending Suppose you have an in-house array type whose length cannot be read by any strategy in the hierarchy above. You can define a custom function that reads the length like: size_t adaptorF_custom_size ( const YOUR_ARRAY_TYPE & c ); The array adaptors will pick up this function and use it to access your type. Example: // Array with custom length function called \"bigness()\" struct UserArray { std :: vector < double > myData ; size_t bigness () const { return myData . size (); } }; // Size function for custom array size_t adaptorF_custom_size ( const UserArray & c ) { return c . bigness (); } Scalar arrays A scalar array is a long list of values, like a float at each point in a point cloud, or an int at each vertex of a mesh. We will use the type S to refer to the inner scalar type of an array, like float in std::vector<float> . Examples of scalar arrays that Polyscope can read from out of the box include std::vector<float> , Eigen::VectorXd , and std::list<int> . Hierarchy Polyscope will attempt to access an input scalar array in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed index access (like array[i] ) parenthesis index access (like array(i) ) for-each iteration (like array.begin() , array.end() ) extending scalar array access Extending Suppose you have an in-house array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std::vector<S> like std :: vector < YOUR_SCALAR_TYPE > adaptorF_custom_convertToStdVector ( const YOUR_ARRAY_TYPE & c ) { The array adaptors will pick up this function and use it to access your type. Example: // User array with unusual access struct UserArrayFuncAccess { std :: vector < double > myData ; size_t size () const { return myData . size (); } }; std :: vector < double > adaptorF_custom_convertToStdVector ( const UserArrayFuncAccess & c ) { std :: vector < double > out ; for ( auto x : c . myData ) { out . push_back ( x ); } return out ; } Arrays of vectors These are arrays of values where each element of the array is itself a fixed-size vector type, like the 3D position of each point in a point cloud, or a list of edges in a graph. Note that these arrays must have an inner dimension which is fixed and known at compile time. Examples of vector arrays that Polyscope can read from out of the box include std::vector<glm::vec3> , Eigen::Matrx<N,3> , and std::list<std::array<int,2>> . Hierarchy Polyscope will attempt to access an input array of vectors in the following ways, in order of decreasing precedence: any user-defined function (see below) dense parenthesis access (like array(i,j) ) double bracket access (like array[i][j] ) outer type bracket-accessible, inner type anything convertible to Vector2/3 (like array[i].x ) outer type iterable, inner type anything convertible to Vector2/3 (like for(auto vec : array) and vec.u ). outer type iterable, inner type bracket-accessible (like for(auto vec : array) and vec[7] ) Notice that two these options make use of the fixed-sized vector adaptors . Once Polyscope can read the elements of SOME_VEC3_TYPE , it can also read from std::vector<SOME_VEC3_TYPE> , etc. The sizes of the inner vector type are generally not checked by Polyscope, so be sure you\u2019re passing in something with the right dimensions! If a function expects an array of 3D vectors, don\u2019t give it an array of 2D vectors. extending array-of-vectors access Extending Suppose you have an in-house array-of-vectors type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std::vector<S> like std :: vector < std :: array < SCALAR_T , N >> adaptorF_custom_convertArrayOfVectorToStdVector ( const YOUR_ARRAY_TYPE & c ) The array adaptors will pick up this function and use it to access your type. Really, the return type of this method can anything that supports .size() and bracket access; std::vector<std::vector<>> would also work. The size of the inner vector is not checked, so be sure it\u2019s right! Example: // An array of vectors with an unusual access scheme struct UserArrayVectorCustom { std :: list < SOME_TYPE > vals ; size_t size () const { return vals . size (); } }; // Define a custom access function std :: vector < std :: array < double , 3 >> adaptorF_custom_convertArrayOfVectorToStdVector ( const UserArrayVectorCustom & inputData ) { std :: vector < std :: array < double , 3 >> out ; for ( auto v : inputData . vals ) { out . push_back ({ v . x (), v . y (), v . z ()}); } return out ; } Nested arrays These are arrays-of-arrays, like the list of vertex indices for each face in a polygon mesh. Unlike the arrays-of-vectors above, the dimensions of the inner arrays need not be known at compile time, and can vary (though arrays with fixed-sized inner dimension are also valid input). Examples of vector arrays that Polyscope can read from out of the box include std::vector<std::vector<int>> , Eigen::Matrix<double,N,3> , and std::vector<std::list<size_t>> . Hierarchy Polyscope will attempt to access a nested array in the following ways, in order of decreasing precedence: any user defined function dense callable (parenthesis) access on a type that supports array.rows() and array.cols() (like array(i,j) ). outer type bracket-accessible, inner type anything that can be accessed as a scalar array (like array[i][j] ) outer type parenthesis-accessible, inner type anything that can be accessed as a scalar array (like array(j)[i] ) outer type iterable, inner type anything that can be accessed as a scalar array (like for(auto inner : array) and inner[7] ). Notice that several of these options make use of the scalar array adaptors . Once Polyscope can read from YOUR_ARRAY<S> , it can also read from std::vector<YOUR_ARRAY<S>> , etc. extending nested array access Extending Suppose you have an in-house nested array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std::vector<std::vector<S>> like std :: vector < std :: vector < S >> adaptorF_custom_convertNestedArrayToStdVector ( const YOUR_NESTED_ARRAY & inputData ) { The array adaptors will pick up this function and use it to access your type. Example: // A nested list type with unusual access struct UserNestedListCustom { std :: list < std :: vector < int >> vals ; size_t size () const { return vals . size (); } }; std :: vector < std :: vector < int >> adaptorF_custom_convertNestedArrayToStdVector ( const UserNestedListCustom & inputData ) { std :: vector < std :: vector < int >> out ; for ( auto v : inputData . vals ) { std :: vector < int > inner ; for ( auto x : v ) { inner . push_back ( x ); } out . push_back ( inner ); } return out ; } Debugging One downside to our \u201cclever\u201d use of templates is that compiler error messages can be borderline incomprehensible. Generally, the best debugging strategy is to carefully read the documentation and ensure you are passing in data that makes sense. In most cases, the problem is something simple, like passing a 3D vector where a 2D vector is needed, or mixing up the order of arguments. However, if you are deep in the weeds trying to debug why your type isn\u2019t matching against the template hierarchy (or why a custom function isn\u2019t being used), consider adding the define #define POLYSCOPE_NO_STANDARDIZE_FALLTHROUGH anywhere before the Polyscope includes. This will cause most compilers to print the long scary list of all template substitutions which were considered and rejected, which you can slowly parse to aid you on your quest.","title":"Data Adaptors"},{"location":"data_adaptors/#fixed-size-vector-types","text":"These are 2D or 3D vectors whose size are known at compile time, commonly used to represent things like positions (3D), or UV coordinates (2D). Examples of 3D vector types that Polyscope can read from out of the box include glm::vec3 , Eigen::Vector3d , and std::array<double, 3> (likewise for 2D).","title":"Fixed size vector types"},{"location":"data_adaptors/#hierarchy","text":"Polyscope will attempt to access an input 2D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec[0] and vec[1] ) members x , y (like vec.x and vec.y ) members u , v (like vec.u and vec.v ) members functions real() / imag() (like vec.real() and vec.imag() ) Polyscope will attempt to access an input 3D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec[0] , vec[1] , and vec[2] ) members x , y , z (like vec.x , vec.y , and vec.z ) using Eigen fixed-size vectorizable types If you are using fixed-sized, vectorizable Eigen types like Eigen::Vector2f and Eigen::Vector4f as your 2D/3D vector types, there are special, tricky alignment rules imposed by Eigen which must be respected. For instance, a std::vector<Eigen::Vector2f> is not a valid type; using it will lead to tricky-to-debug segfaults. Polyscope makes a best effort to avoid problems when the caller\u2019s fixed vector type has alignment constraints, but beware\u2014these are dangerous waters. See Eigen\u2019s documentation here and here for more information. extending vector access","title":"Hierarchy"},{"location":"data_adaptors/#extending","text":"Suppose you have an in-house vector type which cannot be accessed by any strategy in the hierarchy above. You can define a custom function that accesses the elements of your type: YOUR_TYPES_SCALAR adaptorF_custom_accessVector2Value ( const YOUR_TYPE & v , unsigned int ind ); The array adaptors will pick up this function and use it to access your type. Example: // A vector2 type with unusual access struct UserVector2Custom { double foo ; double bar ; }; // Define an accessor to teach Polyscope to read from your type double adaptorF_custom_accessVector2Value ( const UserVector2Custom & v , unsigned int ind ) { if ( ind == 0 ) return v . foo ; if ( ind == 1 ) return v . bar ; throw std :: logic_error ( \"bad access\" ); return -1. ; } // Now Polyscope functions can take this type as input! The same principle applies for 3D vectors, where the relevant function is named YOUR_TYPES_SCALAR adaptorF_custom_accessVector3Value ( const YOUR_TYPE & v , unsigned int ind );","title":"Extending"},{"location":"data_adaptors/#array-size","text":"The three array adaptor variants below (scalar array, vector array, and nested array) all assume the ability to read the size of an input array.","title":"Array size"},{"location":"data_adaptors/#hierarchy_1","text":"Polyscope will attempt to read the length of an input array in the following ways, in decreasing order of precedence: any user-defined function (see below) a .rows() member function (like inputData.rows() ) a .size() member function (like inputData.size() ) extending array size","title":"Hierarchy"},{"location":"data_adaptors/#extending_1","text":"Suppose you have an in-house array type whose length cannot be read by any strategy in the hierarchy above. You can define a custom function that reads the length like: size_t adaptorF_custom_size ( const YOUR_ARRAY_TYPE & c ); The array adaptors will pick up this function and use it to access your type. Example: // Array with custom length function called \"bigness()\" struct UserArray { std :: vector < double > myData ; size_t bigness () const { return myData . size (); } }; // Size function for custom array size_t adaptorF_custom_size ( const UserArray & c ) { return c . bigness (); }","title":"Extending"},{"location":"data_adaptors/#scalar-arrays","text":"A scalar array is a long list of values, like a float at each point in a point cloud, or an int at each vertex of a mesh. We will use the type S to refer to the inner scalar type of an array, like float in std::vector<float> . Examples of scalar arrays that Polyscope can read from out of the box include std::vector<float> , Eigen::VectorXd , and std::list<int> .","title":"Scalar arrays"},{"location":"data_adaptors/#hierarchy_2","text":"Polyscope will attempt to access an input scalar array in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed index access (like array[i] ) parenthesis index access (like array(i) ) for-each iteration (like array.begin() , array.end() ) extending scalar array access","title":"Hierarchy"},{"location":"data_adaptors/#extending_2","text":"Suppose you have an in-house array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std::vector<S> like std :: vector < YOUR_SCALAR_TYPE > adaptorF_custom_convertToStdVector ( const YOUR_ARRAY_TYPE & c ) { The array adaptors will pick up this function and use it to access your type. Example: // User array with unusual access struct UserArrayFuncAccess { std :: vector < double > myData ; size_t size () const { return myData . size (); } }; std :: vector < double > adaptorF_custom_convertToStdVector ( const UserArrayFuncAccess & c ) { std :: vector < double > out ; for ( auto x : c . myData ) { out . push_back ( x ); } return out ; }","title":"Extending"},{"location":"data_adaptors/#arrays-of-vectors","text":"These are arrays of values where each element of the array is itself a fixed-size vector type, like the 3D position of each point in a point cloud, or a list of edges in a graph. Note that these arrays must have an inner dimension which is fixed and known at compile time. Examples of vector arrays that Polyscope can read from out of the box include std::vector<glm::vec3> , Eigen::Matrx<N,3> , and std::list<std::array<int,2>> .","title":"Arrays of vectors"},{"location":"data_adaptors/#hierarchy_3","text":"Polyscope will attempt to access an input array of vectors in the following ways, in order of decreasing precedence: any user-defined function (see below) dense parenthesis access (like array(i,j) ) double bracket access (like array[i][j] ) outer type bracket-accessible, inner type anything convertible to Vector2/3 (like array[i].x ) outer type iterable, inner type anything convertible to Vector2/3 (like for(auto vec : array) and vec.u ). outer type iterable, inner type bracket-accessible (like for(auto vec : array) and vec[7] ) Notice that two these options make use of the fixed-sized vector adaptors . Once Polyscope can read the elements of SOME_VEC3_TYPE , it can also read from std::vector<SOME_VEC3_TYPE> , etc. The sizes of the inner vector type are generally not checked by Polyscope, so be sure you\u2019re passing in something with the right dimensions! If a function expects an array of 3D vectors, don\u2019t give it an array of 2D vectors. extending array-of-vectors access","title":"Hierarchy"},{"location":"data_adaptors/#extending_3","text":"Suppose you have an in-house array-of-vectors type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std::vector<S> like std :: vector < std :: array < SCALAR_T , N >> adaptorF_custom_convertArrayOfVectorToStdVector ( const YOUR_ARRAY_TYPE & c ) The array adaptors will pick up this function and use it to access your type. Really, the return type of this method can anything that supports .size() and bracket access; std::vector<std::vector<>> would also work. The size of the inner vector is not checked, so be sure it\u2019s right! Example: // An array of vectors with an unusual access scheme struct UserArrayVectorCustom { std :: list < SOME_TYPE > vals ; size_t size () const { return vals . size (); } }; // Define a custom access function std :: vector < std :: array < double , 3 >> adaptorF_custom_convertArrayOfVectorToStdVector ( const UserArrayVectorCustom & inputData ) { std :: vector < std :: array < double , 3 >> out ; for ( auto v : inputData . vals ) { out . push_back ({ v . x (), v . y (), v . z ()}); } return out ; }","title":"Extending"},{"location":"data_adaptors/#nested-arrays","text":"These are arrays-of-arrays, like the list of vertex indices for each face in a polygon mesh. Unlike the arrays-of-vectors above, the dimensions of the inner arrays need not be known at compile time, and can vary (though arrays with fixed-sized inner dimension are also valid input). Examples of vector arrays that Polyscope can read from out of the box include std::vector<std::vector<int>> , Eigen::Matrix<double,N,3> , and std::vector<std::list<size_t>> .","title":"Nested arrays"},{"location":"data_adaptors/#hierarchy_4","text":"Polyscope will attempt to access a nested array in the following ways, in order of decreasing precedence: any user defined function dense callable (parenthesis) access on a type that supports array.rows() and array.cols() (like array(i,j) ). outer type bracket-accessible, inner type anything that can be accessed as a scalar array (like array[i][j] ) outer type parenthesis-accessible, inner type anything that can be accessed as a scalar array (like array(j)[i] ) outer type iterable, inner type anything that can be accessed as a scalar array (like for(auto inner : array) and inner[7] ). Notice that several of these options make use of the scalar array adaptors . Once Polyscope can read from YOUR_ARRAY<S> , it can also read from std::vector<YOUR_ARRAY<S>> , etc. extending nested array access","title":"Hierarchy"},{"location":"data_adaptors/#extending_4","text":"Suppose you have an in-house nested array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std::vector<std::vector<S>> like std :: vector < std :: vector < S >> adaptorF_custom_convertNestedArrayToStdVector ( const YOUR_NESTED_ARRAY & inputData ) { The array adaptors will pick up this function and use it to access your type. Example: // A nested list type with unusual access struct UserNestedListCustom { std :: list < std :: vector < int >> vals ; size_t size () const { return vals . size (); } }; std :: vector < std :: vector < int >> adaptorF_custom_convertNestedArrayToStdVector ( const UserNestedListCustom & inputData ) { std :: vector < std :: vector < int >> out ; for ( auto v : inputData . vals ) { std :: vector < int > inner ; for ( auto x : v ) { inner . push_back ( x ); } out . push_back ( inner ); } return out ; }","title":"Extending"},{"location":"data_adaptors/#debugging","text":"One downside to our \u201cclever\u201d use of templates is that compiler error messages can be borderline incomprehensible. Generally, the best debugging strategy is to carefully read the documentation and ensure you are passing in data that makes sense. In most cases, the problem is something simple, like passing a 3D vector where a 2D vector is needed, or mixing up the order of arguments. However, if you are deep in the weeds trying to debug why your type isn\u2019t matching against the template hierarchy (or why a custom function isn\u2019t being used), consider adding the define #define POLYSCOPE_NO_STANDARDIZE_FALLTHROUGH anywhere before the Polyscope includes. This will cause most compilers to print the long scary list of all template substitutions which were considered and rejected, which you can slowly parse to aid you on your quest.","title":"Debugging"},{"location":"about/contributing/","text":"Polyscope is an open-source project, and you are encouraged to contribute! A few high-level guidelines: All contributions must be released under Polyscope\u2019s MIT license. Significant new features need to be documented! This documentation lives in polyscope-docs . You can and should submit a request there at the same time as adding code to Polyscope. The documentation uses markdown. Modifying the docs amounts to editing a source file and rebuilding the site source. The the nodes there in README.md . To add a new page to the documentation, edit mkdocs.yml . If adding a new structure or quantity, be sure to make use of the data adaptors for all user inputs. See point_cloud.h for an example. Be sure to run the unit tests (see building ), and add tests for any new features. Add a blurb to the release notes ! We\u2019ll expand these guidelines as Polyscope grows.","title":"Contributing"},{"location":"about/contributors/","text":"This page lists people who have contributed something to Polyscope, in no particular order. Thank you so much for you work! If you would like to be listed on this page, don\u2019t hesitate to ask. Nicholas Sharp Keenan Crane Yousuf Soliman Rohan Sawhney Chris Yu Mark Gillespie Connor Lin","title":"Contributors"},{"location":"about/dependencies/","text":"Polyscope stands on the shoulders of many outstanding open-source projects. These dependencies are all permissively licensed , and bundled with the project ; we just list them here to give due credit! Name Purpose Link GLFW Window and input management with openGL glfw.org Dear ImGui GUI interface (buttons, text boxes, etc) github.com/ocornut/imgui glad OpenGL loader (used on Windows/Linux) github.com/Dav1dde/glad glm Vector math and glsl utilities glm.g-truc.net stb Header-only libraries, esp. image loading github.com/nothings/stb json Read/write json text github.com/nlohmann/json mkdocs Doc generation mkdocs.org mkdocs-material Doc generation squidfunk.github.io/mkdocs-material/ googletest Unit testing github.com/google/googletest pybind11 (Python only) Python bindings github.com/pybind/pybind11 Eigen (Python only) numpy interop for bindings eigen.tuxfamily.org Additionally, Polyscope includes a few public-domain / permissively licensed assets. Some of the built-in matcaps are from the Blender project, and others were rendered using Blender. The built-in colormaps come from several sources as detailed on the colormap page , including Smith et. al. , cmocean , and matplotlib . The concrete texture on the ground is from cc0textures.com . Thank you, artists!","title":"Dependencies"},{"location":"about/license/","text":"Polyscope is released under an MIT license , and all of its dependencies are under similar permissive licenses (MIT, zlib, or public domain). Polyscope is created and maintained by academics: citations let us know our work is having impact! Please cite Polyscope or otherwise give a shout-out if and when it contributes to published works. @misc { polyscope , title = {Polyscope} , author = {Nicholas Sharp and others} , note = {www.polyscope.run} , year = {2019} }","title":"License"},{"location":"about/release_notes/","text":"Version 1.2.0 TODO Add volume meshes, slice planes, and transparent rendering. Support soft ground shadows, point clouds with variable radius, and back face culling options for surface meshes. Better programmatic camera controls. Generalize isoline support for all scalar quantities. Change the font. Overhaul to a more flexible shader system, internally, change default screenshot format back to png , fix size validation bugs with surface mesh, require explicit tangent spaces. Version 1.1.0 107930b Mar 30, 2020: Select backend at runtime, improve backend support in build system, keep window invisible until first show, bugfixes, add Windows builds to CI. Version 1.0.0 6f44d1a Mar 25, 2020: Overhaul rendering backend, generalize materials, raycast vectors and cylinders, linear lighting workflow, custom matcaps, mocked backend, general unit tests. Jan 29, 2020 92b45be : Many bugfixes, small features, and general API cleanup. Encapsulate parameters for structures and quantities. Use scaled values and persistent values to track parameters. Additional camera navigation controls. Simplify picking API. Sept 19, 2019 2f83da2 : Add streamline visualization for vector fields (previously existed but was removed) Aug 11, 2019 dd4b36f : Add curve network quantity. July 20, 2019 afe7c5e : Add helpers for 2D visualization. Move templates on structure constructors for consistency. July 18, 2019 8514792 : Completely-rewritten Polyscope version 2.0 released. This new version is decoupled from any particular geometry codebase, and is designed to be easy to integrate with existing projects.","title":"Release Notes"},{"location":"basics/camera_controls/","text":"These settings affect the 3D camera view in polyscope. It is often convenient to set them just before calling polyscope::init , but they may set be anywhere. #include \"polyscope/polyscope.h\" // a few camera options polyscope :: view :: upDir = UpDir :: ZUp ; polyscope :: view :: style = NavigateStyle :: Free ; // initialize polyscope :: init (); // set the camera pose explicitly polyscope :: view :: lookAt ( glm :: vec3 { 10. , 10. , 0. }, glm :: vec3 { 0. , 2. , 0. }); // show the GUI polyscope :: show (); Options NavigateStyle view :: style navigation style The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse. This value can be manually set under the view menu of the ui. Programmatically, the enum view::NavigateStyle contains various settings: NavigateStyle::Turntable The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions. NavigateStyle::Free The camera is free to take any orientation, rotation is always about relative to the current camera. NavigateStyle::Planar The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data ). Example: polyscope :: view :: style = NavigateStyle :: Free ; UpDir view :: upDir up direction 3D data is typically oriented with some natural \u201cup\u201d direction, but not everyone agrees as to which coordinate axis is \u201cup\u201d. Computer graphics and vision often use a Y-up convention, where science and engineering more commonly use Z-up. This setting affects default orientation of the view, the behavior of some navigation styles (esp. Turntable ), and the orientation of the ground plane. This value can be manually set under the view menu of the ui. Programmatically, the enum view::UpDir contains various settings: UpDir::XUp The positive X-axis is up. UpDir::NegXUp The negative X-axis is up. UpDir::YUp The positive Y-axis is up. UpDir::NegYUp The negative Y-axis is up. UpDir::ZUp The positive Z-axis is up. UpDir::NegZUp The negative Z-axis is up. Default: UpDir::Yup . Example: polyscope :: view :: upDir = UpDir :: ZUp ; void lookAt ( glm :: vec3 cameraLocation , glm :: vec3 target , bool flyTo = false ) look at Set the camera to be located at the 3D position cameraLocation and looking at the 3D position target , both in world coordinates. The up direction for the camera is set to be the scene\u2019s up direction. If flyTo=true , the camera will smoothly animate to the new configuration. Example: polyscope :: view :: lookAt ( glm :: vec3 { 10. , 10. , 0. }, glm :: vec3 { 0. , 2. , 0. }); void lookAt ( glm :: vec3 cameraLocation , glm :: vec3 target , glm :: vec3 upDir , bool flyTo = false ) Set the camera to be located at the 3D position cameraLocation and looking at the 3D position target , oriented with the up direction upDir , all in world coordinates. If flyTo=true , the camera will smoothly animate to the new configuration. Note that setting the up direction for the camera view with this function is separate from the scene\u2019s view::upDir parameter, which affects things like ground plane placement, and manual view manipulation. Example: polyscope :: view :: lookAt ( glm :: vec3 { 10. , 10. , 0. }, glm :: vec3 { 0. , 2. , 0. }, glm :: vec3 { 0. , 0. , 1. }); void resetCameraToHomeView () reset camera to home view Reset the camera view to the home view (a reasonable default view scaled to the scene). Note: The \u201chome\u201d view is dependent on the data in the scene; it is computed from the bounding boxes of all registered structures to ensure that everything is nicely scaled and in view. As such, one should generally call this function after registering data. Example: polyscope :: view :: resetCameraToHomeView ();","title":"Camera Controls"},{"location":"basics/camera_controls/#options","text":"NavigateStyle view :: style","title":"Options"},{"location":"basics/camera_controls/#navigation-style","text":"The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse. This value can be manually set under the view menu of the ui. Programmatically, the enum view::NavigateStyle contains various settings: NavigateStyle::Turntable The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions. NavigateStyle::Free The camera is free to take any orientation, rotation is always about relative to the current camera. NavigateStyle::Planar The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data ). Example: polyscope :: view :: style = NavigateStyle :: Free ; UpDir view :: upDir","title":"navigation style"},{"location":"basics/camera_controls/#up-direction","text":"3D data is typically oriented with some natural \u201cup\u201d direction, but not everyone agrees as to which coordinate axis is \u201cup\u201d. Computer graphics and vision often use a Y-up convention, where science and engineering more commonly use Z-up. This setting affects default orientation of the view, the behavior of some navigation styles (esp. Turntable ), and the orientation of the ground plane. This value can be manually set under the view menu of the ui. Programmatically, the enum view::UpDir contains various settings: UpDir::XUp The positive X-axis is up. UpDir::NegXUp The negative X-axis is up. UpDir::YUp The positive Y-axis is up. UpDir::NegYUp The negative Y-axis is up. UpDir::ZUp The positive Z-axis is up. UpDir::NegZUp The negative Z-axis is up. Default: UpDir::Yup . Example: polyscope :: view :: upDir = UpDir :: ZUp ; void lookAt ( glm :: vec3 cameraLocation , glm :: vec3 target , bool flyTo = false )","title":"up direction"},{"location":"basics/camera_controls/#look-at","text":"Set the camera to be located at the 3D position cameraLocation and looking at the 3D position target , both in world coordinates. The up direction for the camera is set to be the scene\u2019s up direction. If flyTo=true , the camera will smoothly animate to the new configuration. Example: polyscope :: view :: lookAt ( glm :: vec3 { 10. , 10. , 0. }, glm :: vec3 { 0. , 2. , 0. }); void lookAt ( glm :: vec3 cameraLocation , glm :: vec3 target , glm :: vec3 upDir , bool flyTo = false ) Set the camera to be located at the 3D position cameraLocation and looking at the 3D position target , oriented with the up direction upDir , all in world coordinates. If flyTo=true , the camera will smoothly animate to the new configuration. Note that setting the up direction for the camera view with this function is separate from the scene\u2019s view::upDir parameter, which affects things like ground plane placement, and manual view manipulation. Example: polyscope :: view :: lookAt ( glm :: vec3 { 10. , 10. , 0. }, glm :: vec3 { 0. , 2. , 0. }, glm :: vec3 { 0. , 0. , 1. }); void resetCameraToHomeView ()","title":"look at"},{"location":"basics/camera_controls/#reset-camera-to-home-view","text":"Reset the camera view to the home view (a reasonable default view scaled to the scene). Note: The \u201chome\u201d view is dependent on the data in the scene; it is computed from the bounding boxes of all registered structures to ensure that everything is nicely scaled and in view. As such, one should generally call this function after registering data. Example: polyscope :: view :: resetCameraToHomeView ();","title":"reset camera to home view"},{"location":"basics/initializing/","text":"Initializing Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: #include \"polyscope/polyscope.h\" // Initialize polyscope, creating graphics contexts and constructing a window. // Should be called exactly once. polyscope :: init (); /* * build visualizations, here or in distant code * */ // Pass control flow to polyscope, displaying the interactive window. // Function will return when user closes the window. polyscope :: show (); // More of your code // ... // Show again. Data is preserved between calls to show() // unless explicitly removed. polyscope :: show (); Functions #include \"polyscope/polyscope.h\" init ( std :: string backend = \"\" ) init() Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. backend is an optional specifier for which rendering backend to use, passing \"\" selects a reasonable default backend. Generally, you should not need to manually set the backend. show () show() Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window. This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to show() . You can even nest calls to show() \u2014for instance, if the user clicks a button in your callback which executes some function, you can invoke show() again within that function for immediate debugging. Closing the nested window will then \u201cpop back\u201d to continue displaying the previously shown GUI.","title":"Initializing"},{"location":"basics/initializing/#initializing","text":"Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: #include \"polyscope/polyscope.h\" // Initialize polyscope, creating graphics contexts and constructing a window. // Should be called exactly once. polyscope :: init (); /* * build visualizations, here or in distant code * */ // Pass control flow to polyscope, displaying the interactive window. // Function will return when user closes the window. polyscope :: show (); // More of your code // ... // Show again. Data is preserved between calls to show() // unless explicitly removed. polyscope :: show ();","title":"Initializing"},{"location":"basics/initializing/#functions","text":"#include \"polyscope/polyscope.h\" init ( std :: string backend = \"\" )","title":"Functions"},{"location":"basics/initializing/#init","text":"Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. backend is an optional specifier for which rendering backend to use, passing \"\" selects a reasonable default backend. Generally, you should not need to manually set the backend. show ()","title":"init()"},{"location":"basics/initializing/#show","text":"Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window. This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to show() . You can even nest calls to show() \u2014for instance, if the user clicks a button in your callback which executes some function, you can invoke show() again within that function for immediate debugging. Closing the nested window will then \u201cpop back\u201d to continue displaying the previously shown GUI.","title":"show()"},{"location":"basics/parameters/","text":"Many structures and quantities in Polyscope have optional values which can be set to control their appearance or behavior, such as the radius of points in a point cloud or the color of a mesh. These values can generally be manually adjusted in the GUI, or set programmatically in code. This page documents special features in Polyscope which provide extra functionality while setting these parameters. Persistent values In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values . Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match. Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. PointCloud * psCloud = polyscope :: getPointCloud ( \"my cloud\" ); psCloud -> setPointColor ( glm :: vec3 ( 0.5 , 0.5 , 0.5 )); // the persistent value is recorded in the cache // ... later ... PointCloud * newCloud = polyscope :: registerPointCloud ( \"my cloud\" , new_points ); // newCloud will automatically pick up the pointColor we set above, // since this point cloud has the same name Note that this persistence behavior applies even when variables are manually manipulated in the GUI. for implementors If writing custom Polyscope library code (e.g. your own custom structures and quantities), here\u2019s what you need to know to use persistent values. The class PersistentValue<T> is templated on the underlying scalar type, like PersistentValue<double> . Only a predefined set of types can be used as template arguments because the corresponding global cache must be allocated. See persistent_value.h for a listing, which currently includes bool , float , double , ScaledValue<float> , ScaledValue<double> , glm::vec3 , and std::string . Construct a persistent value like PersistentValue < float > myVar ( \"unique_name\" , 0.5 ) the variable will the cached value if one exists, and if not take the value 0.5 (and add it to the cache). Remember to use a globally unique name for the for the name argument; in structures you can use a concatenation of the type name, structure name, and (if applicable) quantity name. To access a persistent value, call myVar.get() , which returns a reference to the underlying value. In some occasions, in particular when using ImGui, you may need to write to a value directly via the pointer from &myVar.get() . This is problematic, because the variable does not know it has been written to and thus needs to update the cache. The function myVar.manuallyUpdated() can be called to notify the persistent value that it needs to update the cache. The paradigm for using a persistent value with ImGui then looks like if ( ImGui :: SliderFloat ( \"some text\" , & myVar . get ())) { myVar . manuallyChanged (); } Scaled values Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. The ScaledValue type tracks such represents such values, if we set ScaledValue s = 7. , then s.asAbsolute() will return 7. * state::lengthScale when used. Most length-valued parameters in Polyscope use this mechanism, and thus are relative by default. using namespace polyscope ; PointCloud * psCloud = polyscope :: getPointCloud ( \"my cloud\" ); // radius will be 0.05 * lengthScale when used psCloud -> pointRadius = ScaledValue < double >:: relative ( 0.05 ); psCloud -> pointRadius = relativeValue ( 0.05 ); // shorthand, same as previous psCloud -> pointRadius = 0.05 ; // shorthand, same as previous However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use. // radius will be 1.6 when used psCloud -> pointRadius = ScaledValue < double >:: absolute ( 1.6 ) psCloud -> pointRadius = absoluteValue ( 1.6 ); // shorthand, same as previous Note that scaled values can be (and often are) used as persistent values , as described above; the two concepts are complementary. for implementors If writing custom Polyscope library code (e.g. your own custom structures and quantities), here\u2019s what you need to know to use scaled values. The class ScaledValue<T> is templated on the scalar type, which basically just needs to support scalar multiplicaiton. The examples above show how to construct scaled values as relative or absolute. If you want to get the value represented by the ScaledValue as an absolute quantity, use ScaledValue<T>::asAbsolute() , which scales by state::lengthScale if the value is relative. Use ScaledValue<T>::getValuePtr to get a pointer to the underlying T , for instance if using ImGui. A basic ImGui pattern to manipulate the variable looks like: ImGui :: SliderFloat ( \"value \" , value . getValuePtr ()); If the value is a persistent scaled value, like PersistentValue<ScaledValue<float>> , it can be used like: // example persistent scaled value PersistentValue < ScaledValue < float >>> myVal ( \"unique name\" , relativeValue ( 0.03 )); // access float myValInWorldCoords = myVal . get (). asAbsolute (); // use with ImGUI if ( ImGui :: SliderFloat ( \"my val\" , myVal . get (). getValuePtr ())) { myVal . manuallyChanged (); }","title":"Parameters"},{"location":"basics/parameters/#persistent-values","text":"In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values . Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match. Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. PointCloud * psCloud = polyscope :: getPointCloud ( \"my cloud\" ); psCloud -> setPointColor ( glm :: vec3 ( 0.5 , 0.5 , 0.5 )); // the persistent value is recorded in the cache // ... later ... PointCloud * newCloud = polyscope :: registerPointCloud ( \"my cloud\" , new_points ); // newCloud will automatically pick up the pointColor we set above, // since this point cloud has the same name Note that this persistence behavior applies even when variables are manually manipulated in the GUI. for implementors If writing custom Polyscope library code (e.g. your own custom structures and quantities), here\u2019s what you need to know to use persistent values. The class PersistentValue<T> is templated on the underlying scalar type, like PersistentValue<double> . Only a predefined set of types can be used as template arguments because the corresponding global cache must be allocated. See persistent_value.h for a listing, which currently includes bool , float , double , ScaledValue<float> , ScaledValue<double> , glm::vec3 , and std::string . Construct a persistent value like PersistentValue < float > myVar ( \"unique_name\" , 0.5 ) the variable will the cached value if one exists, and if not take the value 0.5 (and add it to the cache). Remember to use a globally unique name for the for the name argument; in structures you can use a concatenation of the type name, structure name, and (if applicable) quantity name. To access a persistent value, call myVar.get() , which returns a reference to the underlying value. In some occasions, in particular when using ImGui, you may need to write to a value directly via the pointer from &myVar.get() . This is problematic, because the variable does not know it has been written to and thus needs to update the cache. The function myVar.manuallyUpdated() can be called to notify the persistent value that it needs to update the cache. The paradigm for using a persistent value with ImGui then looks like if ( ImGui :: SliderFloat ( \"some text\" , & myVar . get ())) { myVar . manuallyChanged (); }","title":"Persistent values"},{"location":"basics/parameters/#scaled-values","text":"Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. The ScaledValue type tracks such represents such values, if we set ScaledValue s = 7. , then s.asAbsolute() will return 7. * state::lengthScale when used. Most length-valued parameters in Polyscope use this mechanism, and thus are relative by default. using namespace polyscope ; PointCloud * psCloud = polyscope :: getPointCloud ( \"my cloud\" ); // radius will be 0.05 * lengthScale when used psCloud -> pointRadius = ScaledValue < double >:: relative ( 0.05 ); psCloud -> pointRadius = relativeValue ( 0.05 ); // shorthand, same as previous psCloud -> pointRadius = 0.05 ; // shorthand, same as previous However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use. // radius will be 1.6 when used psCloud -> pointRadius = ScaledValue < double >:: absolute ( 1.6 ) psCloud -> pointRadius = absoluteValue ( 1.6 ); // shorthand, same as previous Note that scaled values can be (and often are) used as persistent values , as described above; the two concepts are complementary. for implementors If writing custom Polyscope library code (e.g. your own custom structures and quantities), here\u2019s what you need to know to use scaled values. The class ScaledValue<T> is templated on the scalar type, which basically just needs to support scalar multiplicaiton. The examples above show how to construct scaled values as relative or absolute. If you want to get the value represented by the ScaledValue as an absolute quantity, use ScaledValue<T>::asAbsolute() , which scales by state::lengthScale if the value is relative. Use ScaledValue<T>::getValuePtr to get a pointer to the underlying T , for instance if using ImGui. A basic ImGui pattern to manipulate the variable looks like: ImGui :: SliderFloat ( \"value \" , value . getValuePtr ()); If the value is a persistent scaled value, like PersistentValue<ScaledValue<float>> , it can be used like: // example persistent scaled value PersistentValue < ScaledValue < float >>> myVal ( \"unique name\" , relativeValue ( 0.03 )); // access float myValInWorldCoords = myVal . get (). asAbsolute (); // use with ImGUI if ( ImGui :: SliderFloat ( \"my val\" , myVal . get (). getValuePtr ())) { myVal . manuallyChanged (); }","title":"Scaled values"},{"location":"basics/program_options/","text":"These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling polyscope::init , but they may set be anywhere. #include \"polyscope/polyscope.h\" // a few options polyscope :: options :: programName = \"important app\" ; polyscope :: options :: verbosity = 0 ; polyscope :: options :: usePrefsFile = false ; // initialize polyscope :: init (); Options std :: string options :: programName program name A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: polyscope :: options :: programName = \"important app\" ; int options :: verbosity verbosity How much useful info should polyscope print to std::cout ? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: polyscope :: options :: verbosity = 1 ; std :: string options :: printPrefix print prefix A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: polyscope :: options :: printPrefix = \"[MYAPP] \" ; // prints now look like \"[MYAPP] loaded openGL\" bool options :: errorsThrowExceptions errors throw execptions If true, errors in polyscope throw execptions. If false, a polyscope::error is shown in the UI, but processing attempts to continue. Default: false . bool options :: enableRenderErrorChecks render error checks If true, the rendering subsystem will eagerly check for and report errors. This comes at some small performance cost, but can help catch problems. Default: true when compiled in Debug mode, false in Release mode. int options :: ssaaFactor SSAA anti-aliasing factor Enable super-sampling anti-aliasing for a prettier rendered scene. SSAA renders the scene at multiple samples for each pixel, then averages them to resolve final pixel values. Cost scales quadratically with the value of this parameter, so it will quickly become expensive. Reasonable values are in the range 1 to 4 . Using 2 is generally sufficient for anti-aliasing. Default: 1 (no anti-aliasing) int options :: maxFPS max fps The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . bool options :: usePrefsFile use prefs file Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If false , if will be neither written nor read. Default: true . bool options :: alwaysRedraw always redraw Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is true , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: false . bool options :: openImGuiWindowForUserCallback open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true . bool options :: invokeUserCallbackForNestedShow invoke user callback for nested show Suppose you call polyscope::show() , and within your callback, another instance of polyscope::show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your userCallback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope::show() . Default: false .","title":"Program Options"},{"location":"basics/program_options/#options","text":"std :: string options :: programName","title":"Options"},{"location":"basics/program_options/#program-name","text":"A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: polyscope :: options :: programName = \"important app\" ; int options :: verbosity","title":"program name"},{"location":"basics/program_options/#verbosity","text":"How much useful info should polyscope print to std::cout ? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: polyscope :: options :: verbosity = 1 ; std :: string options :: printPrefix","title":"verbosity"},{"location":"basics/program_options/#print-prefix","text":"A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: polyscope :: options :: printPrefix = \"[MYAPP] \" ; // prints now look like \"[MYAPP] loaded openGL\" bool options :: errorsThrowExceptions","title":"print prefix"},{"location":"basics/program_options/#errors-throw-execptions","text":"If true, errors in polyscope throw execptions. If false, a polyscope::error is shown in the UI, but processing attempts to continue. Default: false . bool options :: enableRenderErrorChecks","title":"errors throw execptions"},{"location":"basics/program_options/#render-error-checks","text":"If true, the rendering subsystem will eagerly check for and report errors. This comes at some small performance cost, but can help catch problems. Default: true when compiled in Debug mode, false in Release mode. int options :: ssaaFactor","title":"render error checks"},{"location":"basics/program_options/#ssaa-anti-aliasing-factor","text":"Enable super-sampling anti-aliasing for a prettier rendered scene. SSAA renders the scene at multiple samples for each pixel, then averages them to resolve final pixel values. Cost scales quadratically with the value of this parameter, so it will quickly become expensive. Reasonable values are in the range 1 to 4 . Using 2 is generally sufficient for anti-aliasing. Default: 1 (no anti-aliasing) int options :: maxFPS","title":"SSAA anti-aliasing factor"},{"location":"basics/program_options/#max-fps","text":"The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . bool options :: usePrefsFile","title":"max fps"},{"location":"basics/program_options/#use-prefs-file","text":"Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If false , if will be neither written nor read. Default: true . bool options :: alwaysRedraw","title":"use prefs file"},{"location":"basics/program_options/#always-redraw","text":"Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is true , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: false . bool options :: openImGuiWindowForUserCallback","title":"always redraw"},{"location":"basics/program_options/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true . bool options :: invokeUserCallbackForNestedShow","title":"open imgui window for user callback"},{"location":"basics/program_options/#invoke-user-callback-for-nested-show","text":"Suppose you call polyscope::show() , and within your callback, another instance of polyscope::show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your userCallback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope::show() . Default: false .","title":"invoke user callback for nested show"},{"location":"basics/scene_options/","text":"These are settings which affect the visual display of the scene. It is often convenient to set them just before calling polyscope::init , but they may set be anywhere. #include \"polyscope/polyscope.h\" // a few options polyscope :: options :: autocenterStructures = true ; polyscope :: options :: autoscaleStructures = true ; // initialize polyscope :: init (); bool options :: autocenterStructures autocenter structures If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: false . bool options :: autoscaleStructures autoscale structures If true, all structures will have their transform set to rescale their length to 1 immediately after being registered. This scales the content nicely in view, but obscures any important absolute world positions. Default: false .","title":"Scene Options"},{"location":"basics/scene_options/#autocenter-structures","text":"If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: false . bool options :: autoscaleStructures","title":"autocenter structures"},{"location":"basics/scene_options/#autoscale-structures","text":"If true, all structures will have their transform set to rescale their length to 1 immediately after being registered. This scales the content nicely in view, but obscures any important absolute world positions. Default: false .","title":"autoscale structures"},{"location":"building/","text":"Polyscope uses CMake to configure its build system. Unix-like environments (macOS,Linux,WSL) If you\u2019re using CMake in a Unix-like environment, integrating Polyscope in to your codebase should be as simple as running git clone --recurse-submodules https://github.com/nmwsharp/polyscope.git and adding add_subdirectory(\"path/to/polyscope\") ... target_link_libraries(YOUR_TARGET polyscope) to your CMakeLists.txt . If you place polyscope outside of your project\u2019s source tree, you may need add_subdirectory(\"path/to/polyscope\" \"polyscope\") to also set a library build directory. See these repositories for some simple examples of using Polyscope with an existing codebase or library: with geometry-central \u2013 example project with libIGL \u2013 example project Building in Windows If you are using Cygwin, WSL, or some other unix-emulation environment on Windows, just follow the Unix instructions above (though be wary that these tools often do not have good openGL and windowing support, which can be a problem at runtime for a graphical application like Polyscope). Additionally, Polyscope builds out of the box on Visual Studio 2019 (earlier versions have not been tested). Simply run CMake (either with the GUI or terminal interface) on Polyscope\u2019s CMakeLists.txt to generate Visual Studio project and solution files. To integrate Polyscope with an existing Visual Studio project: (if the project uses CMake): add Polyscope to your projects CMakeLists.txt as in the Unix instructions above (otherwise): first generate the Polyscope project with its CMakeLists.txt , then manually add the polyscope project to your existing Visual Studio solution Polyscope has been verified to compile in Visual Studio 2019 & 2017; other versions should work but have not been tested! Polyscope uses only C++11 language features, but does make advanced use of templates (for instance, SFINAE), which some older versions of MSVC do not fully support. To test Polyscope on your machine, you can compile the demo app with examples/demo-app/CMakeLists.txt . Dependencies Polyscope packages all of its source code dependencies with the repository. On Ubuntu and friends, you may want to apt-get install xorg-dev libglu1-mesa-dev freeglut3-dev mesa-common-dev to pull graphics and windowing related headers to build. Backends Internally, Polyscope has (very preliminary) support for changing the rendering backend. At compile time, CMake flags control which backends Polyscope will be built with, and at runtime one of the available backends can be selected during init() . Currently, only a single \u201creal\u201d backend is supported. However, an additional \u201cmock\u201d backend enables testing on headless machines. Backend CMake option String name Description OpenGL3 & GLFW POLYSCOPE_BACKEND_OPENGL3_GLFW openGL3_glfw The standard rendering engine for Polyscope mock POLYSCOPE_BACKEND_OPENGL_MOCK openGL_mock Fake backend which stubs out all calls to the rendering engine, but still performs many useful internal checks. By default the CMake script builds all (both) backends. But for instance, the OpenGL3 backend could be excluded from the build with cmake -DPOLYSCOPE_BACKEND_OPENGL3_GLFW = OFF .. and the mock backend could be used at runtime with polyscope :: init ( \"openGL_mock\" ) . Tests Unit test live in the /test/ directory, and cover most of the core functionality of Polyscope. Polyscope uses googletest, which will be downloaded automatically when you build the tests. To build and run the tests, use: cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j4 && ./bin/polyscope-test --gtest_catch_exceptions = 0 The backend can be set for the test script by passing an additional argument: ./bin/polyscope-test --gtest_catch_exceptions = 0 backend = openGL_mock","title":"Building"},{"location":"building/#unix-like-environments-macoslinuxwsl","text":"If you\u2019re using CMake in a Unix-like environment, integrating Polyscope in to your codebase should be as simple as running git clone --recurse-submodules https://github.com/nmwsharp/polyscope.git and adding add_subdirectory(\"path/to/polyscope\") ... target_link_libraries(YOUR_TARGET polyscope) to your CMakeLists.txt . If you place polyscope outside of your project\u2019s source tree, you may need add_subdirectory(\"path/to/polyscope\" \"polyscope\") to also set a library build directory. See these repositories for some simple examples of using Polyscope with an existing codebase or library: with geometry-central \u2013 example project with libIGL \u2013 example project","title":"Unix-like environments (macOS,Linux,WSL)"},{"location":"building/#building-in-windows","text":"If you are using Cygwin, WSL, or some other unix-emulation environment on Windows, just follow the Unix instructions above (though be wary that these tools often do not have good openGL and windowing support, which can be a problem at runtime for a graphical application like Polyscope). Additionally, Polyscope builds out of the box on Visual Studio 2019 (earlier versions have not been tested). Simply run CMake (either with the GUI or terminal interface) on Polyscope\u2019s CMakeLists.txt to generate Visual Studio project and solution files. To integrate Polyscope with an existing Visual Studio project: (if the project uses CMake): add Polyscope to your projects CMakeLists.txt as in the Unix instructions above (otherwise): first generate the Polyscope project with its CMakeLists.txt , then manually add the polyscope project to your existing Visual Studio solution Polyscope has been verified to compile in Visual Studio 2019 & 2017; other versions should work but have not been tested! Polyscope uses only C++11 language features, but does make advanced use of templates (for instance, SFINAE), which some older versions of MSVC do not fully support. To test Polyscope on your machine, you can compile the demo app with examples/demo-app/CMakeLists.txt .","title":"Building in Windows"},{"location":"building/#dependencies","text":"Polyscope packages all of its source code dependencies with the repository. On Ubuntu and friends, you may want to apt-get install xorg-dev libglu1-mesa-dev freeglut3-dev mesa-common-dev to pull graphics and windowing related headers to build.","title":"Dependencies"},{"location":"building/#backends","text":"Internally, Polyscope has (very preliminary) support for changing the rendering backend. At compile time, CMake flags control which backends Polyscope will be built with, and at runtime one of the available backends can be selected during init() . Currently, only a single \u201creal\u201d backend is supported. However, an additional \u201cmock\u201d backend enables testing on headless machines. Backend CMake option String name Description OpenGL3 & GLFW POLYSCOPE_BACKEND_OPENGL3_GLFW openGL3_glfw The standard rendering engine for Polyscope mock POLYSCOPE_BACKEND_OPENGL_MOCK openGL_mock Fake backend which stubs out all calls to the rendering engine, but still performs many useful internal checks. By default the CMake script builds all (both) backends. But for instance, the OpenGL3 backend could be excluded from the build with cmake -DPOLYSCOPE_BACKEND_OPENGL3_GLFW = OFF .. and the mock backend could be used at runtime with polyscope :: init ( \"openGL_mock\" ) .","title":"Backends"},{"location":"building/#tests","text":"Unit test live in the /test/ directory, and cover most of the core functionality of Polyscope. Polyscope uses googletest, which will be downloaded automatically when you build the tests. To build and run the tests, use: cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j4 && ./bin/polyscope-test --gtest_catch_exceptions = 0 The backend can be set for the test script by passing an additional argument: ./bin/polyscope-test --gtest_catch_exceptions = 0 backend = openGL_mock","title":"Tests"},{"location":"features/2D_data/","text":"Polyscope is primarily focused on 3D data, but can also be used for 2D visualization. This section descibes a few helpers which make it easier to do so. Example: register a 2D point cloud and add some vectors to it #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" polyscope :: init (); // Set the camera to 2D mode (see below) polyscope :: view :: style = polyscope :: view :: NavigateStyle :: Planar ; // Build a random point cloud size_t N = 3000 ; std :: vector < glm :: vec2 > points ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { points . push_back ( glm :: vec2 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }); } // Register it. Note the \"2D\" in the function call. polyscope :: registerPointCloud2D ( \"flat points\" , points ); // Build a random vector std :: vector < glm :: vec2 > randVec ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { randVec [ i ] = glm :: vec2 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }; } // Add it to the point cloud. Note the \"2D\" in the function call polyscope :: getPointCloud ( \"flat points\" ) -> addVectorQuantity2D ( \"random vector\" , randVec ); polyscope :: show (); Adding 2D data Functions which accept 3D positions (or vectors) as input have a variant which takes 2D positions, and appends a 0 z-coordinate. For instance, registerPointCloud() has a matching registerPointCloud2D() , there\u2019s registerSurfaceMesh2D , etc. Any other functions which don\u2019t take 3D positions can be used as normal, like addScalarQuantity() . Note that you definitely should not just call the normal 3D versions with 2D data. If you\u2019re lucky, it will fail to compile; if you\u2019re unlucky your code may segfault! Planar camera mode The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: polyscope::view::style = polyscope::view::NavigateStyle::Planar;","title":"2D Data"},{"location":"features/2D_data/#adding-2d-data","text":"Functions which accept 3D positions (or vectors) as input have a variant which takes 2D positions, and appends a 0 z-coordinate. For instance, registerPointCloud() has a matching registerPointCloud2D() , there\u2019s registerSurfaceMesh2D , etc. Any other functions which don\u2019t take 3D positions can be used as normal, like addScalarQuantity() . Note that you definitely should not just call the normal 3D versions with 2D data. If you\u2019re lucky, it will fail to compile; if you\u2019re unlucky your code may segfault!","title":"Adding 2D data"},{"location":"features/2D_data/#planar-camera-mode","text":"The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: polyscope::view::style = polyscope::view::NavigateStyle::Planar;","title":"Planar camera mode"},{"location":"features/color_maps/","text":"Built-in color maps Different color maps are appropriate for different situations: sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below). diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases 0 semantially means \u201cnothing\u201d, and the endpoints have opposite meaning. cyclic maps data defined on the circle, like an angle decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes Polyscope supports the following built-in color maps: Name Type String Key viridis sequential viridis blues sequential blues reds sequential reds coolwarm diverging coolwarm pink-green diverging pink-green phase cyclic phase spectral decorative spectral rainbow decorative rainbow jet decorative jet Loading custom color maps Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from [Appearance] --> [Color maps] --> [Load color map] , or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting stb_image can read). void polyscope :: loadColorMap ( std :: string cmapName , std :: string filename ) loadColorMap Load a new colormap from the image file filename , which will be assigned the name cmapName . Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9 Phase is from the cmocean package. link \u21a9 The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib . \u21a9","title":"Color Maps"},{"location":"features/color_maps/#built-in-color-maps","text":"Different color maps are appropriate for different situations: sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below). diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases 0 semantially means \u201cnothing\u201d, and the endpoints have opposite meaning. cyclic maps data defined on the circle, like an angle decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes Polyscope supports the following built-in color maps: Name Type String Key viridis sequential viridis blues sequential blues reds sequential reds coolwarm diverging coolwarm pink-green diverging pink-green phase cyclic phase spectral decorative spectral rainbow decorative rainbow jet decorative jet","title":"Built-in color maps"},{"location":"features/color_maps/#loading-custom-color-maps","text":"Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from [Appearance] --> [Color maps] --> [Load color map] , or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting stb_image can read). void polyscope :: loadColorMap ( std :: string cmapName , std :: string filename )","title":"Loading custom color maps"},{"location":"features/color_maps/#loadcolormap","text":"Load a new colormap from the image file filename , which will be assigned the name cmapName . Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9 Phase is from the cmocean package. link \u21a9 The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib . \u21a9","title":"loadColorMap"},{"location":"features/ground_and_shadows/","text":"The Polyscope scene view includes a ground plane which optionally supports reflection and soft-shadow effects. This section outlines the various modes and options available for the ground plane. Ground plane and shadow modes GroundPlaneMode::None no ground plane, nor reflection/shadows are shown GroundPlaneMode::Tile a tiled ground plane GroundPlaneMode::TileReflection a tiled ground plane with a reflection of the scene (default) GroundPlaneMode::ShadowOnly a transparent ground plane with a soft vertical shadow of the scene The ground plane and shadow settings can also be manually adjusted in the GUI under the [Appearance] --> [Ground Plane] menu. Example: adjust the ground plane & shadow appearance #include \"polyscope/polyscope.h\" polyscope :: init (); // set soft shadows on the ground polyscope :: options :: groundPlaneMode = polyscope :: GroundPlaneMode :: ShadowOnly ; polyscope :: view :: upDir = UpDir :: ZUp ; // set +Z as up direction polyscope :: options :: groundPlaneHeightFactor = -0.25 ; // adjust the plane height polyscope :: options :: shadowDarkness = 0.1 ; // lighter shadows /* load your mesh, point cloud, etc */ // take screenshot from the current camera view, which will have transparent shadows polyscope :: screenshot ( \"test_image.png\" , true ); // open the GUI polyscope :: show (); GroundPlaneMode options :: groundPlaneMode Set the mode used for the ground plane, as described above. Should be one of GroundPlaneMode::None , GroundPlaneMode::Tile , GroundPlaneMode::TileReflection , or GroundPlaneMode::ShadowOnly . Default: GroundPlaneMode::TileReflection . Some more details: the ground plane is automatically faded away whenever the scene is viewed from underneath the ground, and also faded away in the distance far from the scene, as determined by the scene bounding box. Shadows are properly transparent, exporting a screenshot with transparency will set alpha = options::shadowDarkness values for shadowed areas, and set alpha=0 for unshadowed parts of the ground plane. The options::shadowBlurIters and options::shadowDarkness parameters below adjust the visual appearance of soft shadows for GroundPlaneMode::ShadowOnly . int options :: shadowBlurIters The number of blur iterations used to blur soft shadows. Increase to make the shadows more fuzzy. Default: 2 . float options :: shadowDarkness How dark the shadows are. 0 is totally transparent (white), and 1 is fully black. When taking screenshots with transparency, these will become alpha transparency values for the shadowed regions. Default: .25 . Ground plane positioning The orientation of the ground plane is determined by the up direction for the scene , which can be set along any of the coordinate directions such as +X , -Z , etc. The height of the ground plane is set by default from the bounding box of the scene. The options::groundPlaneHeightFactor can be set to adjust the relative offset of the ground plane from the bounding box. ScaledValue < float > options :: groundPlaneHeightFactor The offset of the ground plane from the bottom of the bounding box for the scene. Use postive/negative values to shift the ground plane up/down. This parameter is a scaled value . You can assign to it like a normal float, options::groundPlaneHeightFactor = 0.5 , and the resulting value will be relative to the scene length scale. Alternately, absolute values can also be used, as described on the linked page. Default: 0 .","title":"Ground and Shadows"},{"location":"features/ground_and_shadows/#ground-plane-and-shadow-modes","text":"GroundPlaneMode::None no ground plane, nor reflection/shadows are shown GroundPlaneMode::Tile a tiled ground plane GroundPlaneMode::TileReflection a tiled ground plane with a reflection of the scene (default) GroundPlaneMode::ShadowOnly a transparent ground plane with a soft vertical shadow of the scene The ground plane and shadow settings can also be manually adjusted in the GUI under the [Appearance] --> [Ground Plane] menu. Example: adjust the ground plane & shadow appearance #include \"polyscope/polyscope.h\" polyscope :: init (); // set soft shadows on the ground polyscope :: options :: groundPlaneMode = polyscope :: GroundPlaneMode :: ShadowOnly ; polyscope :: view :: upDir = UpDir :: ZUp ; // set +Z as up direction polyscope :: options :: groundPlaneHeightFactor = -0.25 ; // adjust the plane height polyscope :: options :: shadowDarkness = 0.1 ; // lighter shadows /* load your mesh, point cloud, etc */ // take screenshot from the current camera view, which will have transparent shadows polyscope :: screenshot ( \"test_image.png\" , true ); // open the GUI polyscope :: show (); GroundPlaneMode options :: groundPlaneMode Set the mode used for the ground plane, as described above. Should be one of GroundPlaneMode::None , GroundPlaneMode::Tile , GroundPlaneMode::TileReflection , or GroundPlaneMode::ShadowOnly . Default: GroundPlaneMode::TileReflection . Some more details: the ground plane is automatically faded away whenever the scene is viewed from underneath the ground, and also faded away in the distance far from the scene, as determined by the scene bounding box. Shadows are properly transparent, exporting a screenshot with transparency will set alpha = options::shadowDarkness values for shadowed areas, and set alpha=0 for unshadowed parts of the ground plane. The options::shadowBlurIters and options::shadowDarkness parameters below adjust the visual appearance of soft shadows for GroundPlaneMode::ShadowOnly . int options :: shadowBlurIters The number of blur iterations used to blur soft shadows. Increase to make the shadows more fuzzy. Default: 2 . float options :: shadowDarkness How dark the shadows are. 0 is totally transparent (white), and 1 is fully black. When taking screenshots with transparency, these will become alpha transparency values for the shadowed regions. Default: .25 .","title":"Ground plane and shadow modes"},{"location":"features/ground_and_shadows/#ground-plane-positioning","text":"The orientation of the ground plane is determined by the up direction for the scene , which can be set along any of the coordinate directions such as +X , -Z , etc. The height of the ground plane is set by default from the bounding box of the scene. The options::groundPlaneHeightFactor can be set to adjust the relative offset of the ground plane from the bounding box. ScaledValue < float > options :: groundPlaneHeightFactor The offset of the ground plane from the bottom of the bounding box for the scene. Use postive/negative values to shift the ground plane up/down. This parameter is a scaled value . You can assign to it like a normal float, options::groundPlaneHeightFactor = 0.5 , and the resulting value will be relative to the scene length scale. Alternately, absolute values can also be used, as described on the linked page. Default: 0 .","title":"Ground plane positioning"},{"location":"features/materials/","text":"Polyscope uses matcaps to render the appearance of objects in the scene, as opposed to more traditional configurations of lights and shading models, etc. A matcap is a small image of a material, which is sampled by the renderer to query the materials\u2019 appearance from a some angle. Scene information like lighting is implicitly baked in to the matcap image. Most objects in Polyscope (surface meshes, point clouds, vectors, etc) expose a setMaterial ( std :: string ) option to choose a material for the object\u2019s appearance. Additionally, materials can generally be set in the UI from [Options] --> [Material] . Blended materials In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities). Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps. How it works Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components. At runtime, to generate a color from a triple of rgb values each in the range [0,1] , we sample the images like: outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color. Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space. Materials which which support this blending are denoted by (rgb) in the options menu. Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options. Built-in materials Polyscope supports the following built-in materials: Name String Key Blendable Image clay clay yes wax wax yes candy candy yes flat flat yes mud 1 mud no ceramic 1 ceramic no jade 1 jade no normal 1 normal no Loading custom materials Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from [Appearance] --> [Materials] --> [Load material] , or programatically using the function below. For blendable matcaps, if the single filename mat.hdr is given, Polyscope will try to load mat_r.hdr , mat_g.hdr , etc. Ideally, matcap images should be linear .hdr images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with intensity=1 and gamma=2.2 before use. Most common image formats are accepted (anything stb_image can read). void polyscope :: loadStaticMaterial ( std :: string matName , std :: string filename ) loadStaticMaterial Load a new static (non-blendable) material from a single image file filename . The new material will be called matName . void polyscope :: loadBlendableMaterial ( std :: string matName , std :: array < std :: string , 4 > filenames ) loadBlendableMaterial Load a new blendable material from image files filenames , corresponding to red, green, blue, and black basis materials. The new material will be called matName . void polyscope :: loadBlendableMaterial ( std :: string matName , std :: string filenameBase , std :: string filenameExt ) loadBlendableMaterial Same as above, but the four filenames will be generated as filenameBase + \"_r\" + filenameExt , etc. The matcaps are from the Blender matcap repository, available under a CC0/public domain license . Thanks to the Blender community for contributing them! \u21a9 \u21a9 \u21a9 \u21a9","title":"Materials"},{"location":"features/materials/#blended-materials","text":"In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities). Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps. How it works Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components. At runtime, to generate a color from a triple of rgb values each in the range [0,1] , we sample the images like: outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color. Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space. Materials which which support this blending are denoted by (rgb) in the options menu. Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options.","title":"Blended materials"},{"location":"features/materials/#built-in-materials","text":"Polyscope supports the following built-in materials: Name String Key Blendable Image clay clay yes wax wax yes candy candy yes flat flat yes mud 1 mud no ceramic 1 ceramic no jade 1 jade no normal 1 normal no","title":"Built-in materials"},{"location":"features/materials/#loading-custom-materials","text":"Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from [Appearance] --> [Materials] --> [Load material] , or programatically using the function below. For blendable matcaps, if the single filename mat.hdr is given, Polyscope will try to load mat_r.hdr , mat_g.hdr , etc. Ideally, matcap images should be linear .hdr images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with intensity=1 and gamma=2.2 before use. Most common image formats are accepted (anything stb_image can read). void polyscope :: loadStaticMaterial ( std :: string matName , std :: string filename )","title":"Loading custom materials"},{"location":"features/materials/#loadstaticmaterial","text":"Load a new static (non-blendable) material from a single image file filename . The new material will be called matName . void polyscope :: loadBlendableMaterial ( std :: string matName , std :: array < std :: string , 4 > filenames )","title":"loadStaticMaterial"},{"location":"features/materials/#loadblendablematerial","text":"Load a new blendable material from image files filenames , corresponding to red, green, blue, and black basis materials. The new material will be called matName . void polyscope :: loadBlendableMaterial ( std :: string matName , std :: string filenameBase , std :: string filenameExt )","title":"loadBlendableMaterial"},{"location":"features/materials/#loadblendablematerial_1","text":"Same as above, but the four filenames will be generated as filenameBase + \"_r\" + filenameExt , etc. The matcaps are from the Blender matcap repository, available under a CC0/public domain license . Thanks to the Blender community for contributing them! \u21a9 \u21a9 \u21a9 \u21a9","title":"loadBlendableMaterial"},{"location":"features/messages/","text":"Using messages We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. terminating error Like error , but terminates the program after being dismissed. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); // Generating an error. // The UI will block and show this error immediately. After // the error is dismissed, the call will return. polyscope :: error ( \"Resistance is futile.\" ); // Generate a fatal error. // After the error is dismissed, the program will terminate. polyscope :: terminatingError ( \"Resistance is futile.\" ); Messages void polyscope :: info ( std :: string message ) info Simply logs a message to stdout . void polyscope :: warning ( std :: string baseMessage , std :: string detailMessage = \"\" ) warning Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detailMessage field need not be used. However, if issuing warnings in a loop, warnings with the same baseMessage are batched together, so the UI doesn\u2019t get completely overwhelmed. Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); void polyscope :: error ( std :: string message ) error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns. void polyscope :: terminatingError ( std :: string message ) terminating error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, the program terminates.","title":"Messages"},{"location":"features/messages/#using-messages","text":"We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. terminating error Like error , but terminates the program after being dismissed. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); // Generating an error. // The UI will block and show this error immediately. After // the error is dismissed, the call will return. polyscope :: error ( \"Resistance is futile.\" ); // Generate a fatal error. // After the error is dismissed, the program will terminate. polyscope :: terminatingError ( \"Resistance is futile.\" );","title":"Using messages"},{"location":"features/messages/#messages","text":"void polyscope :: info ( std :: string message )","title":"Messages"},{"location":"features/messages/#info","text":"Simply logs a message to stdout . void polyscope :: warning ( std :: string baseMessage , std :: string detailMessage = \"\" )","title":"info"},{"location":"features/messages/#warning","text":"Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detailMessage field need not be used. However, if issuing warnings in a loop, warnings with the same baseMessage are batched together, so the UI doesn\u2019t get completely overwhelmed. Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); void polyscope :: error ( std :: string message )","title":"warning"},{"location":"features/messages/#error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns. void polyscope :: terminatingError ( std :: string message )","title":"error"},{"location":"features/messages/#terminating-error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, the program terminates.","title":"terminating error"},{"location":"features/screenshots/","text":"Polyscope includes simple functionality for saving screenshots from the current camera view to disk. The ImGUI interface windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [screenshot] button in the options GUI window, or programmatically using the functions below. Clicking the GUI button generates a numbered screenshot file in the current directory; the arrow to the side of the button can be used to adjust file format and transparency settings for these screenshots. It is not necessary to call polyscope::show() before taking screenshots. You can set up you scene and programmatically configure the camera view , then call polyscope::screenshot() to save a rendered image to disk, all without any user interaction. Example: Register a mesh, position the camera, and take a screenshot #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" // Initialize Polyscope polyscope :: init (); // Register your mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , /* your verts */ , /* your faces */ ); // Position the camera polyscope :: view :: lookAt ( glm :: vec3 { 10. , 10. , 0. }, glm :: vec3 { 0. , 2. , 0. }); // Adjust some screenshot default settings if you'd like polyscope :: screenshotExtension = \".jpg\" ; // Take a screenshot // It will be written to your current directory as screenshot_000000.jpg, etc polyscope :: screenshot (); void screenshot ( bool transparentBG = true ) numbered screenshot Saves a screenshot to the current directory, with file named like screenshot_000000.png , numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent, and set as transparency alpha in the saved image if the file format supports it. std :: string options :: screenshotExtension screenshot extension Set the extension used when taking automatically-numbered screenshots, either with screenshot() or by clicking the GUI button. The extension should be .png , or .jpg . void screenshot ( std :: string filename , bool transparentBG = true ) named screenshot Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be .png , or .jpg . If transparentBG is true , the background will be rendered as transparent.","title":"Screenshots"},{"location":"features/screenshots/#numbered-screenshot","text":"Saves a screenshot to the current directory, with file named like screenshot_000000.png , numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent, and set as transparency alpha in the saved image if the file format supports it. std :: string options :: screenshotExtension","title":"numbered screenshot"},{"location":"features/screenshots/#screenshot-extension","text":"Set the extension used when taking automatically-numbered screenshots, either with screenshot() or by clicking the GUI button. The extension should be .png , or .jpg . void screenshot ( std :: string filename , bool transparentBG = true )","title":"screenshot extension"},{"location":"features/screenshots/#named-screenshot","text":"Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be .png , or .jpg . If transparentBG is true , the background will be rendered as transparent.","title":"named screenshot"},{"location":"features/slice_planes/","text":"Geometric data often has complex internal structures. Slice planes can be added to the scene to cull away parts of an object and inspect its interior. These planes can be manipulated either programmatically or manually in the GUI. Your browser does not support the video tag. Example : sweep a slice plane through the scene to produce the animation above #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include <igl/readOBJ.h> // Initialize Polyscope polyscope :: init (); // Read & register the mesh Eigen :: MatrixXd meshV ; Eigen :: MatrixXi meshF ; igl :: readOBJ ( filename , meshV , meshF ); polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Add a slice plane polyscope :: SlicePlane * psPlane = polyscope :: addSceneSlicePlane (); psPlane -> setDrawPlane ( true ); // render the semi-transparent gridded plane psPlane -> setDrawWidget ( true ); // Animate the plane sliding along the scene for ( float t = 0. ; t < 2. * M_PI ; t += 2. * M_PI / 120 ) { float pos = std :: cos ( t ) * .8 + .2 ; psPlane -> setPose ( glm :: vec3 { 0. , 0. , pos }, glm :: vec3 { 0. , 0. , -1. }); // Take a screenshot at each frame polyscope :: screenshot ( false ); } Slice planes can also be manipulated in the GUI under [View] --> [Slice Planes] , where you can add and remove slice planes and control whether they are active and widgets are visible. When a plane is active in the scene, you can drag the 3D widget to adjust its pose. Additionally, for each structure, [Options] --> [Slice Planes] allows you to toggle whether the slice plane effects that structure. Creating and modifying slice planes SlicePlane * addSceneSlicePlane ( bool initiallyVisible = false ) add slice plane Add a new slice plane to the scene. An arbitrary number of slices planes may be added. If initiallyVisible = false , then the widget and plane grid will be disabled by default, which is usually what one wants when creating a slice plane programatically. void removeLastSceneSlicePlane () remove slice plane Remove the most recently created slice plane. const std :: string SlicePlane :: name name The unique name of the slice plane, which can be accessed like myPlane->name . void SlicePlane :: setPose ( glm :: vec3 planePosition , glm :: vec3 planeNormal ) set pose Set the position and orientation of the slice plane. planePosition is any 3D position which the plane touches (the center of the plane) planeNormal is a vector giving the normal direction of the plane, objects in this negative side of the plane will be culled void SlicePlane :: setActive ( bool newVal ) active Set the slice plane to be active or not. If inactive, the slice plane will not have any effect on any structures in the scene, nor will it be shown in the GUI view. bool SlicePlane :: getActive () Test whether the slice plane is active. void SlicePlane :: setDrawPlane ( bool newVal ) draw plane Set the slice plane to draw its plane (as a colored, semi-transparent grid). If false the slice plane will still slice objects, but the plane itself will not be rendered. bool SlicePlane :: getDrawPlane () Test whether the slice plane is drawing its plane. void SlicePlane :: setDrawWidget ( bool newVal ) draw widget Set the slice plane to draw its control widget (a grey and colored cube with handles for translations and rotations). If false the slice plane will still slice objects, but the widget will not be rendered. Note that regardless of this setting, the widget will not be visible in any screenshots by default, because it is treated as part of the GUI interface, like the ImGUI widow panes. bool SlicePlane :: getDrawWidget () Test whether the slice plane is drawing its widget. Per-structure ignore slice planes By default, every slice plane affects all content in the scene. However, we can also make a particular structure ignore a given slice plane, so that it only slices through some of the objects in the scene. This can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); polyscope :: SlicePlane * psPlane = polyscope :: addSceneSlicePlane (); psMesh -> setIgnoreSlicePlane ( psPlane -> name , true ); Structure * Structure :: setIgnoreSlicePlane ( std :: string name , bool newValue ) ignore plane Set a slice plane to be ignored by the structure. If newValue is true the slice plane will be ignored, and if false it will be respected. bool Structure :: getIgnoreSlicePlane ( std :: string name ) Test if a slice plane is currently being ignored by the structure. Cull whole elements For some structures, slice planes can be set to discretely cull away whole elements, rather than slicing directly through the middle of an element. This option can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); polyscope :: SlicePlane * psPlane = polyscope :: addSceneSlicePlane (); psMesh -> setCullWholeElements ( false ); Structure * Structure :: setCullWholeElements ( bool newVal ) set cull whole elements If true , slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Note that not all structures may support culling whole elements. If not supported, this setting will do nothing. bool Structure :: getCullWholeElements () Test whether the cull whole elements setting is applied.","title":"Slice Planes"},{"location":"features/slice_planes/#creating-and-modifying-slice-planes","text":"SlicePlane * addSceneSlicePlane ( bool initiallyVisible = false )","title":"Creating and modifying slice planes"},{"location":"features/slice_planes/#add-slice-plane","text":"Add a new slice plane to the scene. An arbitrary number of slices planes may be added. If initiallyVisible = false , then the widget and plane grid will be disabled by default, which is usually what one wants when creating a slice plane programatically. void removeLastSceneSlicePlane ()","title":"add slice plane"},{"location":"features/slice_planes/#remove-slice-plane","text":"Remove the most recently created slice plane. const std :: string SlicePlane :: name","title":"remove slice plane"},{"location":"features/slice_planes/#name","text":"The unique name of the slice plane, which can be accessed like myPlane->name . void SlicePlane :: setPose ( glm :: vec3 planePosition , glm :: vec3 planeNormal )","title":"name"},{"location":"features/slice_planes/#set-pose","text":"Set the position and orientation of the slice plane. planePosition is any 3D position which the plane touches (the center of the plane) planeNormal is a vector giving the normal direction of the plane, objects in this negative side of the plane will be culled void SlicePlane :: setActive ( bool newVal )","title":"set pose"},{"location":"features/slice_planes/#active","text":"Set the slice plane to be active or not. If inactive, the slice plane will not have any effect on any structures in the scene, nor will it be shown in the GUI view. bool SlicePlane :: getActive () Test whether the slice plane is active. void SlicePlane :: setDrawPlane ( bool newVal )","title":"active"},{"location":"features/slice_planes/#draw-plane","text":"Set the slice plane to draw its plane (as a colored, semi-transparent grid). If false the slice plane will still slice objects, but the plane itself will not be rendered. bool SlicePlane :: getDrawPlane () Test whether the slice plane is drawing its plane. void SlicePlane :: setDrawWidget ( bool newVal )","title":"draw plane"},{"location":"features/slice_planes/#draw-widget","text":"Set the slice plane to draw its control widget (a grey and colored cube with handles for translations and rotations). If false the slice plane will still slice objects, but the widget will not be rendered. Note that regardless of this setting, the widget will not be visible in any screenshots by default, because it is treated as part of the GUI interface, like the ImGUI widow panes. bool SlicePlane :: getDrawWidget () Test whether the slice plane is drawing its widget.","title":"draw widget"},{"location":"features/slice_planes/#per-structure-ignore-slice-planes","text":"By default, every slice plane affects all content in the scene. However, we can also make a particular structure ignore a given slice plane, so that it only slices through some of the objects in the scene. This can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); polyscope :: SlicePlane * psPlane = polyscope :: addSceneSlicePlane (); psMesh -> setIgnoreSlicePlane ( psPlane -> name , true ); Structure * Structure :: setIgnoreSlicePlane ( std :: string name , bool newValue )","title":"Per-structure ignore slice planes"},{"location":"features/slice_planes/#ignore-plane","text":"Set a slice plane to be ignored by the structure. If newValue is true the slice plane will be ignored, and if false it will be respected. bool Structure :: getIgnoreSlicePlane ( std :: string name ) Test if a slice plane is currently being ignored by the structure.","title":"ignore plane"},{"location":"features/slice_planes/#cull-whole-elements","text":"For some structures, slice planes can be set to discretely cull away whole elements, rather than slicing directly through the middle of an element. This option can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); polyscope :: SlicePlane * psPlane = polyscope :: addSceneSlicePlane (); psMesh -> setCullWholeElements ( false ); Structure * Structure :: setCullWholeElements ( bool newVal )","title":"Cull whole elements"},{"location":"features/slice_planes/#set-cull-whole-elements","text":"If true , slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Note that not all structures may support culling whole elements. If not supported, this setting will do nothing. bool Structure :: getCullWholeElements () Test whether the cull whole elements setting is applied.","title":"set cull whole elements"},{"location":"features/transparency/","text":"The Polyscope rendering framework supports transparency to visualize complicated data with nested internal structures. Example: register a surface mesh and render it with transparency #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" polyscope :: init (); /* load a mesh */ // Register the mesh with Polyscope auto * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , /* vertices */ , /* faces */ ); // Set transparency psMesh -> setTransparency ( 0.5 ); // Optional: change transparency rendering settings // polyscope::options::transparencyMode = polyscope::TransparencyMode::Simple; // polyscope::options::transparencyRenderPasses = 16; polyscope :: show (); Transparency modes In computer graphics, rendering scenes with transparent content is surprisingly difficult and often computationally expensive. Polyscope supports three different modes for transparent rendering: TransparencyMode::None is the default, which does not use any transparency and ignores any related settings. TransparencyMode::Simple uses an approximation which takes a weighted average of objects in view. The benefit is that this method is efficient, only slightly more expensive than normal rendering. However, it ignores the relative depth of different objects, and thus can yield noticeable and confusing artifacts on complex scenes. Generally, this method should only be used when rendering performance is a concern (i.e., if the view is otherwise too laggy to use). TransparencyMode::Pretty implements expensive-but-accurate \u201ctrue\u201d transparency, which properly accounts for objects at different depths. This mode is implemented using depth peeling , which internally renders the scene many times to generate each frame. Because many internal render passes are needed, this mode may be dramatically more expensive than normal rendering, leading to a laggy interface. The parameter polyscope::options::transparencyRenderPasses controls the number passes performed (default: 8 ); smaller values will reduce the performance hit, whereas larger values may be necessary to resolve complex scenes. The modes are set in options::transparencyMode . Initially, the transparency mode is set to TransparencyMode::None . However, if the transparency of any object is modified while the mode is None , the mode will be automatically updated to Pretty so that the effect is visible. Any ground plane reflections are disabled when using transparency. The transparency mode can also be changed in the GUI in the [Appearance] --> [Transparency] menu. TransparencyMode options :: transparencyMode Set the mode used for transparent rendering. One of TransparencyMode::None , TransparencyMode::Simple , or TransparencyMode::Pretty (see above for explanation). Default: None . Automatically updated when a transparency value is set for some structure. int options :: transparencyRenderPasses The number of passes used for Transparency::Pretty . Lower values will reduce the performance impact, but larger values may be necessary to resolve transparency in complex scenes. Default: 8 . Setting structure transparency Transparency is controlled via a real-valued parameter from 0 to 1 , commonly called \u201calpha\u201d. Setting transparency to 1 means completely opaque (the default), whereas 0 means completely transparent. This parameter is specified on a per-structure basis via Structure::setTransparency(float) . Transparency for each structure can also be modified in the GUI by selecting [Options] --> [Transparency] for the structure. Structure :: setTransparency ( float ) Set the transparency for a structure, 1 means completely opaque (the default), whereas 0 means completely transparent. Example: polyscope :: SurfaceMesh * psMesh = registerSurfaceMesh ( \"mesh\" , verts , faces ); psMesh -> setTransparency ( 0.5 );","title":"Transparency"},{"location":"features/transparency/#transparency-modes","text":"In computer graphics, rendering scenes with transparent content is surprisingly difficult and often computationally expensive. Polyscope supports three different modes for transparent rendering: TransparencyMode::None is the default, which does not use any transparency and ignores any related settings. TransparencyMode::Simple uses an approximation which takes a weighted average of objects in view. The benefit is that this method is efficient, only slightly more expensive than normal rendering. However, it ignores the relative depth of different objects, and thus can yield noticeable and confusing artifacts on complex scenes. Generally, this method should only be used when rendering performance is a concern (i.e., if the view is otherwise too laggy to use). TransparencyMode::Pretty implements expensive-but-accurate \u201ctrue\u201d transparency, which properly accounts for objects at different depths. This mode is implemented using depth peeling , which internally renders the scene many times to generate each frame. Because many internal render passes are needed, this mode may be dramatically more expensive than normal rendering, leading to a laggy interface. The parameter polyscope::options::transparencyRenderPasses controls the number passes performed (default: 8 ); smaller values will reduce the performance hit, whereas larger values may be necessary to resolve complex scenes. The modes are set in options::transparencyMode . Initially, the transparency mode is set to TransparencyMode::None . However, if the transparency of any object is modified while the mode is None , the mode will be automatically updated to Pretty so that the effect is visible. Any ground plane reflections are disabled when using transparency. The transparency mode can also be changed in the GUI in the [Appearance] --> [Transparency] menu. TransparencyMode options :: transparencyMode Set the mode used for transparent rendering. One of TransparencyMode::None , TransparencyMode::Simple , or TransparencyMode::Pretty (see above for explanation). Default: None . Automatically updated when a transparency value is set for some structure. int options :: transparencyRenderPasses The number of passes used for Transparency::Pretty . Lower values will reduce the performance impact, but larger values may be necessary to resolve transparency in complex scenes. Default: 8 .","title":"Transparency modes"},{"location":"features/transparency/#setting-structure-transparency","text":"Transparency is controlled via a real-valued parameter from 0 to 1 , commonly called \u201calpha\u201d. Setting transparency to 1 means completely opaque (the default), whereas 0 means completely transparent. This parameter is specified on a per-structure basis via Structure::setTransparency(float) . Transparency for each structure can also be modified in the GUI by selecting [Options] --> [Transparency] for the structure. Structure :: setTransparency ( float ) Set the transparency for a structure, 1 means completely opaque (the default), whereas 0 means completely transparent. Example: polyscope :: SurfaceMesh * psMesh = registerSurfaceMesh ( \"mesh\" , verts , faces ); psMesh -> setTransparency ( 0.5 );","title":"Setting structure transparency"},{"location":"features/user_callback/","text":"Intro When polyscope::show() has been called, Polyscope will optionally invoke user-supplied callback function on every loop iteration. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc. See ImGui for documentation of UI commands. std :: function < void () > polyscope :: state :: userCallback user callback A function which will be invoked on every main loop iteration by Polyscope, once show() has been called. If null, nothing will be invoked. Example The code below creates the following UI using a callback. #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" // Parameters which we will set in the callback UI. int nPts = 2000 ; float anotherParam = 3.14 ; void mySubroutine () { // do something useful... // Register a structure std :: vector < glm :: vec3 > points ; for ( int i = 0 ; i < nPts ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit () }); } polyscope :: registerPointCloud ( \"my point cloud\" , points ); } // Your callback functions void myCallback () { // Since options::openImGuiWindowForUserCallback == true by default, // we can immediately start using ImGui commands to build a UI ImGui :: PushItemWidth ( 100 ); // Make ui elements 100 pixels wide, // instead of full width. Must have // matching PopItemWidth() below. ImGui :: InputInt ( \"num points\" , & nPts ); // set a int variable ImGui :: InputFloat ( \"param value\" , & anotherParam ); // set a float variable if ( ImGui :: Button ( \"run subroutine\" )) { // executes when button is pressed mySubroutine (); } ImGui :: SameLine (); if ( ImGui :: Button ( \"hi\" )) { polyscope :: warning ( \"hi\" ); } ImGui :: PopItemWidth (); } int main ( int argc , char ** argv ) { /* ...your program setup... */ // Initialize polyscope polyscope :: init (); // Specify the callback polyscope :: state :: userCallback = myCallback ; // Give control to the polyscope gui polyscope :: show (); return EXIT_SUCCESS ; } Options bool options :: openImGuiWindowForUserCallback open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true . bool options :: invokeUserCallbackForNestedShow invoke user callback for nested show Suppose you call polyscope::show() , and within your callback, another instance of polyscope::show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your userCallback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope::show() . Default: false .","title":"User Callback"},{"location":"features/user_callback/#intro","text":"When polyscope::show() has been called, Polyscope will optionally invoke user-supplied callback function on every loop iteration. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc. See ImGui for documentation of UI commands. std :: function < void () > polyscope :: state :: userCallback","title":"Intro"},{"location":"features/user_callback/#user-callback","text":"A function which will be invoked on every main loop iteration by Polyscope, once show() has been called. If null, nothing will be invoked.","title":"user callback"},{"location":"features/user_callback/#example","text":"The code below creates the following UI using a callback. #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" // Parameters which we will set in the callback UI. int nPts = 2000 ; float anotherParam = 3.14 ; void mySubroutine () { // do something useful... // Register a structure std :: vector < glm :: vec3 > points ; for ( int i = 0 ; i < nPts ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit () }); } polyscope :: registerPointCloud ( \"my point cloud\" , points ); } // Your callback functions void myCallback () { // Since options::openImGuiWindowForUserCallback == true by default, // we can immediately start using ImGui commands to build a UI ImGui :: PushItemWidth ( 100 ); // Make ui elements 100 pixels wide, // instead of full width. Must have // matching PopItemWidth() below. ImGui :: InputInt ( \"num points\" , & nPts ); // set a int variable ImGui :: InputFloat ( \"param value\" , & anotherParam ); // set a float variable if ( ImGui :: Button ( \"run subroutine\" )) { // executes when button is pressed mySubroutine (); } ImGui :: SameLine (); if ( ImGui :: Button ( \"hi\" )) { polyscope :: warning ( \"hi\" ); } ImGui :: PopItemWidth (); } int main ( int argc , char ** argv ) { /* ...your program setup... */ // Initialize polyscope polyscope :: init (); // Specify the callback polyscope :: state :: userCallback = myCallback ; // Give control to the polyscope gui polyscope :: show (); return EXIT_SUCCESS ; }","title":"Example"},{"location":"features/user_callback/#options","text":"bool options :: openImGuiWindowForUserCallback","title":"Options"},{"location":"features/user_callback/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui::Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true . bool options :: invokeUserCallbackForNestedShow","title":"open imgui window for user callback"},{"location":"features/user_callback/#invoke-user-callback-for-nested-show","text":"Suppose you call polyscope::show() , and within your callback, another instance of polyscope::show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your userCallback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope::show() . Default: false .","title":"invoke user callback for nested show"},{"location":"integrations/DGtal/","text":"This section demonstrates using Polyscope with DGtal for digital geometry processing. See this repository for a sample project configuration, CMAKE build system, and a quick demo! Adding a surface These snippets are from the example here . See that code for full setup and template definitions! // Initialize polyscope polyscope :: init (); // ... surface setup here, see full example... // create the surface auto primalSurface = SH3 :: makePrimalPolygonalSurface ( c2i , surface ); // Convert faces to appropriate indexed format std :: vector < std :: vector < unsigned long >> faces ; for ( auto & face : primalSurface -> allFaces ()) faces . push_back ( primalSurface -> verticesAroundFace ( face )); // Register pointels as a point cloud polyscope :: registerPointCloud ( \"Pointels\" , primalSurface -> positions ()); // Register surface with quadrilateral faces auto digsurf = polyscope :: registerSurfaceMesh ( \"Primal surface\" , primalSurface -> positions (), faces ); // Set appearance parameters digsurf -> edgeWidth = 1.0 ; digsurf -> edgeColor = { 1. , 1. , 1. }; // Show the gui polyscope :: show (); The resulting surface: Computing surface quantities // Compute some differential quantities params ( \"r-radius\" , 5.0 ); auto normals = SHG3 :: getCTrivialNormalVectors ( surface , surfels , params ); auto normalsTrivial = SHG3 :: getTrivialNormalVectors ( K , surfels ); auto normalsII = SHG3 :: getIINormalVectors ( binary_image , surfels , params ); auto Mcurv = SHG3 :: getIIMeanCurvatures ( binary_image , surfels , params ); auto Gcurv = SHG3 :: getIIGaussianCurvatures ( binary_image , surfels , params ); // Surfel area measure std :: vector < double > areaMeasure ( surfels . size ()); for ( auto i = 0 ; i < areaMeasure . size (); ++ i ) areaMeasure [ i ] = normalsTrivial [ i ]. dot ( normalsII [ i ]); // Add quantities for visualization digsurf -> addFaceVectorQuantity ( \"Trivial normal vectors\" , normalsTrivial ); digsurf -> addFaceVectorQuantity ( \"CTrivial normal vectors\" , normals ); digsurf -> addFaceVectorQuantity ( \"II normal vectors\" , normalsII ); digsurf -> addFaceScalarQuantity ( \"II mean curvature\" , Mcurv ); digsurf -> addFaceScalarQuantity ( \"II Gaussian curvature\" , Gcurv ); digsurf -> addFaceScalarQuantity ( \"Surfel area measure\" , areaMeasure ); // Show the gui polyscope :: show (); The resulting curvatures: The resulting normal vectors:","title":"DGtal"},{"location":"integrations/DGtal/#adding-a-surface","text":"These snippets are from the example here . See that code for full setup and template definitions! // Initialize polyscope polyscope :: init (); // ... surface setup here, see full example... // create the surface auto primalSurface = SH3 :: makePrimalPolygonalSurface ( c2i , surface ); // Convert faces to appropriate indexed format std :: vector < std :: vector < unsigned long >> faces ; for ( auto & face : primalSurface -> allFaces ()) faces . push_back ( primalSurface -> verticesAroundFace ( face )); // Register pointels as a point cloud polyscope :: registerPointCloud ( \"Pointels\" , primalSurface -> positions ()); // Register surface with quadrilateral faces auto digsurf = polyscope :: registerSurfaceMesh ( \"Primal surface\" , primalSurface -> positions (), faces ); // Set appearance parameters digsurf -> edgeWidth = 1.0 ; digsurf -> edgeColor = { 1. , 1. , 1. }; // Show the gui polyscope :: show (); The resulting surface:","title":"Adding a surface"},{"location":"integrations/DGtal/#computing-surface-quantities","text":"// Compute some differential quantities params ( \"r-radius\" , 5.0 ); auto normals = SHG3 :: getCTrivialNormalVectors ( surface , surfels , params ); auto normalsTrivial = SHG3 :: getTrivialNormalVectors ( K , surfels ); auto normalsII = SHG3 :: getIINormalVectors ( binary_image , surfels , params ); auto Mcurv = SHG3 :: getIIMeanCurvatures ( binary_image , surfels , params ); auto Gcurv = SHG3 :: getIIGaussianCurvatures ( binary_image , surfels , params ); // Surfel area measure std :: vector < double > areaMeasure ( surfels . size ()); for ( auto i = 0 ; i < areaMeasure . size (); ++ i ) areaMeasure [ i ] = normalsTrivial [ i ]. dot ( normalsII [ i ]); // Add quantities for visualization digsurf -> addFaceVectorQuantity ( \"Trivial normal vectors\" , normalsTrivial ); digsurf -> addFaceVectorQuantity ( \"CTrivial normal vectors\" , normals ); digsurf -> addFaceVectorQuantity ( \"II normal vectors\" , normalsII ); digsurf -> addFaceScalarQuantity ( \"II mean curvature\" , Mcurv ); digsurf -> addFaceScalarQuantity ( \"II Gaussian curvature\" , Gcurv ); digsurf -> addFaceScalarQuantity ( \"Surfel area measure\" , areaMeasure ); // Show the gui polyscope :: show (); The resulting curvatures: The resulting normal vectors:","title":"Computing surface quantities"},{"location":"integrations/geometry_central/","text":"This section demonstrates using Polyscope with geometry-central ! Note that a few useful adaptor functions are included in geometrycentral/surface/meshio.h . See this repository for a sample project configuration and CMAKE build system. Registering a surface mesh #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; SurfaceMesh & mesh = /* your mesh */ ; EmbeddedGeometryInterface & geom = /* your geometry */ ; // Be sure your mesh has vertex positions available geom . requireVertexPositions (); // Register the mesh with polyscope polyscope :: registerSurfaceMesh ( \"myMesh\" , geom . vertexPositions , mesh . getFaceVertexList ()); // Note: for a VertexPositionGeometry, one could instead use: VertexPositionGeometry & posGeom = /* your geometry */ ; polyscope :: registerSurfaceMesh ( \"myMesh\" , posGeom . inputVertexPositions , mesh . getFaceVertexList ()); Compressed meshes Polyscope expects dense buffers of data, but geometry-central uses sparse and lazily allocated buffers to support fast mesh modification. If you are modifying your mesh, be sure to call mesh->compress() before registering it with Polyscope. Note: Geometry-central meshes must be in \u201ccompressed mode\u201d (with dense indices) to register with Polyscope. If you have deleted elements from your mesh, this may require calling SurfaceMesh::compress() before you register it. Meshdata containers Geometry-central\u2019s Meshdata<> containers can be passed directly to Polyscope for visualization. /* (continuing up from the Registering example above) */ VertexData < double > myScalar = /* some scalar on vertices */ ; polyscope :: getMesh ( \"myMesh\" ) -> addVertexScalarQuantity ( \"myScalar\" , myScalar ); FaceData < double > otherScalar = /* another scalar on faces*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addFaceScalarQuantity ( \"otherScalar\" , otherScalar ); FaceData < double > anotherScalar = /* another scalar on edges*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addEdgeScalarQuantity ( \"super important edge scalar\" , anotherScalar ); // Containers holding `Vector3`s can be used for 3D vectors at faces and vertices // Example: vertex normals as computed in geometry-central posGeom -> requireVertexNormals (); polyscope :: getMesh ( \"myMesh\" ) -> addVertexVectorQuantity ( \"vertex normals\" , posGeom -> vertexNormals ); Custom ordering Geometry-central\u2019s ordering of mesh halfedges and corners is different from Polyscope\u2019s default ordering (see indexing convention ). As such, you must tell Polyscope about this ordering for edge-valued, halfedge-valued or corner-valued visualizations to work properly. The geometry-central function polyscopePermutations(HalfedgeMesh& mesh) from meshio.h generates the ordering data in an approriate form for Polyscope, and can be passed either at construction time or after. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // could alternately pass polyscopePermutations(*mesh) as additional // last parameter of constructor polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh )); Tangent vector data 1-forms To communicate the canonical edge orientation when passing a 1-form, use polyscopeEdgeOrientations(mesh) from meshio.h . Example: #include \"geometrycentral/surface/meshio.h\" HalfedgeMesh & mesh = /* your mesh */ ; EdgeData < double > myForm = /* your 1-form */ ; polyscope :: getSurfaceMesh ( \"myMesh\" ) -> addOneFormIntrinsicVectorQuantity ( \"my form\" , myForm , polyscopeEdgeOrientations ( mesh ));","title":"Geometry Central"},{"location":"integrations/geometry_central/#registering-a-surface-mesh","text":"#include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; SurfaceMesh & mesh = /* your mesh */ ; EmbeddedGeometryInterface & geom = /* your geometry */ ; // Be sure your mesh has vertex positions available geom . requireVertexPositions (); // Register the mesh with polyscope polyscope :: registerSurfaceMesh ( \"myMesh\" , geom . vertexPositions , mesh . getFaceVertexList ()); // Note: for a VertexPositionGeometry, one could instead use: VertexPositionGeometry & posGeom = /* your geometry */ ; polyscope :: registerSurfaceMesh ( \"myMesh\" , posGeom . inputVertexPositions , mesh . getFaceVertexList ()); Compressed meshes Polyscope expects dense buffers of data, but geometry-central uses sparse and lazily allocated buffers to support fast mesh modification. If you are modifying your mesh, be sure to call mesh->compress() before registering it with Polyscope. Note: Geometry-central meshes must be in \u201ccompressed mode\u201d (with dense indices) to register with Polyscope. If you have deleted elements from your mesh, this may require calling SurfaceMesh::compress() before you register it.","title":"Registering a surface mesh"},{"location":"integrations/geometry_central/#meshdata-containers","text":"Geometry-central\u2019s Meshdata<> containers can be passed directly to Polyscope for visualization. /* (continuing up from the Registering example above) */ VertexData < double > myScalar = /* some scalar on vertices */ ; polyscope :: getMesh ( \"myMesh\" ) -> addVertexScalarQuantity ( \"myScalar\" , myScalar ); FaceData < double > otherScalar = /* another scalar on faces*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addFaceScalarQuantity ( \"otherScalar\" , otherScalar ); FaceData < double > anotherScalar = /* another scalar on edges*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addEdgeScalarQuantity ( \"super important edge scalar\" , anotherScalar ); // Containers holding `Vector3`s can be used for 3D vectors at faces and vertices // Example: vertex normals as computed in geometry-central posGeom -> requireVertexNormals (); polyscope :: getMesh ( \"myMesh\" ) -> addVertexVectorQuantity ( \"vertex normals\" , posGeom -> vertexNormals );","title":"Meshdata containers"},{"location":"integrations/geometry_central/#custom-ordering","text":"Geometry-central\u2019s ordering of mesh halfedges and corners is different from Polyscope\u2019s default ordering (see indexing convention ). As such, you must tell Polyscope about this ordering for edge-valued, halfedge-valued or corner-valued visualizations to work properly. The geometry-central function polyscopePermutations(HalfedgeMesh& mesh) from meshio.h generates the ordering data in an approriate form for Polyscope, and can be passed either at construction time or after. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // could alternately pass polyscopePermutations(*mesh) as additional // last parameter of constructor polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh ));","title":"Custom ordering"},{"location":"integrations/geometry_central/#tangent-vector-data","text":"","title":"Tangent vector data"},{"location":"integrations/geometry_central/#1-forms","text":"To communicate the canonical edge orientation when passing a 1-form, use polyscopeEdgeOrientations(mesh) from meshio.h . Example: #include \"geometrycentral/surface/meshio.h\" HalfedgeMesh & mesh = /* your mesh */ ; EdgeData < double > myForm = /* your 1-form */ ; polyscope :: getSurfaceMesh ( \"myMesh\" ) -> addOneFormIntrinsicVectorQuantity ( \"my form\" , myForm , polyscopeEdgeOrientations ( mesh ));","title":"1-forms"},{"location":"integrations/libIGL/","text":"This section demonstrates using Polyscope with libIGL . See this repository for a sample project configuration, CMAKE build system, and a quick demo. Generally, Polyscope\u2019s data adaptors work as expected with libIGL! You can simply call Polyscope functions and pass your IGL Eigen matrix types. Adding a mesh Example: // Initialize polyscope polyscope :: init (); // Read a mesh igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the gui polyscope :: show (); Adding mesh quantities Adding a scalar quantity: using namespace Eigen ; // Compute pointwise Gaussian curvature VectorXd K ; igl :: gaussian_curvature ( meshV , meshF , K ); SparseMatrix < double > M , Minv ; igl :: massmatrix ( meshV , meshF , igl :: MASSMATRIX_TYPE_DEFAULT , M ); igl :: invert_diag ( M , Minv ); K = ( Minv * K ). eval (); // Add for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexScalarQuantity ( \"gaussian curvature\" , K ); Adding a vector quantity: // Compute vertex normals Eigen :: MatrixXd N_vertices ; igl :: per_vertex_normals ( meshV , meshF , N_vertices ); // Add them for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexVectorQuantity ( \"libIGL vertex normals\" , N_vertices );","title":"libIGL"},{"location":"integrations/libIGL/#adding-a-mesh","text":"Example: // Initialize polyscope polyscope :: init (); // Read a mesh igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the gui polyscope :: show ();","title":"Adding a mesh"},{"location":"integrations/libIGL/#adding-mesh-quantities","text":"Adding a scalar quantity: using namespace Eigen ; // Compute pointwise Gaussian curvature VectorXd K ; igl :: gaussian_curvature ( meshV , meshF , K ); SparseMatrix < double > M , Minv ; igl :: massmatrix ( meshV , meshF , igl :: MASSMATRIX_TYPE_DEFAULT , M ); igl :: invert_diag ( M , Minv ); K = ( Minv * K ). eval (); // Add for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexScalarQuantity ( \"gaussian curvature\" , K ); Adding a vector quantity: // Compute vertex normals Eigen :: MatrixXd N_vertices ; igl :: per_vertex_normals ( meshV , meshF , N_vertices ); // Add them for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexVectorQuantity ( \"libIGL vertex normals\" , N_vertices );","title":"Adding mesh quantities"},{"location":"structures/structure_management/","text":"Intro A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); Then, in a distant part of your code, add a scalar function to it with: polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); This avoids the need to pass a pointer to the structure you created around your entire codebase. Memory management As a general policy, Polyscope always manages its own memory, and will take care of deleting anything it allocated. Whenever a routine returns a pointer (like getStructure() ), it is a non-owning pointer. You should never delete one of these pointers. To delete a structure and free memory, see the removeStructure() methods below. The following structures available in Polyscope. Many more structures are in development! Surface Mesh Point Cloud Curve Network Volume Mesh in progress : Camera View Registering structures Each structure offers a register___(name, ...) function (like registerPointCloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a Structure* pointer which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. The general form for registering structures is below; it may be useful if you are implementing your own structures. bool registerStructure ( Structure * structure , bool replaceIfPresent = true ) Register a new structure with Polyscope. The structure must have a Structure::name which is unique amongst all registered structures of that type. Polyscope takes ownership of the memory when the structure is registered, and will delete it when no longer needed. Note: most users will create structures via the individual registerPointCloud() (etc) functions, rather than this general form. Accessing structures Polyscope offers two patterns for calling methods on a registered structure: you can either use the pointer returned after structure creation, or refer to the structure by name. #include \"polyscope/surface_mesh.h\" // register a structure polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); // access with the pointer psMesh -> addScalarQuantity ( \"some values\" , values ); // access by name polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); The former is concise and programmatic, while the latter avoids the need to keep track of a variable. As before, each structure offers a get___(name) method, like getSurfaceMesh(name) which can be used to get a pointer to the structure of that type by name. The general form below may be useful if you are implementing your own structures. Structure * getStructure ( std :: string type , std :: string name = \"\" ) Get a pointer to a registered structure. The type must be the unique string corresponding to the structure type. As a convenience, if the name may be argument omitted only if there is exactly one structure of that type. If not such structure is available, nullptr will be returned. Note: most users will get structures via the individual getPointCloud() (etc) functions, rather than this general form. Removing structures If no longer needed, structures can be removed by name or by pointer. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. void removeStructure ( Structure * structure , bool errorIfAbsent = true ) Remove the specified structure and free objects associated with it. If errorIfAbsent == true , and error will be thrown if there is no such structure registered, otherwise the function will return silently. void removeStructure ( std :: string type , std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a type name and name instead. void removeStructure ( std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a name instead. Will fail unless there is exactly one structure with the given name across all structure types.","title":"Structure Management"},{"location":"structures/structure_management/#intro","text":"A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); Then, in a distant part of your code, add a scalar function to it with: polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); This avoids the need to pass a pointer to the structure you created around your entire codebase. Memory management As a general policy, Polyscope always manages its own memory, and will take care of deleting anything it allocated. Whenever a routine returns a pointer (like getStructure() ), it is a non-owning pointer. You should never delete one of these pointers. To delete a structure and free memory, see the removeStructure() methods below. The following structures available in Polyscope. Many more structures are in development! Surface Mesh Point Cloud Curve Network Volume Mesh in progress : Camera View","title":"Intro"},{"location":"structures/structure_management/#registering-structures","text":"Each structure offers a register___(name, ...) function (like registerPointCloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a Structure* pointer which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. The general form for registering structures is below; it may be useful if you are implementing your own structures. bool registerStructure ( Structure * structure , bool replaceIfPresent = true ) Register a new structure with Polyscope. The structure must have a Structure::name which is unique amongst all registered structures of that type. Polyscope takes ownership of the memory when the structure is registered, and will delete it when no longer needed. Note: most users will create structures via the individual registerPointCloud() (etc) functions, rather than this general form.","title":"Registering structures"},{"location":"structures/structure_management/#accessing-structures","text":"Polyscope offers two patterns for calling methods on a registered structure: you can either use the pointer returned after structure creation, or refer to the structure by name. #include \"polyscope/surface_mesh.h\" // register a structure polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); // access with the pointer psMesh -> addScalarQuantity ( \"some values\" , values ); // access by name polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); The former is concise and programmatic, while the latter avoids the need to keep track of a variable. As before, each structure offers a get___(name) method, like getSurfaceMesh(name) which can be used to get a pointer to the structure of that type by name. The general form below may be useful if you are implementing your own structures. Structure * getStructure ( std :: string type , std :: string name = \"\" ) Get a pointer to a registered structure. The type must be the unique string corresponding to the structure type. As a convenience, if the name may be argument omitted only if there is exactly one structure of that type. If not such structure is available, nullptr will be returned. Note: most users will get structures via the individual getPointCloud() (etc) functions, rather than this general form.","title":"Accessing structures"},{"location":"structures/structure_management/#removing-structures","text":"If no longer needed, structures can be removed by name or by pointer. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. void removeStructure ( Structure * structure , bool errorIfAbsent = true ) Remove the specified structure and free objects associated with it. If errorIfAbsent == true , and error will be thrown if there is no such structure registered, otherwise the function will return silently. void removeStructure ( std :: string type , std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a type name and name instead. void removeStructure ( std :: string name , bool errorIfAbsent = true ) Identical to removeStructure(Struture*) , but accepts a name instead. Will fail unless there is exactly one structure with the given name across all structure types.","title":"Removing structures"},{"location":"structures/curve_network/basics/","text":"Curve Networks Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point! Registering a curve network Curve network structures can be registered with Polyscope by passing the node position and edge indices. There are also two helpers for constructing lines and loops which only require the node locations and automatically build connectivity. As usual in Polyscope, the data adaptors allow these functions to accept a wide variety of data types as input\u2013 any nodes which are essentially a list of vectors and any edges which are a list of index tuples will work. The std::vector<> types in the example below are just one possibility. Example: add a curve network #include \"polyscope/curve_network.h\" polyscope :: init (); std :: vector < glm :: vec3 > nodes = /* some nodes */ ; std :: vector < std :: array < size_t , 2 >> edges = /* edges between nodes */ ; // Add the curve network polyscope :: registerCurveNetwork ( \"my network\" , nodes , edges ); // visualize! polyscope :: show (); CurveNetwork * polyscope :: registerCurveNetwork ( std :: string name , const P & nodes , const E & edges ) Add a new curve network to polyscope nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. edges is the array of edges, each of which is a pair of 0-based node indices node. The type should be adaptable to an array of size_t -valued 2-vectors. The length will be the number of edges. Note: the inner vector type of the nodes input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetwork2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLine ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a polyline of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLine2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLoop ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a closed loop of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLoop2D exists with the same signature. See 2D data . Updating a curve network The locations of the nodes in a curve network can be updated with the member function updateNodePositions(newPositions) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). void CurveNetwork :: updateNodePositions ( const V & newPositions ) Update the node positions in a curve network structure. newPositions is the vector array of 3D node locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of nodes. Note: updatePointPositions2D exists with the same signature. See 2D data . Options Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes radius size of rendered points and lines double getRadius () setRadius ( double newVal , bool isRelative = true ) yes color default color the curve network glm :: vec3 getColor setColor(glm::vec3 newVal) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Basics"},{"location":"structures/curve_network/basics/#curve-networks","text":"Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point!","title":"Curve Networks"},{"location":"structures/curve_network/basics/#registering-a-curve-network","text":"Curve network structures can be registered with Polyscope by passing the node position and edge indices. There are also two helpers for constructing lines and loops which only require the node locations and automatically build connectivity. As usual in Polyscope, the data adaptors allow these functions to accept a wide variety of data types as input\u2013 any nodes which are essentially a list of vectors and any edges which are a list of index tuples will work. The std::vector<> types in the example below are just one possibility. Example: add a curve network #include \"polyscope/curve_network.h\" polyscope :: init (); std :: vector < glm :: vec3 > nodes = /* some nodes */ ; std :: vector < std :: array < size_t , 2 >> edges = /* edges between nodes */ ; // Add the curve network polyscope :: registerCurveNetwork ( \"my network\" , nodes , edges ); // visualize! polyscope :: show (); CurveNetwork * polyscope :: registerCurveNetwork ( std :: string name , const P & nodes , const E & edges ) Add a new curve network to polyscope nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. edges is the array of edges, each of which is a pair of 0-based node indices node. The type should be adaptable to an array of size_t -valued 2-vectors. The length will be the number of edges. Note: the inner vector type of the nodes input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetwork2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLine ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a polyline of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLine2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLoop ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a closed loop of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLoop2D exists with the same signature. See 2D data .","title":"Registering a curve network"},{"location":"structures/curve_network/basics/#updating-a-curve-network","text":"The locations of the nodes in a curve network can be updated with the member function updateNodePositions(newPositions) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). void CurveNetwork :: updateNodePositions ( const V & newPositions ) Update the node positions in a curve network structure. newPositions is the vector array of 3D node locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of nodes. Note: updatePointPositions2D exists with the same signature. See 2D data .","title":"Updating a curve network"},{"location":"structures/curve_network/basics/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes radius size of rendered points and lines double getRadius () setRadius ( double newVal , bool isRelative = true ) yes color default color the curve network glm :: vec3 getColor setColor(glm::vec3 newVal) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Options"},{"location":"structures/curve_network/color_quantities/","text":"Visualize color rgb-valued data at the nodes or edges of a curve network. Example: #include \"polyscope/curve_network.h\" std :: vector < std :: array < double , 3 >> randColor ( edges . size ()); for ( size_t i = 0 ; i < edges . size (); i ++ ) { randColor [ i ] = {{ polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit ()}}; } // visualize polyscope :: getCurveNetwork ( curveNetworkName ) -> addEdgeColorQuantity ( \"random color\" , randColor ); CurveNetwork :: addNodeColorQuantity ( std :: string name , const T & values ) Add a color quantity to the nodes of the curve network values is the array of colors at nodes. The type should be adaptable to a 3-vector array of float s. The length should be the number of nodes in the curve network. RGB values are interpreted in the range [0,1] . CurveNetwork :: addEdgeColorQuantity ( std :: string name , const T & values ) Add a color quantity to the edges of the curve network values is the array of colors at edges. The type should be adaptable to a 3-vector array of float s. The length should be the number of edges in the curve network. RGB values are interpreted in the range [0,1] . Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Color Quantities"},{"location":"structures/curve_network/color_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/curve_network/scalar_quantities/","text":"Visualize scalar valued data at the nodes or edges of a curve network. Example: #include \"polyscope/curve_network.h\" std :: vector < double > xC ( nodes . size ()); for ( size_t i = 0 ; i < nodes . size (); i ++ ) { xC [ i ] = nodes [ i ]. x ; // (use the x coordinate as sample data) } // visualize polyscope :: getCurveNetwork ( curveNetworkName ) -> addNodeScalarQuantity ( \"sample value\" , xC ); CurveNetwork :: addNodeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity to the nodes of the curve network. values is the array of scalars at nodes. The type should be adaptable to a float scalar array. The length should be the number of nodes in the curve network. CurveNetwork :: addEdgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity to the edges of the curve network. values is the array of scalars at edges . The type should be adaptable to a float scalar array. The length should be the number of edges in the curve network. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Scalar Quantities"},{"location":"structures/curve_network/scalar_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/curve_network/vector_quantities/","text":"Visualize vector-valued data at the nodes or edges of a curve network. Example: add vectors at nodes #include \"polyscope/curve_network.h\" // Generate random vectors as example vector data std :: vector < glm :: vec3 > randVec ( nNodes ); for ( size_t iN = 0 ; iN < nNodes ; iN ++ ) { randVec [ iN ] = glm :: vec3 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }; } // Add the vector data to the curve network polyscope :: getCurveNetwork ( \"my curve\" ) -> addNodeVectorQuantity ( \"sample vectors\" , randVec ); // Visualize polyscope :: show (); CurveNetwork :: addNodeVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity to the nodes of a curve network. Vectors will be drawn with their roots at each edge. vectors is the array of vectors at nodes. The type should be adaptable to a 3-vector array of float s. The length should be the number of nodes in the curve network. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D curve network), addNodeVectorQuantity2D exists with the same signature. See 2D data . CurveNetwork :: addEdgeVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity to the edges of a curve network. Vectors will be drawn with their roots at the center of each each. vectors is the array of vectors at edges. The type should be adaptable to a 3-vector array of float s. The length should be the number of edges in the curve network. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D curve network), addEdgeVectorQuantity2D exists with the same signature. See 2D data . Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Vector Quantities"},{"location":"structures/curve_network/vector_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/point_cloud/basics/","text":"Point Clouds Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point. Registering a point cloud Example: a point cloud of random points #include \"polyscope/point_cloud.h\" std :: vector < glm :: vec3 > points ; // generate points for ( size_t i = 0 ; i < 3000 ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }); } // visualize! polyscope :: registerPointCloud ( \"really great points\" , points ); polyscope :: registerPointCloud ( std :: string name , const T & pointPositions ) Add a new point cloud structure to Polyscope. pointPositions is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of points. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D point cloud, registerPointCloud2D exists with the same signature. See 2D data . Updating a point cloud The locations of the points in a point cloud can be updated with the member function updatePointPositions(newPositions) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). void PointCloud :: updatePointPositions ( const V & newPositions ) Update the point positions in a point cloud structure. newPositions is the vector array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of points. Note: updatePointPositions2D exists with the same signature. See 2D data . Options Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes point radius size of rendered points double getPointRadius () setPointRadius ( double newVal , bool isRelative = true ) yes point color default color for point glm :: vec3 getPointColor () setPointColor(glm::vec3 newVal) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Basics"},{"location":"structures/point_cloud/basics/#point-clouds","text":"Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point.","title":"Point Clouds"},{"location":"structures/point_cloud/basics/#registering-a-point-cloud","text":"Example: a point cloud of random points #include \"polyscope/point_cloud.h\" std :: vector < glm :: vec3 > points ; // generate points for ( size_t i = 0 ; i < 3000 ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }); } // visualize! polyscope :: registerPointCloud ( \"really great points\" , points ); polyscope :: registerPointCloud ( std :: string name , const T & pointPositions ) Add a new point cloud structure to Polyscope. pointPositions is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of points. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D point cloud, registerPointCloud2D exists with the same signature. See 2D data .","title":"Registering a point cloud"},{"location":"structures/point_cloud/basics/#updating-a-point-cloud","text":"The locations of the points in a point cloud can be updated with the member function updatePointPositions(newPositions) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). void PointCloud :: updatePointPositions ( const V & newPositions ) Update the point positions in a point cloud structure. newPositions is the vector array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of points. Note: updatePointPositions2D exists with the same signature. See 2D data .","title":"Updating a point cloud"},{"location":"structures/point_cloud/basics/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes point radius size of rendered points double getPointRadius () setPointRadius ( double newVal , bool isRelative = true ) yes point color default color for point glm :: vec3 getPointColor () setPointColor(glm::vec3 newVal) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Options"},{"location":"structures/point_cloud/color_quantities/","text":"Visualize color rgb-valued data at the points of a point cloud. Example: #include \"polyscope/point_cloud.h\" std :: vector < std :: array < double , 3 >> randColor ( points . size ()); for ( size_t i = 0 ; i < points . size (); i ++ ) { randColor [ i ] = {{ polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit ()}}; } // visualize polyscope :: getPointCloud ( pointCloudName ) -> addColorQuantity ( \"random color\" , randColor ); PointCloud :: addColorQuantity ( std :: string name , const T & values ) Add a color quantity to the point cloud. values is the array of colors at points. The type should be adaptable to a 3-vector array of float s. The length should be the number of points in the point cloud. RGB values are interpreted in the range [0,1] . Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Color Quantities"},{"location":"structures/point_cloud/color_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/point_cloud/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the points of a point cloud. Example: #include \"polyscope/point_cloud.h\" std :: vector < double > xC ( points . size ()); for ( size_t i = 0 ; i < points . size (); i ++ ) { xC [ i ] = points [ i ]. x ; } // visualize polyscope :: getPointCloud ( pointCloudName ) -> addScalarQuantity ( \"xC\" , xC ); PointCloud :: addScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity to the point cloud. values is the array of scalars at points. The type should be adaptable to a float scalar array. The length should be the number of points in the point cloud. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Scalar Quantities"},{"location":"structures/point_cloud/scalar_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/point_cloud/variable_radius/","text":"By default, all points in the cloud have the same radius. However, any point cloud scalar quantity can be additionally interpreted as the radius of the points. This can also be set manually in the GUI via the point cloud [Options] \u2013> [Variable Radius]. Example: #include \"polyscope/point_cloud.h\" // Populate a random scalar quantity std :: vector < double > xC ( points . size ()); for ( size_t i = 0 ; i < points . size (); i ++ ) { xC [ i ] = points [ i ]. x ; } // Get a reference to some point cloud auto psCloud = polyscope :: getPointCloud ( /* your point cloud name */ ); auto q = psCloud -> addScalarQuantity ( \"xC\" , xC ); // add the quantity psCloud -> setPointRadiusQuantity ( q ); // set the quantity as the radius // psCloud->setPointRadiusQuantity(\"xC\"); // equivalently, the name can be used Any negative values in the scalar quantity will be clamped to 0 . By default, values will be rescaled such that the largest corresponds to the size from the point radius option (thus, using any constant scalar quantity will make the radii identical to the default value with no radius set). This automatic scaling can be disabled by setting autoScale=false below. Reproducing radius in world units Remember that point clouds always have a per-structure radius parameter which sets a radius for all of the points in the point cloud (and can be adjusted via a slider in the GUI, or via setPointRadius() ). This per-structure parameter makes things a little more complicated when also setting length via a scalar quantity as described here. By default, the structure radius parameter is still respected. The variable radius from the quantity first scaled such that the largest value is 1. , and then is multiplied by the structure parameter to get the actual radius used for the points. This usually gives a reasonable visualization, but makes it difficult to set a precise radius in world units. To properly reproduce a radius in world-coordinate units, you can circumvent autoscaling like cloud->setPointRadiusQuantity(q, false) . This will prevent the auto-scaling of the radii, and also ignore the structure\u2019s point radius parameter. void PointCloud :: setPointRadiusQuantity ( PointCloudScalarQuantity * quantity , bool autoScale = true ) Set the point radius from a quantity. When using a radius which is a physical length in world coordinates, set autoScale to false to skip rescaling and ignore the structure\u2019s point radius parameter. void PointCloud :: setPointRadiusQuantity ( std :: string name , bool autoScale = true ) Set the point radius from a quantity by name. The quantity must be a point cloud scalar quantity add to this cloud. When using a radius which is a physical length in world coordinates, set autoScale to false to skip rescaling and ignore the structure\u2019s point radius parameter. void PointCloud :: clearPointRadiusQuantity () Clear the point radius quantity and return to using the constant radius.","title":"Variable Radius"},{"location":"structures/point_cloud/vector_quantities/","text":"Visualize vector-valued data at the points of a point cloud. PointCloud :: addVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity to the point cloud. vectors is the array of vectors at points. The type should be adaptable to a 3-vector array of float s. The length should be the number of points in the point cloud. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D point cloud), addVectorQuantity2D exists with the same signature. See 2D data . Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Vector Quantities"},{"location":"structures/point_cloud/vector_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/basics/","text":"Surface Meshes Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/edges/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element. Registering a surface mesh Example: registering a surface mesh from libIGL #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include <igl/readOBJ.h> // Initialize Polyscope polyscope :: init (); // Read the mesh Eigen :: MatrixXd meshV ; Eigen :: MatrixXi meshF ; igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the GUI polyscope :: show (); Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices ) Add a new surface mesh structure to Polyscope. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. faceIndices is the nested array of vertex indices for each face. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 3>> . The outer length will be the number of faces. All indices should be valid 0-based indices in to the vertex list. General nested lists can be used to create polygonal meshes of varying face degree, such as std::vector<std::vector<size_t>> . Also, passing a fixed-size 2D array of indices will work just fine, like Eigen::MatrixXi with Fx3 dimensions for a triangle mesh, or Fx4 for a quad mesh. Note: the inner vector type of the vertex positions must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D surface mesh, registerSurfaceMesh2D exists with the same signature. See 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everyone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering. Updating a mesh The locations of the vertices in a mesh can be updated with the member function updateVertexPositions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). void SurfaceMesh :: updateVertexPositions ( const V & newPositions ) Update the vertex positions in a surface mesh structure. newPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of vertices. Note: updateVertexPositions2D exists with the same signature. See 2D data . Back face policies The faces of a mesh are implicitly given an outward orientation by the order in which the vertices are listed. The standard convention, which Polyscope respects, is that a counter-clockwise ordering of vertices defines the \u201coutward\u201d direction. Faces which are viewed from behind are referred to as back faces ; they can arise when a surface is viewed from the inside, or if a mesh is not properly oriented. Polyscope offers several options for how backfaces are displayed. BackFacePolicy::Identical all faces are always rendered identically, whether viewed from the front or back BackFacePolicy::Different backfaces are shaded differently, so they can be distinguished (this is the default) BackFacePolicy::Cull backfaces are culled, and not rendered at all The choice of these policies can be set as an option for each surface mesh structure, either in the GUI via [Options] -> [Back Face Policy] or programmatically with the function below. SurfaceMesh * SurfaceMesh :: setBackFacePolicy ( BackFacePolicy newPolicy ) Set the policy for rendering oppositely-oriented backfaces. newPolicy is an enum giving the new policy, one of BackFacePolicy::Identical , BackFacePolicy::Different , or BackFacePolicy::Cull as described above There is also a corresponding getBackFacePolicy() . Options Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes shade smooth use smooth shading along faces or simple flat faces bool isSmoothShade () setSmoothShade ( bool isSmooth ) yes surface color the color of the mesh glm :: vec3 getSurfaceColor () setSurfaceColor ( glm :: vec3 val ) yes edge color the color of the edges of the mesh glm :: vec3 getEdgeColor () setEdgeColor ( glm :: vec3 val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges double getEdgeWidth () setEdgeWidth ( double val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes back face policy what back face policy to use BackFacePolicy getBackFacePolicy () setBackFacePolicy(BackFacePolicy newPolicy) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Basics"},{"location":"structures/surface_mesh/basics/#surface-meshes","text":"Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/edges/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element.","title":"Surface Meshes"},{"location":"structures/surface_mesh/basics/#registering-a-surface-mesh","text":"Example: registering a surface mesh from libIGL #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include <igl/readOBJ.h> // Initialize Polyscope polyscope :: init (); // Read the mesh Eigen :: MatrixXd meshV ; Eigen :: MatrixXi meshF ; igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the GUI polyscope :: show (); Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices ) Add a new surface mesh structure to Polyscope. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. faceIndices is the nested array of vertex indices for each face. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 3>> . The outer length will be the number of faces. All indices should be valid 0-based indices in to the vertex list. General nested lists can be used to create polygonal meshes of varying face degree, such as std::vector<std::vector<size_t>> . Also, passing a fixed-size 2D array of indices will work just fine, like Eigen::MatrixXi with Fx3 dimensions for a triangle mesh, or Fx4 for a quad mesh. Note: the inner vector type of the vertex positions must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D surface mesh, registerSurfaceMesh2D exists with the same signature. See 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everyone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering.","title":"Registering a surface mesh"},{"location":"structures/surface_mesh/basics/#updating-a-mesh","text":"The locations of the vertices in a mesh can be updated with the member function updateVertexPositions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). void SurfaceMesh :: updateVertexPositions ( const V & newPositions ) Update the vertex positions in a surface mesh structure. newPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of vertices. Note: updateVertexPositions2D exists with the same signature. See 2D data .","title":"Updating a mesh"},{"location":"structures/surface_mesh/basics/#back-face-policies","text":"The faces of a mesh are implicitly given an outward orientation by the order in which the vertices are listed. The standard convention, which Polyscope respects, is that a counter-clockwise ordering of vertices defines the \u201coutward\u201d direction. Faces which are viewed from behind are referred to as back faces ; they can arise when a surface is viewed from the inside, or if a mesh is not properly oriented. Polyscope offers several options for how backfaces are displayed. BackFacePolicy::Identical all faces are always rendered identically, whether viewed from the front or back BackFacePolicy::Different backfaces are shaded differently, so they can be distinguished (this is the default) BackFacePolicy::Cull backfaces are culled, and not rendered at all The choice of these policies can be set as an option for each surface mesh structure, either in the GUI via [Options] -> [Back Face Policy] or programmatically with the function below. SurfaceMesh * SurfaceMesh :: setBackFacePolicy ( BackFacePolicy newPolicy ) Set the policy for rendering oppositely-oriented backfaces. newPolicy is an enum giving the new policy, one of BackFacePolicy::Identical , BackFacePolicy::Different , or BackFacePolicy::Cull as described above There is also a corresponding getBackFacePolicy() .","title":"Back face policies"},{"location":"structures/surface_mesh/basics/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes shade smooth use smooth shading along faces or simple flat faces bool isSmoothShade () setSmoothShade ( bool isSmooth ) yes surface color the color of the mesh glm :: vec3 getSurfaceColor () setSurfaceColor ( glm :: vec3 val ) yes edge color the color of the edges of the mesh glm :: vec3 getEdgeColor () setEdgeColor ( glm :: vec3 val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges double getEdgeWidth () setEdgeWidth ( double val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes back face policy what back face policy to use BackFacePolicy getBackFacePolicy () setBackFacePolicy(BackFacePolicy newPolicy) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Options"},{"location":"structures/surface_mesh/color_quantities/","text":"Visualize color rgb-valued data at the elements of a surface mesh. Example : visualizing random colors at faces #include \"polyscope/surface_mesh.h\" // Make some random colors std :: vector < std :: array < double , 3 >> fColor ( nFaces ); for ( size_t iF = 0 ; iF < nFaces ; iF ++ ) { std :: vector < size_t >& face = faceIndices [ iF ]; fColor [ iF ] = {{ polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit ()}}; } // Visualize polyscope :: getSurfaceMesh ( \"name\" ) -> addFaceColorQuantity ( \"fColor\" , fColor ); Add colors to elements SurfaceMesh :: addVertexColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the vertices of the mesh. values is the array of colors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. RGB values are interpreted in the range [0,1] . SurfaceMesh :: addFaceColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the faces of the mesh. values is the array of colors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. RGB values are interpreted in the range [0,1] . Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Color Quantities"},{"location":"structures/surface_mesh/color_quantities/#add-colors-to-elements","text":"SurfaceMesh :: addVertexColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the vertices of the mesh. values is the array of colors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. RGB values are interpreted in the range [0,1] . SurfaceMesh :: addFaceColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the faces of the mesh. values is the array of colors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. RGB values are interpreted in the range [0,1] .","title":"Add colors to elements"},{"location":"structures/surface_mesh/color_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/count_quantities/","text":"Count quantities store integers defined at just a few elements of a mesh, rather than at every element. These useful for visualizing special vertices or faces, e.g., singularities of a vector field. Example: #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" // Generate a random count quantity std :: vector < std :: pair < size_t , int >> vCount ; for ( size_t iV = 0 ; iV < nVertices ; iV ++ ) { if ( polyscope :: randomUnit () > 0.95 ) { vCount . push_back ( std :: make_pair ( iV , 2 )); } } // Add the count quantity polyscope :: getSurfaceMesh ( /*mesh name */ ) -> addVertexCountQuantity ( \"sample count\" , vCount ); No adaptors here Unlike almost all other quantity adders in Polyscope, these do not use the data adaptors, and must be explicitly given a std::vector<> . SurfaceVertexCountQuantity * SurfaceMesh :: addVertexCountQuantity ( std :: string name , const std :: vector < std :: pair < size_t , int >>& values ) Add a count quantity defined at vertices. values is a list of pairs, where the first entry of each pair is a vertex index, and the second is an integer value at that vertex. This list may be any length. SurfaceFaceCountQuantity * SurfaceMesh :: addFaceCountQuantity ( std :: string name , const std :: vector < std :: pair < size_t , int >>& values ) Add a count quantity defined at faces. values is a list of pairs, where the first entry of each pair is a face index, and the second is an integer value at that vertex. This list may be any length. SurfaceVertexIsolatedScalarQuantity * SurfaceMesh :: addVertexIsolatedScalarQuantity ( std :: string name , const std :: vector < std :: pair < size_t , double >>& values ) Add an isolated quantity defined at vertices. This is very similar to the SurfaceVertexCountQuantity , except the data is real-valued rather than integer-valued. values is a list of pairs, where the first entry of each pair is a vertex index, and the second is an real value at that vertex. This list may be any length. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes point radius radius of points double getPointRadius () setPointRadius ( double newVal , bool isRelative ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Count Quantities"},{"location":"structures/surface_mesh/count_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes point radius radius of points double getPointRadius () setPointRadius ( double newVal , bool isRelative ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/distance_quantities/","text":"Visualize distance-valued data at the elements of a surface mesh. Distance quantities are basicly scalars, but are visualized with alternating stripes to show distance contours. Example : visualizing exact geodesic distance computed via libIGL\u2019s wrappers around Kirsanov\u2019s MMP implementation. // Compute distance from vertex iVertexSource Eigen :: VectorXi VS , FS , VT , FT ; VS . resize ( 1 ); VS << iVertexSource ; VT . setLinSpaced ( meshV . rows (), 0 , meshV . rows () - 1 ); Eigen :: VectorXd d ; igl :: exact_geodesic ( meshV , meshF , VS , FS , VT , FT , d ); // Add the distance quantity to the surface mesh polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexDistanceQuantity ( \"distance from vertex \" + std :: to_string ( iVertexSource ), d ); Add distance to vertices SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a signed distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. This quantity is very similar to addVertexDistanceQuantity , except the colormap is adjusted to scale symetrically for negative values. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no stripe size the size of the stripes showing distance isolines setStripeSize ( double size , bool isRelative = true ) double getStripeSize () yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Distance Quantities"},{"location":"structures/surface_mesh/distance_quantities/#add-distance-to-vertices","text":"SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a signed distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. This quantity is very similar to addVertexDistanceQuantity , except the colormap is adjusted to scale symetrically for negative values.","title":"Add distance to vertices"},{"location":"structures/surface_mesh/distance_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no stripe size the size of the stripes showing distance isolines setStripeSize ( double size , bool isRelative = true ) double getStripeSize () yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/indexing_convention/","text":"Default ordering Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors ). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in a mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering. Vertices The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setVertexPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for vertex-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Faces The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setFacePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for face-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Edges The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setEdgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for edge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Halfedges The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setHalfedgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Corners The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setCornerPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for corner-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. All at once As a convenience, you can alternately define a single function which passes all permutations needed at the same time. This is useful because you can write a single helper function which defines any necessary permutations for the mesh convention in your codebase; see the geometry-central integration for an example. The permutations should be passed as a std :: array < std :: pair < T , size_t > , 5 > , where T is any type that could be used in the set___Permutation() functions above\u2014one good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Each entry of this array is one of the permutations listed above: [vertices, faces, edges, halfedges, corners]. Any permutations which have size() == 0 will be untouched. The second entry of the pair is the optional size of the target index space, as in expectedSize above. These permutations can either be set with SurfaceMesh::setAllPermutations() , or at construction time via a third argument to registerSurfaceMesh() . SurfaceMesh :: setAllPermutations ( const std :: array < std :: pair < T , size_t > , 5 >& perms ) Set all of the ordering permutations at once, as described above. The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . If the size of your index space is different from size of the default index space, the second component of each pair must give this new size. Otherwise, the second component of the pair may be set to zero, to infer the size of the index space from the maximum index given. Must be set before any quantites are added. SurfaceMesh * polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices , const std :: array < std :: pair < P , size_t > , 5 >& perms , bool replaceIfPresent = true ) Register a mesh and immediately set all custom permutations, as described above. Equivalent to SurfaceMesh * s = registerSurfaceMesh ( name , vertexPositions , faceIndices , replaceIfPresent ); s -> setAllPermutations ( perms ); Other wise behave like the standard registerSurfaceMesh() . The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Must be set before any quantites are added.","title":"Indexing Convention"},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","text":"Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors ). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in a mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.","title":"Default ordering"},{"location":"structures/surface_mesh/indexing_convention/#vertices","text":"The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setVertexPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for vertex-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Vertices"},{"location":"structures/surface_mesh/indexing_convention/#faces","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setFacePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for face-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Faces"},{"location":"structures/surface_mesh/indexing_convention/#edges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setEdgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for edge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Edges"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setHalfedgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Halfedges"},{"location":"structures/surface_mesh/indexing_convention/#corners","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setCornerPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for corner-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Corners"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","text":"As a convenience, you can alternately define a single function which passes all permutations needed at the same time. This is useful because you can write a single helper function which defines any necessary permutations for the mesh convention in your codebase; see the geometry-central integration for an example. The permutations should be passed as a std :: array < std :: pair < T , size_t > , 5 > , where T is any type that could be used in the set___Permutation() functions above\u2014one good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Each entry of this array is one of the permutations listed above: [vertices, faces, edges, halfedges, corners]. Any permutations which have size() == 0 will be untouched. The second entry of the pair is the optional size of the target index space, as in expectedSize above. These permutations can either be set with SurfaceMesh::setAllPermutations() , or at construction time via a third argument to registerSurfaceMesh() . SurfaceMesh :: setAllPermutations ( const std :: array < std :: pair < T , size_t > , 5 >& perms ) Set all of the ordering permutations at once, as described above. The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . If the size of your index space is different from size of the default index space, the second component of each pair must give this new size. Otherwise, the second component of the pair may be set to zero, to infer the size of the index space from the maximum index given. Must be set before any quantites are added. SurfaceMesh * polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices , const std :: array < std :: pair < P , size_t > , 5 >& perms , bool replaceIfPresent = true ) Register a mesh and immediately set all custom permutations, as described above. Equivalent to SurfaceMesh * s = registerSurfaceMesh ( name , vertexPositions , faceIndices , replaceIfPresent ); s -> setAllPermutations ( perms ); Other wise behave like the standard registerSurfaceMesh() . The argument should be a std::array<> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Must be set before any quantites are added.","title":"All at once"},{"location":"structures/surface_mesh/misc_quantities/","text":"Surface Graph Quantity The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes radius the radius the graph is drawn with double getRadius () setRadius ( double val , bool isRelative = true ) yes color the color to draw the graph with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Misc Quantities"},{"location":"structures/surface_mesh/misc_quantities/#surface-graph-quantity","text":"The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph.","title":"Surface Graph Quantity"},{"location":"structures/surface_mesh/misc_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes radius the radius the graph is drawn with double getRadius () setRadius ( double val , bool isRelative = true ) yes color the color to draw the graph with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/parameterization_quantities/","text":"A parameterization is a set of 2D coordinates associated with a mesh, often referred to as \u201cUV coordinates\u201d. This sections details several functions for visualizing such parameterizations. #include \"polyscope/surface_mesh.h\" Example : visualizing an LSCM parameterization via libIGL using namespace Eigen ; using namespace std ; // Fix two points on the boundary VectorXi bnd , b ( 2 , 1 ); igl :: boundary_loop ( meshF , bnd ); if ( bnd . size () == 0 ) { polyscope :: warning ( \"mesh has no boundary, cannot parameterize\" ); return ; } b ( 0 ) = bnd ( 0 ); b ( 1 ) = bnd ( round ( bnd . size () / 2 )); MatrixXd bc ( 2 , 2 ); bc << 0 , 0 , 1 , 0 ; // LSCM parametrization Eigen :: MatrixXd V_uv ; igl :: lscm ( meshV , meshF , b , bc , V_uv ); polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexParameterizationQuantity ( \"LSCM parameterization\" , V_uv ); Adding SurfaceMesh :: addParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the corners of a mesh. coords is the array of 2D UV coordinates at corners. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of corners in the mesh. SurfaceMesh :: addVertexParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh. SurfaceMesh :: addLocalParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. this is similar to addVertexParameterizationQuantity , but has preset settings for style and type which are suitable for local parameterizations about a point. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh. Options Styles Several styles are available for how a parameterization is displayed. The enum class ParamVizStyle has options for how parameterizations are visualized: CHECKER : a two-color checker pattern GRID : a grid with thin lines LOCAL_CHECK : a checkboard over a radial colormap, centered around (0,0) LOCAL_RAD : distance stripes over a radial colormap, centered around (0,0) The function SurfaceParameterizationQuantity::setStyle(ParamVizStyle newStyle) can be used to programmatically change the style. Types The enum class ParamCoordsType has options that control how parameter coordinates are interpreted: UNIT : UV coords are assumed to lie on the [0,1] interval WORLD : UV coords are assumed to be scaled like the world-space positions of the mesh These enums can be passed as an optional third argument when a parameterization is registered. Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes style the visualization style (see above) ParamVizStyle getStyle setStyle ( ParamVizStyle style ) yes checker colors two colors to use for checkerboards std :: pair < glm :: vec3 , glm :: vec3 > getCheckerColors () setCheckerColors ( std :: pair < glm :: vec3 , glm :: vec3 > colors ) yes grid colors two colors to use for line and background of grid std :: pair < glm :: vec3 , glm :: vec3 > getGridColors () setGridColors ( std :: pair < glm :: vec3 , glm :: vec3 > colors ) yes checker size the width of checkers / stripes, always used as a relative value, unless the coord tpe is UNIT double getCheckerSize () setCheckerSize ( double val ) yes color map the color map to use for radial displays std :: string getColorMap () setColorMap ( std :: string newMap ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Parameterization Quantities"},{"location":"structures/surface_mesh/parameterization_quantities/#adding","text":"SurfaceMesh :: addParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the corners of a mesh. coords is the array of 2D UV coordinates at corners. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of corners in the mesh. SurfaceMesh :: addVertexParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh. SurfaceMesh :: addLocalParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. this is similar to addVertexParameterizationQuantity , but has preset settings for style and type which are suitable for local parameterizations about a point. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh.","title":"Adding"},{"location":"structures/surface_mesh/parameterization_quantities/#options","text":"","title":"Options"},{"location":"structures/surface_mesh/parameterization_quantities/#styles","text":"Several styles are available for how a parameterization is displayed. The enum class ParamVizStyle has options for how parameterizations are visualized: CHECKER : a two-color checker pattern GRID : a grid with thin lines LOCAL_CHECK : a checkboard over a radial colormap, centered around (0,0) LOCAL_RAD : distance stripes over a radial colormap, centered around (0,0) The function SurfaceParameterizationQuantity::setStyle(ParamVizStyle newStyle) can be used to programmatically change the style.","title":"Styles"},{"location":"structures/surface_mesh/parameterization_quantities/#types","text":"The enum class ParamCoordsType has options that control how parameter coordinates are interpreted: UNIT : UV coords are assumed to lie on the [0,1] interval WORLD : UV coords are assumed to be scaled like the world-space positions of the mesh These enums can be passed as an optional third argument when a parameterization is registered. Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes style the visualization style (see above) ParamVizStyle getStyle setStyle ( ParamVizStyle style ) yes checker colors two colors to use for checkerboards std :: pair < glm :: vec3 , glm :: vec3 > getCheckerColors () setCheckerColors ( std :: pair < glm :: vec3 , glm :: vec3 > colors ) yes grid colors two colors to use for line and background of grid std :: pair < glm :: vec3 , glm :: vec3 > getGridColors () setGridColors ( std :: pair < glm :: vec3 , glm :: vec3 > colors ) yes checker size the width of checkers / stripes, always used as a relative value, unless the coord tpe is UNIT double getCheckerSize () setCheckerSize ( double val ) yes color map the color map to use for radial displays std :: string getColorMap () setColorMap ( std :: string newMap ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Types"},{"location":"structures/surface_mesh/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the elements of a surface mesh. Example : visualizing cotangent weights at edges with geometry-central #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" polyscope :: init (); // Load mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geom ; std :: tie ( mesh , geom ) = loadMesh ( args :: get ( inputFilename )); geom -> requireVertexPositions (); // Register the geometry-central mesh auto psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // set permutations, // so edge data is meaningful // Build cotan weights for the mesh geom -> requireEdgeCotanWeights (); // Visualize cotan weights psMesh -> addEdgeScalarQuantity ( \"edge cotan weights\" , geom -> edgeCotanWeights ); polyscope :: show (); Add scalars to elements SurfaceMesh :: addVertexScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the vertices of the mesh. values is the array of scalars at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addFaceScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the faces of the mesh. values is the array of scalars at faces. The type should be adaptable to a float scalar array. The length should be the number of faces in the mesh. SurfaceMesh :: addEdgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the edges of the mesh. values is the array of scalars at edges. The type should be adaptable to a float scalar array. The length should be the number of edges in the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. SurfaceMesh :: addHalfedgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the halfedges of the mesh. values is the array of scalars at halfedges. The type should be adaptable to a float scalar array. The length should be the number of halfedges in the mesh. Remember, before passing halfedge-valued data, be sure your indexing convention matches what Polyscope expects. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Scalar Quantities"},{"location":"structures/surface_mesh/scalar_quantities/#add-scalars-to-elements","text":"SurfaceMesh :: addVertexScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the vertices of the mesh. values is the array of scalars at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addFaceScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the faces of the mesh. values is the array of scalars at faces. The type should be adaptable to a float scalar array. The length should be the number of faces in the mesh. SurfaceMesh :: addEdgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the edges of the mesh. values is the array of scalars at edges. The type should be adaptable to a float scalar array. The length should be the number of edges in the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. SurfaceMesh :: addHalfedgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the halfedges of the mesh. values is the array of scalars at halfedges. The type should be adaptable to a float scalar array. The length should be the number of halfedges in the mesh. Remember, before passing halfedge-valued data, be sure your indexing convention matches what Polyscope expects.","title":"Add scalars to elements"},{"location":"structures/surface_mesh/scalar_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/vector_quantities/","text":"Visualize vector-valued data at the elements of a surface mesh. Ambient vectors Ambient vectors are \u201cstandard\u201d vectors, which have X-Y-Z vector coordinates in world space. SurfaceMesh :: addVertexVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addVertexVectorQuantity2D exists with the same signature. See 2D data . SurfaceMesh :: addFaceVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addFaceVectorQuantity2D exists with the same signature. See 2D data . Tangent vectors Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element. Example: visualizing tangent vectors with geometry-central #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" polyscope :: init (); // Load mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Register the mesh with polyscope psMesh = polyscope :: registerSurfaceMesh ( \"mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh )); // Set vertex tangent spaces geometry -> requireVertexTangentBasis (); VertexData < Vector3 > vBasisX ( * mesh ); for ( Vertex v : mesh -> vertices ()) { vBasisX [ v ] = geometry -> vertexTangentBasis [ v ][ 0 ]; } polyscope :: getSurfaceMesh ( \"mesh\" ) -> setVertexTangentBasisX ( vBasisX ); // Make a vector field VertexData < Vector2 > vecField = /* some field */ // Register the field polyscope :: getSurfaceMesh ( \"mesh\" ) -> addVertexIntrinsicVectorQuantity ( \"great vectors\" , vecField ); polyscope :: show (); Specifying the tangent basis Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for mesh element. void SurfaceMesh :: setVertexTangentBasisX ( const T & vectors ) Specify the tangent coordinates at vertices, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each vertex. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. Note: As always for functions that take 3D vector inputs, there is a setVertexTangentBasisX2D with the same signature, which expects 2D vector inputs. See 2D data . void SurfaceMesh :: setFaceTangentBasisX ( const T & vectors ) Specify the tangent coordinates at faces, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each face. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. Note: As always for functions that take 3D vector inputs, there is a setFaceTangentBasisX2D with the same signature, which expects vector 2D inputs. See 2D data . Adding intrinsic tangent vectors In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh :: addVertexIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 2-vector array of float s. The length should be the number of vertices in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh::vertexTangentSpaces . These tangent spaces can be manually specified as described above. SurfaceMesh :: addFaceIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 2-vector array of float s. The length should be the number of faces in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh::facesTangentSpaces . These tangent spaces can be manually specified as described above. One forms One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh :: addOneFormIntrinsicVectorQuantity ( std :: string name , const T & data , const O & orientations ) Add a one-form quantity via a scalar at edges, which will be shown like a vector field. data is the array of scalars at edges. The type should be adaptable to an array of float s. The length should be the number of edges in the mesh. orientations 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. This input is an array of booleans at edges. The type should be adaptable to an array of char s (because std::vector<bool> is broken). The length should be the number of edges in the mesh. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes ribbon enabled draw the ribbon visualization (only available for intrinsic vector fields) bool isRibbonEnabled () setRibbonEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Vector Quantities"},{"location":"structures/surface_mesh/vector_quantities/#ambient-vectors","text":"Ambient vectors are \u201cstandard\u201d vectors, which have X-Y-Z vector coordinates in world space. SurfaceMesh :: addVertexVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addVertexVectorQuantity2D exists with the same signature. See 2D data . SurfaceMesh :: addFaceVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addFaceVectorQuantity2D exists with the same signature. See 2D data .","title":"Ambient vectors"},{"location":"structures/surface_mesh/vector_quantities/#tangent-vectors","text":"Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element. Example: visualizing tangent vectors with geometry-central #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" polyscope :: init (); // Load mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Register the mesh with polyscope psMesh = polyscope :: registerSurfaceMesh ( \"mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh )); // Set vertex tangent spaces geometry -> requireVertexTangentBasis (); VertexData < Vector3 > vBasisX ( * mesh ); for ( Vertex v : mesh -> vertices ()) { vBasisX [ v ] = geometry -> vertexTangentBasis [ v ][ 0 ]; } polyscope :: getSurfaceMesh ( \"mesh\" ) -> setVertexTangentBasisX ( vBasisX ); // Make a vector field VertexData < Vector2 > vecField = /* some field */ // Register the field polyscope :: getSurfaceMesh ( \"mesh\" ) -> addVertexIntrinsicVectorQuantity ( \"great vectors\" , vecField ); polyscope :: show ();","title":"Tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#specifying-the-tangent-basis","text":"Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for mesh element. void SurfaceMesh :: setVertexTangentBasisX ( const T & vectors ) Specify the tangent coordinates at vertices, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each vertex. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. Note: As always for functions that take 3D vector inputs, there is a setVertexTangentBasisX2D with the same signature, which expects 2D vector inputs. See 2D data . void SurfaceMesh :: setFaceTangentBasisX ( const T & vectors ) Specify the tangent coordinates at faces, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each face. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. Note: As always for functions that take 3D vector inputs, there is a setFaceTangentBasisX2D with the same signature, which expects vector 2D inputs. See 2D data .","title":"Specifying the tangent basis"},{"location":"structures/surface_mesh/vector_quantities/#adding-intrinsic-tangent-vectors","text":"In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh :: addVertexIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 2-vector array of float s. The length should be the number of vertices in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh::vertexTangentSpaces . These tangent spaces can be manually specified as described above. SurfaceMesh :: addFaceIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 2-vector array of float s. The length should be the number of faces in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh::facesTangentSpaces . These tangent spaces can be manually specified as described above.","title":"Adding intrinsic tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#one-forms","text":"One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh :: addOneFormIntrinsicVectorQuantity ( std :: string name , const T & data , const O & orientations ) Add a one-form quantity via a scalar at edges, which will be shown like a vector field. data is the array of scalars at edges. The type should be adaptable to an array of float s. The length should be the number of edges in the mesh. orientations 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. This input is an array of booleans at edges. The type should be adaptable to an array of char s (because std::vector<bool> is broken). The length should be the number of edges in the mesh. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects.","title":"One forms"},{"location":"structures/surface_mesh/vector_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes ribbon enabled draw the ribbon visualization (only available for intrinsic vector fields) bool isRibbonEnabled () setRibbonEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/volume_mesh/basics/","text":"Volume Meshes Volumetric meshes, such as tetrahedral ( tet ) and hexahedral ( hex , cube-like) meshes, represent a region of 3D space. Polyscope can display tet and hex meshes, including those which have a mix of hex and tet elements. We\u2019ll use the term cell to refer generically to a tet or hex in a volume mesh. As always, Polyscope can also handle scalar, color, or vector quantities associated with the vertices or cells of the mesh, and you can click on the mesh elements to inspect values. Your browser does not support the video tag. Registering a volume mesh Example: registering a tetrahedral mesh from libIGL #include \"polyscope/polyscope.h\" #include \"polyscope/volume_mesh.h\" #include <igl/readMESH.h> // Initialize Polyscope polyscope :: init (); // Read mesh from file Eigen :: MatrixXd V ; // vertex positions Eigen :: MatrixXi T ; // tetrahedra Eigen :: MatrixXi F ; // faces (we don't use these here) igl :: readMESH ( \"path/to/volume.mesh\" , V , T , F ); // Register the volume mesh with Polyscope polyscope :: registerTetMesh ( \"my mesh\" , V , T ); // Add a scalar quantity size_t nVerts = V . rows (); std :: vector < double > scalarV ( nVerts ); for ( size_t i = 0 ; i < nVerts ; i ++ ) { // use the x-coordinate of vertex position as a test function scalarV [ i ] = V ( i , 0 ); } polyscope :: getVolumeMesh ( \"my mesh\" ) -> addVertexScalarQuantity ( \"scalar Q\" , scalarV ); // Show the GUI polyscope :: show (); Volume meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each cell. There are a few different variants to register meshes with tets, hexes, or a mix of the two. All of these register helpers return a pointer to a polyscope::VolumeMesh object which you can then add quantities to. polyscope :: registerTetMesh ( std :: string name , const V & vertexPositions , const C & tetIndices ) Add a new volume mesh structure to Polyscope, with all tetrahedral elements. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. tetIndices is the 2D array of vertex indices for each tetrahedral cell, with dimension (C,4) where C is the number of tets. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 4>> . All indices should be valid 0-based indices in to the vertex list. polyscope :: registerHexMesh ( std :: string name , const V & vertexPositions , const C & hexIndices ) Add a new volume mesh structure to Polyscope, with all hexahedral (cube-like) elements. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. hexIndices is the 2D array of vertex indices for each hexahedral cell, with dimension (C,8) where C is the number of hexes. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 8>> . All indices should be valid 0-based indices in to the vertex list. polyscope :: registerVolumeMesh ( std :: string name , const V & vertexPositions , const C & hexIndices ) Add a new volume mesh structure to Polyscope, which may have a mix of cell types. This variant takes a rectangular array as input, where all cell rows have 8 entries, but cells with less than 8 vertices are padded with negative values. For instance, a row of the 2D array hexIndices which refers to a tet cell might hold [12, 9, 22, 51, -1, -1, -1, -1] . vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. hexIndices is the 2D array of vertex indices for each hexahedral cell, with dimension (C,8) where C is the number of tet/hexes. For tet elements, the rows of the array should be padded with negative indices, which will be ignored. The type should be adaptable to a nested array of unsigned int ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<int, 8>> . All indices should be valid 0-based indices in to the vertex list. Signed types should be used to support the negative element convention as described above. polyscope :: registerTetHexMesh ( std :: string name , const V & vertexPositions , const Ct & tetIndices , const Ct & hexIndices ) Add a new volume mesh structure to Polyscope. This variant takes a mix of tet and hex elements, where each are given in their own separate list. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. tetIndices is the 2D array of vertex indices for each tetrahedral cell, with dimension (C,4) where C is the number of tets. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 4>> . All indices should be valid 0-based indices in to the vertex list. hexIndices is the 2D array of vertex indices for each hexahedral cell, with dimension (C,8) where C is the number of hexes. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 8>> . All indices should be valid 0-based indices in to the vertex list. For the purposes of element ordering, the cells are presumed to be ordered with all tetrahedral cells coming first, then hexahedral cells. No support for 2D Unlike other structures, 2D volume meshes are not supported; they don\u2019t make much sense (see 2D data ). Updating a mesh The locations of the vertices in a mesh can be updated with the member function updateVertexPositions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). void VolumeMesh :: updateVertexPositions ( const V & newPositions ) Update the vertex positions in a volume mesh structure. newPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of vertices. Slice planes Slice planes are particularly useful for inspecting the internal stucture of a volume mesh, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details. Options Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes color the color of the outside of the volume glm :: vec3 getColor () setColor ( glm :: vec3 val ) yes interior color the color of the inside of the volume glm :: vec3 getInteriorColor () setInteriorColor ( glm :: vec3 val ) yes edge color the color of the edges of the mesh glm :: vec3 getEdgeColor () setEdgeColor ( glm :: vec3 val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges double getEdgeWidth () setEdgeWidth ( double val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Basics"},{"location":"structures/volume_mesh/basics/#volume-meshes","text":"Volumetric meshes, such as tetrahedral ( tet ) and hexahedral ( hex , cube-like) meshes, represent a region of 3D space. Polyscope can display tet and hex meshes, including those which have a mix of hex and tet elements. We\u2019ll use the term cell to refer generically to a tet or hex in a volume mesh. As always, Polyscope can also handle scalar, color, or vector quantities associated with the vertices or cells of the mesh, and you can click on the mesh elements to inspect values. Your browser does not support the video tag.","title":"Volume Meshes"},{"location":"structures/volume_mesh/basics/#registering-a-volume-mesh","text":"Example: registering a tetrahedral mesh from libIGL #include \"polyscope/polyscope.h\" #include \"polyscope/volume_mesh.h\" #include <igl/readMESH.h> // Initialize Polyscope polyscope :: init (); // Read mesh from file Eigen :: MatrixXd V ; // vertex positions Eigen :: MatrixXi T ; // tetrahedra Eigen :: MatrixXi F ; // faces (we don't use these here) igl :: readMESH ( \"path/to/volume.mesh\" , V , T , F ); // Register the volume mesh with Polyscope polyscope :: registerTetMesh ( \"my mesh\" , V , T ); // Add a scalar quantity size_t nVerts = V . rows (); std :: vector < double > scalarV ( nVerts ); for ( size_t i = 0 ; i < nVerts ; i ++ ) { // use the x-coordinate of vertex position as a test function scalarV [ i ] = V ( i , 0 ); } polyscope :: getVolumeMesh ( \"my mesh\" ) -> addVertexScalarQuantity ( \"scalar Q\" , scalarV ); // Show the GUI polyscope :: show (); Volume meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each cell. There are a few different variants to register meshes with tets, hexes, or a mix of the two. All of these register helpers return a pointer to a polyscope::VolumeMesh object which you can then add quantities to. polyscope :: registerTetMesh ( std :: string name , const V & vertexPositions , const C & tetIndices ) Add a new volume mesh structure to Polyscope, with all tetrahedral elements. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. tetIndices is the 2D array of vertex indices for each tetrahedral cell, with dimension (C,4) where C is the number of tets. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 4>> . All indices should be valid 0-based indices in to the vertex list. polyscope :: registerHexMesh ( std :: string name , const V & vertexPositions , const C & hexIndices ) Add a new volume mesh structure to Polyscope, with all hexahedral (cube-like) elements. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. hexIndices is the 2D array of vertex indices for each hexahedral cell, with dimension (C,8) where C is the number of hexes. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 8>> . All indices should be valid 0-based indices in to the vertex list. polyscope :: registerVolumeMesh ( std :: string name , const V & vertexPositions , const C & hexIndices ) Add a new volume mesh structure to Polyscope, which may have a mix of cell types. This variant takes a rectangular array as input, where all cell rows have 8 entries, but cells with less than 8 vertices are padded with negative values. For instance, a row of the 2D array hexIndices which refers to a tet cell might hold [12, 9, 22, 51, -1, -1, -1, -1] . vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. hexIndices is the 2D array of vertex indices for each hexahedral cell, with dimension (C,8) where C is the number of tet/hexes. For tet elements, the rows of the array should be padded with negative indices, which will be ignored. The type should be adaptable to a nested array of unsigned int ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<int, 8>> . All indices should be valid 0-based indices in to the vertex list. Signed types should be used to support the negative element convention as described above. polyscope :: registerTetHexMesh ( std :: string name , const V & vertexPositions , const Ct & tetIndices , const Ct & hexIndices ) Add a new volume mesh structure to Polyscope. This variant takes a mix of tet and hex elements, where each are given in their own separate list. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors; this allows many common types to be used as input, including Eigen::MatrixXd and std::vector<std::array<double, 3>> . The length will be the number of vertices. tetIndices is the 2D array of vertex indices for each tetrahedral cell, with dimension (C,4) where C is the number of tets. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 4>> . All indices should be valid 0-based indices in to the vertex list. hexIndices is the 2D array of vertex indices for each hexahedral cell, with dimension (C,8) where C is the number of hexes. The type should be adaptable to a nested array of size_t ; this allows many common types to be used as input, including Eigen::MatrixXi and std::vector<std::array<size_t, 8>> . All indices should be valid 0-based indices in to the vertex list. For the purposes of element ordering, the cells are presumed to be ordered with all tetrahedral cells coming first, then hexahedral cells. No support for 2D Unlike other structures, 2D volume meshes are not supported; they don\u2019t make much sense (see 2D data ).","title":"Registering a volume mesh"},{"location":"structures/volume_mesh/basics/#updating-a-mesh","text":"The locations of the vertices in a mesh can be updated with the member function updateVertexPositions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). void VolumeMesh :: updateVertexPositions ( const V & newPositions ) Update the vertex positions in a volume mesh structure. newPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of vertices.","title":"Updating a mesh"},{"location":"structures/volume_mesh/basics/#slice-planes","text":"Slice planes are particularly useful for inspecting the internal stucture of a volume mesh, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details.","title":"Slice planes"},{"location":"structures/volume_mesh/basics/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool isEnabled () setEnabled ( bool newVal ) yes transparency transparency alpha for this structure in [0,1] double getTransparency () setTransparency ( double val ) yes color the color of the outside of the volume glm :: vec3 getColor () setColor ( glm :: vec3 val ) yes interior color the color of the inside of the volume glm :: vec3 getInteriorColor () setInteriorColor ( glm :: vec3 val ) yes edge color the color of the edges of the mesh glm :: vec3 getEdgeColor () setEdgeColor ( glm :: vec3 val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges double getEdgeWidth () setEdgeWidth ( double val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled()/setTransparency() return generic setter, so chain them last)","title":"Options"},{"location":"structures/volume_mesh/color_quantities/","text":"Visualize color rgb-valued data at the elements of a volume mesh. Example : showing a color value at cells (here randomly generated data) /* ... initialization, create mesh ... */ // Register the volume mesh with Polyscope polyscope :: registerTetMesh ( \"my mesh\" , verts , tets ); // Add a color quantity size_t nCells = tets . rows (); std :: vector < std :: array < double , 3 >> randColor ( nCells ); for ( size_t i = 0 ; i < nCells ; i ++ ) { // generate random colors randColor [ i ] = {{ polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit ()}}; } polyscope :: getVolumeMesh ( \"my mesh\" ) -> addCellColorQuantity ( \"random color\" , randColor ); // Show the GUI polyscope :: show (); Add colors to elements VolumeMesh :: addVertexColorQuantity ( std :: string name , const T & data ) Add a color quantity defined at the vertices of the mesh. data is the array of colors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. RGB values are interpreted in the range [0,1] . VolumeMesh :: addCellColorQuantity ( std :: string name , const T & data ) Add a color quantity defined at the faces of the mesh. data is the array of colors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of cells (tets, hexes, etc) in the mesh. RGB values are interpreted in the range [0,1] . Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Color Quantities"},{"location":"structures/volume_mesh/color_quantities/#add-colors-to-elements","text":"VolumeMesh :: addVertexColorQuantity ( std :: string name , const T & data ) Add a color quantity defined at the vertices of the mesh. data is the array of colors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. RGB values are interpreted in the range [0,1] . VolumeMesh :: addCellColorQuantity ( std :: string name , const T & data ) Add a color quantity defined at the faces of the mesh. data is the array of colors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of cells (tets, hexes, etc) in the mesh. RGB values are interpreted in the range [0,1] .","title":"Add colors to elements"},{"location":"structures/volume_mesh/color_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/volume_mesh/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the elements of a volume mesh. Example : showing a scalar on vertices (here just one of the spatial coordinate functions) /* ... initialization, create mesh ... */ // Register the volume mesh with Polyscope polyscope :: registerTetMesh ( \"my mesh\" , verts , tets ); // Add a scalar quantity size_t nVerts = verts . rows (); std :: vector < double > scalarV ( nVerts ); for ( size_t i = 0 ; i < nVerts ; i ++ ) { // use the x-coordinate of vertex position as a test function scalarV [ i ] = V ( i , 0 ); } auto scalarQ = polyscope :: getVolumeMesh ( \"my mesh\" ) -> addVertexScalarQuantity ( \"scalar Q\" , scalarV ); // Set some options scalarQ -> setEnabled ( true ); // initially enabled scalarQ -> setMapRange ({ -1. , 1. }); // colormap from [-1,1] scalarQ -> setColorMap ( \"blues\" ); // use a blue colormap // Show the GUI polyscope :: show (); Add scalars to elements VolumeMesh :: addVertexScalarQuantity ( std :: string name , const T & data , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the vertices of the mesh. data is the array of scalars at vertices. The type should be adaptable to a float scalar array; this includes may common types like std::vector<float> and Eigen::VectorXd . The length should be the number of vertices in the mesh. VolumeMesh :: addCellScalarQuantity ( std :: string name , const T & data , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the cells of the mesh. data is the array of scalars, with one value per cell. The type should be adaptable to a float scalar array; this includes may common types like std::vector<float> and Eigen::VectorXd . The length should be the number of cell in the mesh. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Scalar Quantities"},{"location":"structures/volume_mesh/scalar_quantities/#add-scalars-to-elements","text":"VolumeMesh :: addVertexScalarQuantity ( std :: string name , const T & data , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the vertices of the mesh. data is the array of scalars at vertices. The type should be adaptable to a float scalar array; this includes may common types like std::vector<float> and Eigen::VectorXd . The length should be the number of vertices in the mesh. VolumeMesh :: addCellScalarQuantity ( std :: string name , const T & data , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the cells of the mesh. data is the array of scalars, with one value per cell. The type should be adaptable to a float scalar array; this includes may common types like std::vector<float> and Eigen::VectorXd . The length should be the number of cell in the mesh.","title":"Add scalars to elements"},{"location":"structures/volume_mesh/scalar_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes color map the color map to use std :: string getColorMap () setColorMap ( std :: string newMap ) yes map range the lower and upper limits used when mapping the data in to the color map std :: pair < double , double > getMapRange () setMapRange ( std :: pair < double , double > ) and resetMapRange () no (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/volume_mesh/vector_quantities/","text":"Visualize vector-valued data at the elements of a volume mesh. Example : showing vectors on vertices (here random vectors) /* ... initialization, create mesh ... */ // Register the volume mesh with Polyscope polyscope :: registerTetMesh ( \"my mesh\" , verts , tets ); // Add a vector quantity size_t nVerts = V . rows (); std :: vector < std :: array < double , 3 >> randVec ( nVerts ); for ( size_t i = 0 ; i < nVerts ; i ++ ) { // use random vectors as test data randVec [ i ] = {{ polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }}; } auto vectorQ = polyscope :: getVolumeMesh ( \"my mesh\" ) -> addVertexVectorQuantity ( \"random vec\" , randVec ); // Set some options vectorQ -> setEnabled ( true ); // initially enabled vectorQ -> setVectorLengthScale ( 0.05 ); // make the vectors bigger // Show the GUI polyscope :: show (); Add vectors to elements VolumeMesh :: addVertexVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. VolumeMesh :: addCellVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity defined at the cells of the mesh. vectors is the array of vectors at cells. The type should be adaptable to a 3-vector array of float s. The length should be the number of cells in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Vector Quantities"},{"location":"structures/volume_mesh/vector_quantities/#add-vectors-to-elements","text":"VolumeMesh :: addVertexVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. VolumeMesh :: addCellVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity defined at the cells of the mesh. vectors is the array of vectors at cells. The type should be adaptable to a 3-vector array of float s. The length should be the number of cells in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType::AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse.","title":"Add vectors to elements"},{"location":"structures/volume_mesh/vector_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes vector radius the radius vectors are drawn with double getVectorRadius () setVectorRadius ( double val , bool isRelative = true ) yes vector length vectors will be scaled so the longest is this long. ignored if VectorType::Ambient double getVectorLengthScale () setVectorLengthScale ( double val , bool isRelative = true ) yes vector color the color to draw the vectors with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes material what material to use std :: string getMaterial () setMaterial(std::string name) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"}]}