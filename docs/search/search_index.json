{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polyscope is a C++ viewer and user interface for the rapid prototyping and debugging of geometric algorithms in 3D geometry processing, scientific computing, and computer graphics/vision. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code. Polyscope uses a paradigm of structures and quantities . A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field. When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling the display of various data, colormapping data and editing maps, providing \u201cpicking\u201d support to click in the scene and display numerical quantities, and generating histograms of scalar values. A simple workflow for visualizing data in Polyscope looks like: #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" // Initialize polyscope polyscope :: init (); // Register a surface mesh structure polyscope :: registerSurfaceMesh ( \"my mesh\" , mesh . vertices , mesh . faces ); // Add a scalar and a vector function to the mesh polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addVertexScalarQuantity ( \"my_scalar\" , scalarQuantity ); polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addFaceVectorQuantity ( \"my_vector\" , vectorQuantity ); // Show the gui polyscope :: show (); Polyscope is designed to be easy to integrate with existing programs. It is simple to build, and fewer than 10 lines of code should be sufficient to start visualizing. Thanks to some template magic , Polyscope can probably directly read from the data types you\u2019re already using! Author: Nicholas Sharp If Polyscope contributes to an academic publication, cite it as: @misc { polyscope , title = {Polyscope} , author = {Nicholas Sharp and the Polyscope contributors} , note = {www.polyscope.run} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Home"},{"location":"data_adaptors/","text":"Polyscope is designed as a lightweight general-purpose 3D visualization library. But there\u2019s a problem, because different codebases uses different C++ types to store their data: is an array of scalars a std :: vector < double > or an Eigen :: VectorXf or some other internal type? Codebases for 3D geometry are particularly guilty of this: there are probably several hundred distinct 3D vector x-y-z classes floating around github. Rather than forcing the user to manually convert their data types to some Polyscope types, we implement a series of templated adaptor functions, which attempt to read from the user types via a common set of strategies. These adaptors are applied to the inputs to nearly all Polyscope functions, allowing them to automatically accept user-defined types as inputs. You don\u2019t need to do anything special to use these adaptors! They are applied internally to the arguments of nearly every Polyscope function, like the vertices and faces arguments of registerSurfaceMesh ( \"name\" , vertices , faces ) . This section outlines how the adaptors will try to read from your data, and how to extend them for unusual datatypes which are not automatically handled. These functions live in # include \" polyscope/standardize_data_array.h \" . It\u2019s fairly well-commented\u2014 check it out to see how all this works under the hood! Fixed size vector types These are 2D or 3D vectors whose size are known at compile time, commonly used to represent things like positions (3D), or UV coordinates (2D). Examples of 3D vector types that Polyscope can read from out of the box include glm :: vec3 , Eigen :: Vector3d , and std :: array < double , 3 > (likewise for 2D). Hierarchy Polyscope will attempt to access an input 2D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec [ 0 ] and vec [ 1 ] ) members x , y (like vec . x and vec . y ) members u , v (like vec . u and vec . v ) members functions real () / imag () (like vec . real () and vec . imag () ) Polyscope will attempt to access an input 3D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec [ 0 ] , vec [ 1 ] , and vec [ 2 ] ) members x , y , z (like vec . x , vec . y , and vec . z ) using Eigen fixed-size vectorizable types If you are using fixed-sized, vectorizable Eigen types like Eigen :: Vector2f and Eigen :: Vector4f as your 2D/3D vector types, there are special, tricky alignment rules imposed by Eigen which must be respected. For instance, a std :: vector < Eigen :: Vector2f > is not a valid type; using it will lead to tricky-to-debug segfaults. Polyscope makes a best effort to avoid problems when the caller\u2019s fixed vector type has alignment constraints, but beware\u2014these are dangerous waters. See Eigen\u2019s documentation here and here for more information. extending vector access Extending Suppose you have an in-house vector type which cannot be accessed by any strategy in the hierarchy above. You can define a custom function that accesses the elements of your type: YOUR_TYPES_SCALAR adaptorF_custom_accessVector2Value ( const YOUR_TYPE & v , unsigned int ind ); The array adaptors will pick up this function and use it to access your type. Example: // A vector2 type with unusual access struct UserVector2Custom { double foo ; double bar ; }; // Define an accessor to teach Polyscope to read from your type double adaptorF_custom_accessVector2Value ( const UserVector2Custom & v , unsigned int ind ) { if ( ind == 0 ) return v . foo ; if ( ind == 1 ) return v . bar ; throw std :: logic_error ( \"bad access\" ); return - 1. ; } // Now Polyscope functions can take this type as input! The same principle applies for 3D vectors, where the relevant function is named YOUR_TYPES_SCALAR adaptorF_custom_accessVector3Value ( const YOUR_TYPE & v , unsigned int ind ); Array size The three array adaptor variants below (scalar array, vector array, and nested array) all assume the ability to read the size of an input array. Hierarchy Polyscope will attempt to read the length of an input array in the following ways, in decreasing order of precedence: any user-defined function (see below) a .rows () member function (like inputData . rows () ) a .size () member function (like inputData . size () ) extending array size Extending Suppose you have an in-house array type whose length cannot be read by any strategy in the hierarchy above. You can define a custom function that reads the length like: size_t adaptorF_custom_size ( const YOUR_ARRAY_TYPE & c ); The array adaptors will pick up this function and use it to access your type. Example: // Array with custom length function called \"bigness()\" struct UserArray { std :: vector < double > myData ; size_t bigness () const { return myData . size (); } }; // Size function for custom array size_t adaptorF_custom_size ( const UserArray & c ) { return c . bigness (); } Scalar arrays A scalar array is a long list of values, like a float at each point in a point cloud, or an int at each vertex of a mesh. We will use the type S to refer to the inner scalar type of an array, like float in std :: vector < float > . Examples of scalar arrays that Polyscope can read from out of the box include std :: vector < float > , Eigen :: VectorXd , and std :: list < int > . Hierarchy Polyscope will attempt to access an input scalar array in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed index access (like array [ i ] ) parenthesis index access (like array ( i ) ) for-each iteration (like array . begin () , array . end () ) extending scalar array access Extending Suppose you have an in-house array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std :: vector < S > like std :: vector < YOUR_SCALAR_TYPE > adaptorF_custom_convertToStdVector ( const YOUR_ARRAY_TYPE & c ) { The array adaptors will pick up this function and use it to access your type. Example: // User array with unusual access struct UserArrayFuncAccess { std :: vector < double > myData ; size_t size () const { return myData . size (); } }; std :: vector < double > adaptorF_custom_convertToStdVector ( const UserArrayFuncAccess & c ) { std :: vector < double > out ; for ( auto x : c . myData ) { out . push_back ( x ); } return out ; } Arrays of vectors These are arrays of values where each element of the array is itself a fixed-size vector type, like the 3D position of each point in a point cloud, or a list of edges in a graph. Note that these arrays must have an inner dimension which is fixed and known at compile time. Examples of vector arrays that Polyscope can read from out of the box include std :: vector < glm :: vec3 > , Eigen :: Matrx < N , 3 > , and std :: list < std :: array < int , 2 >> . Hierarchy Polyscope will attempt to access an input array of vectors in the following ways, in order of decreasing precedence: any user-defined function (see below) dense parenthesis access (like array ( i , j ) ) double bracket access (like array [ i ][ j ] ) outer type bracket-accessible, inner type anything convertible to Vector2/3 (like array [ i ] . x ) outer type iterable, inner type anything convertible to Vector2/3 (like for ( auto vec : array ) and vec . u ). outer type iterable, inner type bracket-accessible (like for ( auto vec : array ) and vec [ 7 ] ) Notice that two these options make use of the fixed-sized vector adaptors . Once Polyscope can read the elements of SOME_VEC3_TYPE , it can also read from std :: vector < SOME_VEC3_TYPE > , etc. The sizes of the inner vector type are generally not checked by Polyscope, so be sure you\u2019re passing in something with the right dimensions! If a function expects an array of 3D vectors, don\u2019t give it an array of 2D vectors. extending array-of-vectors access Extending Suppose you have an in-house array-of-vectors type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std :: vector < S > like std :: vector < std :: array < SCALAR_T , N >> adaptorF_custom_convertArrayOfVectorToStdVector ( const YOUR_ARRAY_TYPE & c ) The array adaptors will pick up this function and use it to access your type. Really, the return type of this method can anything that supports .size () and bracket access; std :: vector < std :: vector <>> would also work. The size of the inner vector is not checked, so be sure it\u2019s right! Example: // An array of vectors with an unusual access scheme struct UserArrayVectorCustom { std :: list < SOME_TYPE > vals ; size_t size () const { return vals . size (); } }; // Define a custom access function std :: vector < std :: array < double , 3 >> adaptorF_custom_convertArrayOfVectorToStdVector ( const UserArrayVectorCustom & inputData ) { std :: vector < std :: array < double , 3 >> out ; for ( auto v : inputData . vals ) { out . push_back ({ v . x (), v . y (), v . z ()}); } return out ; } Nested arrays These are arrays-of-arrays, like the list of vertex indices for each face in a polygon mesh. Unlike the arrays-of-vectors above, the dimensions of the inner arrays need not be known at compile time, and can vary (though arrays with fixed-sized inner dimension are also valid input). Examples of vector arrays that Polyscope can read from out of the box include std :: vector < std :: vector < int >> , Eigen :: Matrix < double , N , 3 > , and std :: vector < std :: list < size_t >> . Hierarchy Polyscope will attempt to access a nested array in the following ways, in order of decreasing precedence: any user defined function dense callable (parenthesis) access on a type that supports array . rows () and array . cols () (like array ( i , j ) ). outer type bracket-accessible, inner type anything that can be accessed as a scalar array (like array [ i ][ j ] ) outer type parenthesis-accessible, inner type anything that can be accessed as a scalar array (like array ( j ) [ i ] ) outer type iterable, inner type anything that can be accessed as a scalar array (like for ( auto inner : array ) and inner [ 7 ] ). Notice that several of these options make use of the scalar array adaptors . Once Polyscope can read from YOUR_ARRAY < S > , it can also read from std :: vector < YOUR_ARRAY < S >> , etc. extending nested array access Extending Suppose you have an in-house nested array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std :: vector < std :: vector < S >> like std :: vector < std :: vector < S >> adaptorF_custom_convertNestedArrayToStdVector ( const YOUR_NESTED_ARRAY & inputData ) { The array adaptors will pick up this function and use it to access your type. Example: // A nested list type with unusual access struct UserNestedListCustom { std :: list < std :: vector < int >> vals ; size_t size () const { return vals . size (); } }; std :: vector < std :: vector < int >> adaptorF_custom_convertNestedArrayToStdVector ( const UserNestedListCustom & inputData ) { std :: vector < std :: vector < int >> out ; for ( auto v : inputData . vals ) { std :: vector < int > inner ; for ( auto x : v ) { inner . push_back ( x ); } out . push_back ( inner ); } return out ; } Debugging One downside to our \u201cclever\u201d use of templates is that compiler error messages can be borderline incomprehensible. Generally, the best debugging strategy is to carefully read the documentation and ensure you are passing in data that makes sense. In most cases, the problem is something simple, like passing a 3D vector where a 2D vector is needed, or mixing up the order of arguments. However, if you are deep in the weeds trying to debug why your type isn\u2019t matching against the template hierarchy (or why a custom function isn\u2019t being used), consider adding the define #define POLYSCOPE_NO_STANDARDIZE_FALLTHROUGH anywhere before the Polyscope includes. This will cause most compilers to print the long scary list of all template substitutions which were considered and rejected, which you can slowly parse to aid you on your quest.","title":"Data Adaptors"},{"location":"data_adaptors/#fixed-size-vector-types","text":"These are 2D or 3D vectors whose size are known at compile time, commonly used to represent things like positions (3D), or UV coordinates (2D). Examples of 3D vector types that Polyscope can read from out of the box include glm :: vec3 , Eigen :: Vector3d , and std :: array < double , 3 > (likewise for 2D).","title":"Fixed size vector types"},{"location":"data_adaptors/#hierarchy","text":"Polyscope will attempt to access an input 2D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec [ 0 ] and vec [ 1 ] ) members x , y (like vec . x and vec . y ) members u , v (like vec . u and vec . v ) members functions real () / imag () (like vec . real () and vec . imag () ) Polyscope will attempt to access an input 3D vector in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed indices (like vec [ 0 ] , vec [ 1 ] , and vec [ 2 ] ) members x , y , z (like vec . x , vec . y , and vec . z ) using Eigen fixed-size vectorizable types If you are using fixed-sized, vectorizable Eigen types like Eigen :: Vector2f and Eigen :: Vector4f as your 2D/3D vector types, there are special, tricky alignment rules imposed by Eigen which must be respected. For instance, a std :: vector < Eigen :: Vector2f > is not a valid type; using it will lead to tricky-to-debug segfaults. Polyscope makes a best effort to avoid problems when the caller\u2019s fixed vector type has alignment constraints, but beware\u2014these are dangerous waters. See Eigen\u2019s documentation here and here for more information. extending vector access","title":"Hierarchy"},{"location":"data_adaptors/#extending","text":"Suppose you have an in-house vector type which cannot be accessed by any strategy in the hierarchy above. You can define a custom function that accesses the elements of your type: YOUR_TYPES_SCALAR adaptorF_custom_accessVector2Value ( const YOUR_TYPE & v , unsigned int ind ); The array adaptors will pick up this function and use it to access your type. Example: // A vector2 type with unusual access struct UserVector2Custom { double foo ; double bar ; }; // Define an accessor to teach Polyscope to read from your type double adaptorF_custom_accessVector2Value ( const UserVector2Custom & v , unsigned int ind ) { if ( ind == 0 ) return v . foo ; if ( ind == 1 ) return v . bar ; throw std :: logic_error ( \"bad access\" ); return - 1. ; } // Now Polyscope functions can take this type as input! The same principle applies for 3D vectors, where the relevant function is named YOUR_TYPES_SCALAR adaptorF_custom_accessVector3Value ( const YOUR_TYPE & v , unsigned int ind );","title":"Extending"},{"location":"data_adaptors/#array-size","text":"The three array adaptor variants below (scalar array, vector array, and nested array) all assume the ability to read the size of an input array.","title":"Array size"},{"location":"data_adaptors/#hierarchy_1","text":"Polyscope will attempt to read the length of an input array in the following ways, in decreasing order of precedence: any user-defined function (see below) a .rows () member function (like inputData . rows () ) a .size () member function (like inputData . size () ) extending array size","title":"Hierarchy"},{"location":"data_adaptors/#extending_1","text":"Suppose you have an in-house array type whose length cannot be read by any strategy in the hierarchy above. You can define a custom function that reads the length like: size_t adaptorF_custom_size ( const YOUR_ARRAY_TYPE & c ); The array adaptors will pick up this function and use it to access your type. Example: // Array with custom length function called \"bigness()\" struct UserArray { std :: vector < double > myData ; size_t bigness () const { return myData . size (); } }; // Size function for custom array size_t adaptorF_custom_size ( const UserArray & c ) { return c . bigness (); }","title":"Extending"},{"location":"data_adaptors/#scalar-arrays","text":"A scalar array is a long list of values, like a float at each point in a point cloud, or an int at each vertex of a mesh. We will use the type S to refer to the inner scalar type of an array, like float in std :: vector < float > . Examples of scalar arrays that Polyscope can read from out of the box include std :: vector < float > , Eigen :: VectorXd , and std :: list < int > .","title":"Scalar arrays"},{"location":"data_adaptors/#hierarchy_2","text":"Polyscope will attempt to access an input scalar array in the following ways, in order of decreasing precedence: any user-defined function (see below) bracketed index access (like array [ i ] ) parenthesis index access (like array ( i ) ) for-each iteration (like array . begin () , array . end () ) extending scalar array access","title":"Hierarchy"},{"location":"data_adaptors/#extending_2","text":"Suppose you have an in-house array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std :: vector < S > like std :: vector < YOUR_SCALAR_TYPE > adaptorF_custom_convertToStdVector ( const YOUR_ARRAY_TYPE & c ) { The array adaptors will pick up this function and use it to access your type. Example: // User array with unusual access struct UserArrayFuncAccess { std :: vector < double > myData ; size_t size () const { return myData . size (); } }; std :: vector < double > adaptorF_custom_convertToStdVector ( const UserArrayFuncAccess & c ) { std :: vector < double > out ; for ( auto x : c . myData ) { out . push_back ( x ); } return out ; }","title":"Extending"},{"location":"data_adaptors/#arrays-of-vectors","text":"These are arrays of values where each element of the array is itself a fixed-size vector type, like the 3D position of each point in a point cloud, or a list of edges in a graph. Note that these arrays must have an inner dimension which is fixed and known at compile time. Examples of vector arrays that Polyscope can read from out of the box include std :: vector < glm :: vec3 > , Eigen :: Matrx < N , 3 > , and std :: list < std :: array < int , 2 >> .","title":"Arrays of vectors"},{"location":"data_adaptors/#hierarchy_3","text":"Polyscope will attempt to access an input array of vectors in the following ways, in order of decreasing precedence: any user-defined function (see below) dense parenthesis access (like array ( i , j ) ) double bracket access (like array [ i ][ j ] ) outer type bracket-accessible, inner type anything convertible to Vector2/3 (like array [ i ] . x ) outer type iterable, inner type anything convertible to Vector2/3 (like for ( auto vec : array ) and vec . u ). outer type iterable, inner type bracket-accessible (like for ( auto vec : array ) and vec [ 7 ] ) Notice that two these options make use of the fixed-sized vector adaptors . Once Polyscope can read the elements of SOME_VEC3_TYPE , it can also read from std :: vector < SOME_VEC3_TYPE > , etc. The sizes of the inner vector type are generally not checked by Polyscope, so be sure you\u2019re passing in something with the right dimensions! If a function expects an array of 3D vectors, don\u2019t give it an array of 2D vectors. extending array-of-vectors access","title":"Hierarchy"},{"location":"data_adaptors/#extending_3","text":"Suppose you have an in-house array-of-vectors type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std :: vector < S > like std :: vector < std :: array < SCALAR_T , N >> adaptorF_custom_convertArrayOfVectorToStdVector ( const YOUR_ARRAY_TYPE & c ) The array adaptors will pick up this function and use it to access your type. Really, the return type of this method can anything that supports .size () and bracket access; std :: vector < std :: vector <>> would also work. The size of the inner vector is not checked, so be sure it\u2019s right! Example: // An array of vectors with an unusual access scheme struct UserArrayVectorCustom { std :: list < SOME_TYPE > vals ; size_t size () const { return vals . size (); } }; // Define a custom access function std :: vector < std :: array < double , 3 >> adaptorF_custom_convertArrayOfVectorToStdVector ( const UserArrayVectorCustom & inputData ) { std :: vector < std :: array < double , 3 >> out ; for ( auto v : inputData . vals ) { out . push_back ({ v . x (), v . y (), v . z ()}); } return out ; }","title":"Extending"},{"location":"data_adaptors/#nested-arrays","text":"These are arrays-of-arrays, like the list of vertex indices for each face in a polygon mesh. Unlike the arrays-of-vectors above, the dimensions of the inner arrays need not be known at compile time, and can vary (though arrays with fixed-sized inner dimension are also valid input). Examples of vector arrays that Polyscope can read from out of the box include std :: vector < std :: vector < int >> , Eigen :: Matrix < double , N , 3 > , and std :: vector < std :: list < size_t >> .","title":"Nested arrays"},{"location":"data_adaptors/#hierarchy_4","text":"Polyscope will attempt to access a nested array in the following ways, in order of decreasing precedence: any user defined function dense callable (parenthesis) access on a type that supports array . rows () and array . cols () (like array ( i , j ) ). outer type bracket-accessible, inner type anything that can be accessed as a scalar array (like array [ i ][ j ] ) outer type parenthesis-accessible, inner type anything that can be accessed as a scalar array (like array ( j ) [ i ] ) outer type iterable, inner type anything that can be accessed as a scalar array (like for ( auto inner : array ) and inner [ 7 ] ). Notice that several of these options make use of the scalar array adaptors . Once Polyscope can read from YOUR_ARRAY < S > , it can also read from std :: vector < YOUR_ARRAY < S >> , etc. extending nested array access","title":"Hierarchy"},{"location":"data_adaptors/#extending_4","text":"Suppose you have an in-house nested array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a std :: vector < std :: vector < S >> like std :: vector < std :: vector < S >> adaptorF_custom_convertNestedArrayToStdVector ( const YOUR_NESTED_ARRAY & inputData ) { The array adaptors will pick up this function and use it to access your type. Example: // A nested list type with unusual access struct UserNestedListCustom { std :: list < std :: vector < int >> vals ; size_t size () const { return vals . size (); } }; std :: vector < std :: vector < int >> adaptorF_custom_convertNestedArrayToStdVector ( const UserNestedListCustom & inputData ) { std :: vector < std :: vector < int >> out ; for ( auto v : inputData . vals ) { std :: vector < int > inner ; for ( auto x : v ) { inner . push_back ( x ); } out . push_back ( inner ); } return out ; }","title":"Extending"},{"location":"data_adaptors/#debugging","text":"One downside to our \u201cclever\u201d use of templates is that compiler error messages can be borderline incomprehensible. Generally, the best debugging strategy is to carefully read the documentation and ensure you are passing in data that makes sense. In most cases, the problem is something simple, like passing a 3D vector where a 2D vector is needed, or mixing up the order of arguments. However, if you are deep in the weeds trying to debug why your type isn\u2019t matching against the template hierarchy (or why a custom function isn\u2019t being used), consider adding the define #define POLYSCOPE_NO_STANDARDIZE_FALLTHROUGH anywhere before the Polyscope includes. This will cause most compilers to print the long scary list of all template substitutions which were considered and rejected, which you can slowly parse to aid you on your quest.","title":"Debugging"},{"location":"about/bindings/","text":"Python bindings Warning Python bindings are in the works! Check back soon.","title":"Bindings"},{"location":"about/bindings/#python-bindings","text":"Warning Python bindings are in the works! Check back soon.","title":"Python bindings"},{"location":"about/contributing/","text":"Polyscope is an open-source project, and you are encouraged to contribute! A few high-level guidelines: All contributions must be released under Polyscope\u2019s MIT license. Significant new features need to be documented! This documentation lives in polyscope-docs . You can and should submit a request there at the same time as adding code to Polyscope. The documentation uses markdown. Modifying the docs amounts to editing a source file and rebuilding the site source. The the nodes there in README . md . To add a new page to the documentation, edit mkdocs . yml . If adding a new structure or quantity, be sure to make use of the data adaptors for all user inputs. See point_cloud . h for an example. Due to the challenges of testing GUI code, Polyscope doesn\u2019t have many unit tests. However, the data adaptors are unit-tested. If you modify them in any way, be sure to update and run the tests in / test / . Add a blurb to the release notes ! We\u2019ll expand these guidelines as Polyscope grows.","title":"Contributing"},{"location":"about/contributors/","text":"This page lists people who have contributed something to Polyscope, in no particular order. Thank you so much for you work! If you would like to be listed on this page, don\u2019t hesitate to ask. Nicholas Sharp Keenan Crane Yousuf Soliman Rohan Sawhney Chris Yu Mark Gillespie Connor Lin","title":"Contributors"},{"location":"about/license/","text":"Polyscope is released under an MIT license , and all of its dependencies are under similar permissive licenses (MIT, zlib, or public domain). The purpose of Polyscope is to serve the scientific and engineering community. Writing geomtric algorithms is hard , but maybe if visualization is simple we can make research and development a little bit easier. Please join us in this goal by pushing contributions back upstream to the repository, so everyone can benefit from your improvements. Polyscope is created and maintained by academics: citations let us know our work is having impact! Please cite Polyscope or otherwise give a shout-out if and when it contributes to published works.","title":"License"},{"location":"about/release_notes/","text":"Rolling Updates As of July 2019, Polyscope is a recently-released library, we\u2019ll be frequently pushing updates and fixes directly to master as they come in. Once things settle down, hopefully within the next 6 months, we will switch to periodic versioned releases. Release notes August 11, 2019 dd4b36f : Add curve network quantity. July 20, 2019 afe7c5e : Add helpers for 2D visualization. Move templates on structure constructors for consistency. July 18, 2019 8514792 : Completely-rewritten Polyscope version 2.0 released. This new version is decoupled from any particular geometry codebase, and is designed to be easy to integrate with existing projects.","title":"Release notes"},{"location":"about/release_notes/#release-notes","text":"August 11, 2019 dd4b36f : Add curve network quantity. July 20, 2019 afe7c5e : Add helpers for 2D visualization. Move templates on structure constructors for consistency. July 18, 2019 8514792 : Completely-rewritten Polyscope version 2.0 released. This new version is decoupled from any particular geometry codebase, and is designed to be easy to integrate with existing projects.","title":"Release notes"},{"location":"basics/camera_controls/","text":"","title":"Camera Controls"},{"location":"basics/initializing/","text":"Initializing Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: #include \"polyscope/polyscope.h\" // Initialize polyscope, creating openGL context and constructing a window. // Should be called exactly once. polyscope :: init (); /* * build visualizations, here or in distant code * */ // Pass control flow to polyscope, displaying the interactive window. // Function will return when user closes the window. polyscope :: show (); Functions #include \"polyscope/polyscope.h\" init() init() Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show() show() Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window.","title":"Initializing"},{"location":"basics/initializing/#initializing","text":"Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: #include \"polyscope/polyscope.h\" // Initialize polyscope, creating openGL context and constructing a window. // Should be called exactly once. polyscope :: init (); /* * build visualizations, here or in distant code * */ // Pass control flow to polyscope, displaying the interactive window. // Function will return when user closes the window. polyscope :: show ();","title":"Initializing"},{"location":"basics/initializing/#functions","text":"#include \"polyscope/polyscope.h\" init()","title":"Functions"},{"location":"basics/initializing/#init","text":"Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show()","title":"init()"},{"location":"basics/initializing/#show","text":"Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window.","title":"show()"},{"location":"basics/program_options/","text":"These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling polyscope :: init , but they may set be anywhere. #include \"polyscope/polyscope.h\" // a few options polyscope :: options :: programName = \"important app\" ; polyscope :: options :: verbosity = 0 ; polyscope :: options :: usePrefsFile = false ; // initialize polyscope :: init (); Options std :: string options :: programName program name A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: polyscope :: options :: programName = \"important app\" ; int options :: verbosity verbosity How much useful info should polyscope print to std :: cout ? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: polyscope :: options :: verbosity = 1 ; std :: string options :: printPrefix print prefix A string used as a prefix for all messages printed to the terminal by polyscope. Default: [ polyscope ] . Example: polyscope :: options :: printPrefix = \"[MYAPP] \" ; // prints now look like \"[MYAPP] loaded openGL\" bool options :: errorsThrowExceptions errors throw execptions If true, errors in polyscope throw execptions. If false, a polyscope :: error is shown in the UI, but processing attempts to continue. Default: false . int options :: maxFPS max fps The main loop will not run at more than maxFPS iterations per second. - 1 disables, running the loop as fast as possible. Default: 60 . bool options :: usePrefsFile use prefs file Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If false , if will be neither written nor read. Default: true . bool options :: alwaysRedraw always redraw Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is true , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: false . bool options :: openImGuiWindowForUserCallback open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui :: Button ( \" do stuff \" ) . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"Program Options"},{"location":"basics/program_options/#options","text":"std :: string options :: programName","title":"Options"},{"location":"basics/program_options/#program-name","text":"A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: polyscope :: options :: programName = \"important app\" ; int options :: verbosity","title":"program name"},{"location":"basics/program_options/#verbosity","text":"How much useful info should polyscope print to std :: cout ? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: polyscope :: options :: verbosity = 1 ; std :: string options :: printPrefix","title":"verbosity"},{"location":"basics/program_options/#print-prefix","text":"A string used as a prefix for all messages printed to the terminal by polyscope. Default: [ polyscope ] . Example: polyscope :: options :: printPrefix = \"[MYAPP] \" ; // prints now look like \"[MYAPP] loaded openGL\" bool options :: errorsThrowExceptions","title":"print prefix"},{"location":"basics/program_options/#errors-throw-execptions","text":"If true, errors in polyscope throw execptions. If false, a polyscope :: error is shown in the UI, but processing attempts to continue. Default: false . int options :: maxFPS","title":"errors throw execptions"},{"location":"basics/program_options/#max-fps","text":"The main loop will not run at more than maxFPS iterations per second. - 1 disables, running the loop as fast as possible. Default: 60 . bool options :: usePrefsFile","title":"max fps"},{"location":"basics/program_options/#use-prefs-file","text":"Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If false , if will be neither written nor read. Default: true . bool options :: alwaysRedraw","title":"use prefs file"},{"location":"basics/program_options/#always-redraw","text":"Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is true , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: false . bool options :: openImGuiWindowForUserCallback","title":"always redraw"},{"location":"basics/program_options/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui :: Button ( \" do stuff \" ) . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"open imgui window for user callback"},{"location":"basics/scene_options/","text":"These are settings which affect the visual display of the scene. It is often convenient to set them just before calling polyscope :: init , but they may set be anywhere. #include \"polyscope/polyscope.h\" // a few options polyscope :: options :: autocenterStructures = true ; // initialize polyscope :: init (); bool options :: autocenterStructures autocenter structures If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: false .","title":"Scene Options"},{"location":"basics/scene_options/#autocenter-structures","text":"If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: false .","title":"autocenter structures"},{"location":"building/","text":"Polyscope uses CMake as its build system. If you\u2019re using CMAKE, integrating Polyscope in to your codebase should be as simple as running git clone --recurse-submodules https://github.com/nmwsharp/polyscope.git and adding add_subdirectory ( \"polyscope\" ) ... target_link_libraries ( YOUR_TARGET polyscope ) to your CMakeLists . txt . See these repositories for some simple examples of using Polyscope to an existing codebase or library: with geometry-central \u2013 example project with libIGL \u2013 example project Dependencies Polyscope packages all of its source code dependencies with the repository. On Ubuntu and friends, you may want to apt - get install xorg - dev libglu1 - mesa - dev freeglut3 - dev mesa - common - dev to pull graphics and windowing related headers to build. Building in Windows These instructions are unix-centric, because the project developers are mac and linux users. In theory, Polyscope builds just fine in Windows, though some manual effort may be required. Better instructions coming soon!","title":"Building"},{"location":"building/#dependencies","text":"Polyscope packages all of its source code dependencies with the repository. On Ubuntu and friends, you may want to apt - get install xorg - dev libglu1 - mesa - dev freeglut3 - dev mesa - common - dev to pull graphics and windowing related headers to build.","title":"Dependencies"},{"location":"building/#building-in-windows","text":"These instructions are unix-centric, because the project developers are mac and linux users. In theory, Polyscope builds just fine in Windows, though some manual effort may be required. Better instructions coming soon!","title":"Building in Windows"},{"location":"features/2D_data/","text":"Polyscope is primarily focused on 3D data, but can also be used for 2D visualization. This section descibes a few helpers which make it easier to do so. Example: register a 2D point cloud and add some vectors to it #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" polyscope :: init (); // Set the camera to 2D mode (see below) polyscope :: view :: style = polyscope :: view :: NavigateStyle :: Planar ; // Build a random point cloud size_t N = 3000 ; std :: vector < glm :: vec2 > points ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { points . push_back ( glm :: vec2 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }); } // Register it. Note the \"2D\" in the function call. polyscope :: registerPointCloud2D ( \"flat points\" , points ); // Build a random vector std :: vector < glm :: vec2 > randVec ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { randVec [ i ] = glm :: vec2 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }; } // Add it to the point cloud. Note the \"2D\" in the function call polyscope :: getPointCloud ( \"flat points\" ) -> addVectorQuantity2D ( \"random vector\" , randVec ); polyscope :: show (); Adding 2D data Functions which accept 3D positions (or vectors) as input have a variant which takes 2D positions, and appends a 0 z-coordinate. For instance, registerPointCloud () has a matching registerPointCloud2D () , there\u2019s registerSurfaceMesh2D , etc. Any other functions which don\u2019t take 3D positions can be used as normal, like addScalarQuantity () . Note that you definitely should not just call the normal 3D versions with 2D data. If you\u2019re lucky, it will fail to compile; if you\u2019re unlucky your code may segfault! Planar camera mode The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: polyscope :: view :: style = polyscope :: view :: NavigateStyle :: Planar ;","title":"2D Data"},{"location":"features/2D_data/#adding-2d-data","text":"Functions which accept 3D positions (or vectors) as input have a variant which takes 2D positions, and appends a 0 z-coordinate. For instance, registerPointCloud () has a matching registerPointCloud2D () , there\u2019s registerSurfaceMesh2D , etc. Any other functions which don\u2019t take 3D positions can be used as normal, like addScalarQuantity () . Note that you definitely should not just call the normal 3D versions with 2D data. If you\u2019re lucky, it will fail to compile; if you\u2019re unlucky your code may segfault!","title":"Adding 2D data"},{"location":"features/2D_data/#planar-camera-mode","text":"The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: polyscope :: view :: style = polyscope :: view :: NavigateStyle :: Planar ;","title":"Planar camera mode"},{"location":"features/messages/","text":"Using messages We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. terminating error Like error , but terminates the program after being dismissed. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [ space ] . Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); // Generating an error. // The UI will block and show this error immediately. After // the error is dismissed, the call will return. polyscope :: error ( \"Resistance is futile.\" ); // Generate a fatal error. // After the error is dismissed, the program will terminate. polyscope :: terminatingError ( \"Resistance is futile.\" ); Messages void polyscope :: info ( std :: string message ) info Simply logs a message to stdout . void polyscope :: warning ( std :: string baseMessage , std :: string detailMessage = \"\" ) warning Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detailMessage field need not be used. However, if issuing warnings in a loop, warnings with the same baseMessage are batched together, so the UI doesn\u2019t get completely overwhelmed. Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); void polyscope :: error ( std :: string message ) error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns. void polyscope :: terminatingError ( std :: string message ) terminating error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, the program terminates.","title":"Messages"},{"location":"features/messages/#using-messages","text":"We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. terminating error Like error , but terminates the program after being dismissed. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [ space ] . Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); // Generating an error. // The UI will block and show this error immediately. After // the error is dismissed, the call will return. polyscope :: error ( \"Resistance is futile.\" ); // Generate a fatal error. // After the error is dismissed, the program will terminate. polyscope :: terminatingError ( \"Resistance is futile.\" );","title":"Using messages"},{"location":"features/messages/#messages","text":"void polyscope :: info ( std :: string message )","title":"Messages"},{"location":"features/messages/#info","text":"Simply logs a message to stdout . void polyscope :: warning ( std :: string baseMessage , std :: string detailMessage = \"\" )","title":"info"},{"location":"features/messages/#warning","text":"Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detailMessage field need not be used. However, if issuing warnings in a loop, warnings with the same baseMessage are batched together, so the UI doesn\u2019t get completely overwhelmed. Example: #include \"polyscope/polyscope.h\" // Generate a single warning. // Has no effect on the GUI until polyscope gets control flow // back, which happens here in the show() call below. polyscope :: warning ( \"Something went slightly wrong\" ); // Generate a lot of warnings. Becase all of these warnings // have the same base message (the first string), they will // be batched together and only shown as one dialog. The detail // message for the first such warning will also be shown. for ( int i = 0 ; i < 5000 ; i ++ ) { polyscope :: warning ( \"Some problems come in groups\" , \"detail = \" + std :: to_string ( i )); } // The previous warnings would be displayed here polyscope :: show (); void polyscope :: error ( std :: string message )","title":"warning"},{"location":"features/messages/#error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns. void polyscope :: terminatingError ( std :: string message )","title":"error"},{"location":"features/messages/#terminating-error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, the program terminates.","title":"terminating error"},{"location":"features/screenshots/","text":"Taking screenshots Polyscope includes simple functionality for saving screenshots of the UI to disk. The imGUI windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [ screenshot ] button in the options UI window, or programmatically using the functions below. Clicking the UI button is equivalent to calling screenshot () below, generating a numbered screenshot file in the current directory. Messages void polyscope :: screenshot ( bool transparentBG = true ) numbered screenshot Saves a screenshot to the current directory, with file named screenshot_000000 . tga , numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent. void polyscope :: screenshot ( std :: string filename , bool transparentBG = true ) named screenshot Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be one of .png , .tga , or .bmp . If transparentBG is true , the background will be rendered as transparent.","title":"Screenshots"},{"location":"features/screenshots/#taking-screenshots","text":"Polyscope includes simple functionality for saving screenshots of the UI to disk. The imGUI windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [ screenshot ] button in the options UI window, or programmatically using the functions below. Clicking the UI button is equivalent to calling screenshot () below, generating a numbered screenshot file in the current directory.","title":"Taking screenshots"},{"location":"features/screenshots/#messages","text":"void polyscope :: screenshot ( bool transparentBG = true )","title":"Messages"},{"location":"features/screenshots/#numbered-screenshot","text":"Saves a screenshot to the current directory, with file named screenshot_000000 . tga , numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent. void polyscope :: screenshot ( std :: string filename , bool transparentBG = true )","title":"numbered screenshot"},{"location":"features/screenshots/#named-screenshot","text":"Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be one of .png , .tga , or .bmp . If transparentBG is true , the background will be rendered as transparent.","title":"named screenshot"},{"location":"features/user_callback/","text":"Intro When polyscope :: show () has been called, Polyscope will optionally invoke user-supplied callback function on every loop iteration. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc. See ImGui for documentation of UI commands. std :: function < void () > polyscope :: state :: userCallback user callback A function which will be invoked on every main loop iteration by Polyscope, once show () has been called. If null, nothing will be invoked. Example The code below creates the following UI using a callback. #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" // Parameters which we will set in the callback UI. int nPts = 2000 ; float anotherParam = 3.14 ; void mySubroutine () { // do something useful... // Register a structure std :: vector < glm :: vec3 > points ; for ( int i = 0 ; i < nPts ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit () }); } polyscope :: registerPointCloud ( \"my point cloud\" , points ); } // Your callback functions void myCallback () { // Since options::openImGuiWindowForUserCallback == true by default, // we can immediately start using ImGui commands to build a UI ImGui :: PushItemWidth ( 100 ); // Make ui elements 100 pixels wide, // instead of full width. Must have // matching PopItemWidth() below. ImGui :: InputInt ( \"num points\" , & nPts ); // set a int variable ImGui :: InputFloat ( \"param value\" , & anotherParam ); // set a float variable if ( ImGui :: Button ( \"run subroutine\" )) { // executes when button is pressed mySubroutine (); } ImGui :: SameLine (); if ( ImGui :: Button ( \"hi\" )) { polyscope :: warning ( \"hi\" ); } ImGui :: PopItemWidth (); } int main ( int argc , char ** argv ) { /* ...your program setup... */ // Initialize polyscope polyscope :: init (); // Specify the callback polyscope :: state :: userCallback = callback ; // Give control to the polyscope gui polyscope :: show (); return EXIT_SUCCESS ; } Options bool options :: openImGuiWindowForUserCallback open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui :: Button ( \" do stuff \" ) . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"User Callback"},{"location":"features/user_callback/#intro","text":"When polyscope :: show () has been called, Polyscope will optionally invoke user-supplied callback function on every loop iteration. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc. See ImGui for documentation of UI commands. std :: function < void () > polyscope :: state :: userCallback","title":"Intro"},{"location":"features/user_callback/#user-callback","text":"A function which will be invoked on every main loop iteration by Polyscope, once show () has been called. If null, nothing will be invoked.","title":"user callback"},{"location":"features/user_callback/#example","text":"The code below creates the following UI using a callback. #include \"polyscope/polyscope.h\" #include \"polyscope/point_cloud.h\" // Parameters which we will set in the callback UI. int nPts = 2000 ; float anotherParam = 3.14 ; void mySubroutine () { // do something useful... // Register a structure std :: vector < glm :: vec3 > points ; for ( int i = 0 ; i < nPts ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit () }); } polyscope :: registerPointCloud ( \"my point cloud\" , points ); } // Your callback functions void myCallback () { // Since options::openImGuiWindowForUserCallback == true by default, // we can immediately start using ImGui commands to build a UI ImGui :: PushItemWidth ( 100 ); // Make ui elements 100 pixels wide, // instead of full width. Must have // matching PopItemWidth() below. ImGui :: InputInt ( \"num points\" , & nPts ); // set a int variable ImGui :: InputFloat ( \"param value\" , & anotherParam ); // set a float variable if ( ImGui :: Button ( \"run subroutine\" )) { // executes when button is pressed mySubroutine (); } ImGui :: SameLine (); if ( ImGui :: Button ( \"hi\" )) { polyscope :: warning ( \"hi\" ); } ImGui :: PopItemWidth (); } int main ( int argc , char ** argv ) { /* ...your program setup... */ // Initialize polyscope polyscope :: init (); // Specify the callback polyscope :: state :: userCallback = callback ; // Give control to the polyscope gui polyscope :: show (); return EXIT_SUCCESS ; }","title":"Example"},{"location":"features/user_callback/#options","text":"bool options :: openImGuiWindowForUserCallback","title":"Options"},{"location":"features/user_callback/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like ImGui :: Button ( \" do stuff \" ) . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: true .","title":"open imgui window for user callback"},{"location":"integrations/cgal/","text":"","title":"Home"},{"location":"integrations/geometry_central/","text":"This section demonstrates using Polyscope with geometry-central ! Note that a few useful adaptor functions are included in geometrycentral / surface / meshio . h . See this repository for a sample project configuration and CMAKE build system. Note This section is written against a soon-to-be released overhaul of geometry-central, which currently lives in the v1 branch of that repository. Registering a surface mesh #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include \"geometrycentral/surface/halfedge_mesh.h\" #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"geometrycentral/surface/meshio.h using namespace geometrycentral :: surface ; HalfedgeMesh & mesh = /* your mesh */ ; EmbeddedGeometryInterface & geom = /* your geometry */ ; // Be sure your mesh has vertex positions available geom . requireVertexPositions (); // Register the mesh with polyscope polyscope :: registerSurfaceMesh ( \"myMesh\" , geom . vertexPositions , mesh . getFaceVertexList ()); // Note: for a VertexPositionGeometry, one could instead use: VertexPositionGeometry & posGeom = /* your geometry */ ; polyscope :: registerSurfaceMesh ( \"myMesh\" , posGeom . inputVertexPositions , mesh . getFaceVertexList ()); Meshdata containers Geometry-central\u2019s Meshdata <> containers can be passed directly to Polyscope for visualization. /* (continuing up from the Registering example above) */ VertexData < double > myScalar = /* some scalar on vertices */ ; polyscope :: getMesh ( \"myMesh\" ) -> addVertexScalarQuantity ( \"myScalar\" , myScalar ); FaceData < double > otherScalar = /* another scalar on faces*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addFaceScalarQuantity ( \"otherScalar\" , otherScalar ); FaceData < double > anotherScalar = /* another scalar on edges*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addEdgeScalarQuantity ( \"super important edge scalar\" , anotherScalar ); // Containers holding `Vector3`s can be used for 3D vectors at faces and vertices // Example: vertex normals as computed in geometry-central posGeom -> requireVertexNormals (); polyscope :: getMesh ( \"myMesh\" ) -> addVertexVectorQuantity ( \"vertex normals\" , posGeom -> vertexNormals ); Custom ordering Geometry-central\u2019s ordering of mesh halfedges and corners is different from Polyscope\u2019s default ordering (see indexing convention ). As such, you must tell Polyscope about this ordering for halfedge or corner-valued visualizations to work properly. The geometry-central function polyscopePermutations ( HalfedgeMesh & mesh ) from meshio . h generates the ordering data in an approriate form for Polyscope, and can be passed either at construction time or after. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // could alternately pass polyscopePermutations(*mesh) as additional // last parameter of constructor polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh )); Tangent vector data 1-forms To communicate the canonical edge orientation when passing a 1-form, use polyscopeEdgeOrientations ( mesh ) from meshio . h . Example: #include \"geometrycentral/surface/meshio.h\" HalfedgeMesh & mesh = /* your mesh */ ; EdgeData < double > myForm = /* your 1-form */ ; polyscope :: getSurfaceMesh ( \"myMesh\" ) -> addOneFormIntrinsicVectorQuantity ( \"my form\" , myForm , polyscopeEdgeOrientations ( mesh ));","title":"Geometry Central"},{"location":"integrations/geometry_central/#registering-a-surface-mesh","text":"#include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include \"geometrycentral/surface/halfedge_mesh.h\" #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"geometrycentral/surface/meshio.h using namespace geometrycentral :: surface ; HalfedgeMesh & mesh = /* your mesh */ ; EmbeddedGeometryInterface & geom = /* your geometry */ ; // Be sure your mesh has vertex positions available geom . requireVertexPositions (); // Register the mesh with polyscope polyscope :: registerSurfaceMesh ( \"myMesh\" , geom . vertexPositions , mesh . getFaceVertexList ()); // Note: for a VertexPositionGeometry, one could instead use: VertexPositionGeometry & posGeom = /* your geometry */ ; polyscope :: registerSurfaceMesh ( \"myMesh\" , posGeom . inputVertexPositions , mesh . getFaceVertexList ());","title":"Registering a surface mesh"},{"location":"integrations/geometry_central/#meshdata-containers","text":"Geometry-central\u2019s Meshdata <> containers can be passed directly to Polyscope for visualization. /* (continuing up from the Registering example above) */ VertexData < double > myScalar = /* some scalar on vertices */ ; polyscope :: getMesh ( \"myMesh\" ) -> addVertexScalarQuantity ( \"myScalar\" , myScalar ); FaceData < double > otherScalar = /* another scalar on faces*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addFaceScalarQuantity ( \"otherScalar\" , otherScalar ); FaceData < double > anotherScalar = /* another scalar on edges*/ ; polyscope :: getMesh ( \"myMesh\" ) -> addEdgeScalarQuantity ( \"super important edge scalar\" , anotherScalar ); // Containers holding `Vector3`s can be used for 3D vectors at faces and vertices // Example: vertex normals as computed in geometry-central posGeom -> requireVertexNormals (); polyscope :: getMesh ( \"myMesh\" ) -> addVertexVectorQuantity ( \"vertex normals\" , posGeom -> vertexNormals );","title":"Meshdata containers"},{"location":"integrations/geometry_central/#custom-ordering","text":"Geometry-central\u2019s ordering of mesh halfedges and corners is different from Polyscope\u2019s default ordering (see indexing convention ). As such, you must tell Polyscope about this ordering for halfedge or corner-valued visualizations to work properly. The geometry-central function polyscopePermutations ( HalfedgeMesh & mesh ) from meshio . h generates the ordering data in an approriate form for Polyscope, and can be passed either at construction time or after. polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // could alternately pass polyscopePermutations(*mesh) as additional // last parameter of constructor polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"myMesh\" , geom -> vertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh ));","title":"Custom ordering"},{"location":"integrations/geometry_central/#tangent-vector-data","text":"","title":"Tangent vector data"},{"location":"integrations/geometry_central/#1-forms","text":"To communicate the canonical edge orientation when passing a 1-form, use polyscopeEdgeOrientations ( mesh ) from meshio . h . Example: #include \"geometrycentral/surface/meshio.h\" HalfedgeMesh & mesh = /* your mesh */ ; EdgeData < double > myForm = /* your 1-form */ ; polyscope :: getSurfaceMesh ( \"myMesh\" ) -> addOneFormIntrinsicVectorQuantity ( \"my form\" , myForm , polyscopeEdgeOrientations ( mesh ));","title":"1-forms"},{"location":"integrations/libIGL/","text":"This section demonstrates using Polyscope with libIGL . See this repository for a sample project configuration, CMAKE build system, and a quick demo. Generally, Polyscope\u2019s data adaptors work as expected with libIGL! You can simply call Polyscope functions and pass your IGL Eigen matrix types. Adding a mesh Example: // Initialize polyscope polyscope :: init (); // Read a mesh igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the gui polyscope :: show (); Adding mesh quantities Adding a scalar quantity: using namespace Eigen ; // Compute pointwise Gaussian curvature VectorXd K ; igl :: gaussian_curvature ( meshV , meshF , K ); SparseMatrix < double > M , Minv ; igl :: massmatrix ( meshV , meshF , igl :: MASSMATRIX_TYPE_DEFAULT , M ); igl :: invert_diag ( M , Minv ); K = ( Minv * K ). eval (); // Add for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexScalarQuantity ( \"gaussian curvature\" , K ); Adding a vector quantity: // Compute vertex normals Eigen :: MatrixXd N_vertices ; igl :: per_vertex_normals ( meshV , meshF , N_vertices ); // Add them for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexVectorQuantity ( \"libIGL vertex normals\" , N_vertices );","title":"libIGL"},{"location":"integrations/libIGL/#adding-a-mesh","text":"Example: // Initialize polyscope polyscope :: init (); // Read a mesh igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the gui polyscope :: show ();","title":"Adding a mesh"},{"location":"integrations/libIGL/#adding-mesh-quantities","text":"Adding a scalar quantity: using namespace Eigen ; // Compute pointwise Gaussian curvature VectorXd K ; igl :: gaussian_curvature ( meshV , meshF , K ); SparseMatrix < double > M , Minv ; igl :: massmatrix ( meshV , meshF , igl :: MASSMATRIX_TYPE_DEFAULT , M ); igl :: invert_diag ( M , Minv ); K = ( Minv * K ). eval (); // Add for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexScalarQuantity ( \"gaussian curvature\" , K ); Adding a vector quantity: // Compute vertex normals Eigen :: MatrixXd N_vertices ; igl :: per_vertex_normals ( meshV , meshF , N_vertices ); // Add them for visualization in Polyscope polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexVectorQuantity ( \"libIGL vertex normals\" , N_vertices );","title":"Adding mesh quantities"},{"location":"structures/structure_management/","text":"Intro A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); Then, in a distant part of your code, add a scalar function to it with: polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); This avoids the need to pass a pointer to the structure you created around your entire codebase. Memory management As a general policy, Polyscope always manages its own memory, and will take care of deleting anything it allocated. Whenever a routine returns a pointer (like getStructure () ), it is a non-owning pointer. You should never delete one of these pointers. To delete a structure and free memory, see the removeStructure () methods below. The following structures available in Polyscope. Many more structures are in developement! Surface Mesh Point Cloud Curve Network in progress : Camera View in progress : Curve in progress : Tet Mesh Registering structures Each structure offers a register___ ( name , ...) function (like registerPointCloud () ) which accepts the name of the structure and the data necessary to construct it. These functions will return a Structure * pointer which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. By default, these functions will error-out if a structure with that name is already in use. However, they take an optional boolean argument allowReplacement argument, which can be set to true to replace an existing structure of the same name. The general form for registering structures is below; it may be useful if you are implementing your own structures. bool registerStructure ( Structure * structure , bool replaceIfPresent = true ) Register a new structure with Polyscope. The structure must have a Structure :: name which is unique amongst all registered structures of that type. Polyscope takes ownership of the memory when the structure is registered, and will delete it when no longer needed. Note: most users will create structures via the individual registerPointCloud () (etc) functions, rather than this general form. Accessing structures Polyscope offers two patterns for calling methods on a registered structure: you can either use the pointer returned after structure creation, or refer to the structure by name. #include \"polyscope/surface_mesh.h\" // register a structure polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); // with the pointer psMesh -> addScalarQuantity ( \"some values\" , values ); // by name polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); The former is concise and programmatic, while the latter avoids the need to keep track of a varible. As before, each structure offers a get___ ( name ) method, like getSurfaceMesh ( name ) which can be used to get pointer to a structure of that type by name. The general form below may be useful if you are implementing your own structures. Structure * getStructure ( std :: string type , std :: string name = \"\" ) Get a pointer to a registered structure. The type must be the unique string corresponding to the structure type. As a convenience, if the name may be argument omitted only if there is exactly one structure of that type. If not such structure is available, nullptr will be returned. Note: most users will get structures via the individual getPointCloud () (etc) functions, rather than this general form. Removing structures If no longer needed, structures can be removed by name or by pointer. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. void removeStructure ( Structure * structure , bool errorIfAbsent = true ) Remove the specified structure and free objects associated with it. If errorIfAbsent == true , and error will be thrown if there is no such structure registered, otherwise the function will return silently. void removeStructure ( std :: string type , std :: string name , bool errorIfAbsent = true ) Identical to removeStructure ( Struture * ) , but accepts a type name and name instead. void removeStructure ( std :: string name , bool errorIfAbsent = true ) Identical to removeStructure ( Struture * ) , but accepts a name instead. Will fail unless there is exactly one structure with the given name across all structure types.","title":"Structure Management"},{"location":"structures/structure_management/#intro","text":"A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); Then, in a distant part of your code, add a scalar function to it with: polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); This avoids the need to pass a pointer to the structure you created around your entire codebase. Memory management As a general policy, Polyscope always manages its own memory, and will take care of deleting anything it allocated. Whenever a routine returns a pointer (like getStructure () ), it is a non-owning pointer. You should never delete one of these pointers. To delete a structure and free memory, see the removeStructure () methods below. The following structures available in Polyscope. Many more structures are in developement! Surface Mesh Point Cloud Curve Network in progress : Camera View in progress : Curve in progress : Tet Mesh","title":"Intro"},{"location":"structures/structure_management/#registering-structures","text":"Each structure offers a register___ ( name , ...) function (like registerPointCloud () ) which accepts the name of the structure and the data necessary to construct it. These functions will return a Structure * pointer which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. By default, these functions will error-out if a structure with that name is already in use. However, they take an optional boolean argument allowReplacement argument, which can be set to true to replace an existing structure of the same name. The general form for registering structures is below; it may be useful if you are implementing your own structures. bool registerStructure ( Structure * structure , bool replaceIfPresent = true ) Register a new structure with Polyscope. The structure must have a Structure :: name which is unique amongst all registered structures of that type. Polyscope takes ownership of the memory when the structure is registered, and will delete it when no longer needed. Note: most users will create structures via the individual registerPointCloud () (etc) functions, rather than this general form.","title":"Registering structures"},{"location":"structures/structure_management/#accessing-structures","text":"Polyscope offers two patterns for calling methods on a registered structure: you can either use the pointer returned after structure creation, or refer to the structure by name. #include \"polyscope/surface_mesh.h\" // register a structure polyscope :: SurfaceMesh * psMesh = polyscope :: registerSurfaceMesh ( \"my mesh\" , vertices , faces ); // with the pointer psMesh -> addScalarQuantity ( \"some values\" , values ); // by name polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addScalarQuantity ( \"some values\" , values ); The former is concise and programmatic, while the latter avoids the need to keep track of a varible. As before, each structure offers a get___ ( name ) method, like getSurfaceMesh ( name ) which can be used to get pointer to a structure of that type by name. The general form below may be useful if you are implementing your own structures. Structure * getStructure ( std :: string type , std :: string name = \"\" ) Get a pointer to a registered structure. The type must be the unique string corresponding to the structure type. As a convenience, if the name may be argument omitted only if there is exactly one structure of that type. If not such structure is available, nullptr will be returned. Note: most users will get structures via the individual getPointCloud () (etc) functions, rather than this general form.","title":"Accessing structures"},{"location":"structures/structure_management/#removing-structures","text":"If no longer needed, structures can be removed by name or by pointer. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. void removeStructure ( Structure * structure , bool errorIfAbsent = true ) Remove the specified structure and free objects associated with it. If errorIfAbsent == true , and error will be thrown if there is no such structure registered, otherwise the function will return silently. void removeStructure ( std :: string type , std :: string name , bool errorIfAbsent = true ) Identical to removeStructure ( Struture * ) , but accepts a type name and name instead. void removeStructure ( std :: string name , bool errorIfAbsent = true ) Identical to removeStructure ( Struture * ) , but accepts a name instead. Will fail unless there is exactly one structure with the given name across all structure types.","title":"Removing structures"},{"location":"structures/curve_network/basics/","text":"Curve Networks Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point! Registering a curve network Curve network structures can be registered with Polyscope by passing the node position and edge indices. There are also two helpers for constructing lines and loops which only require the node locations and automatically build connectivity. As usual in Polyscope, the data adaptors allow these functions to accept a wide variety of data types as input\u2013 any nodes which are essentially a list of vectors and any edges which are a list of index tuples will work. The std :: vector <> types in the example below are just one possibility. Example: add a curve network #include \"polyscope/curve_network.h\" polyscope :: init (); std :: vector < glm :: vec3 > nodes = /* some nodes */ ; std :: vector < std :: array < size_t , 2 >> edges = /* edges between nodes */ ; // Add the curve network polyscope :: registerCurveNetwork ( \"my network\" , nodes , edges ); // visualize! polyscope :: show (); CurveNetwork * polyscope :: registerCurveNetwork ( std :: string name , const P & nodes , const E & edges ) Add a new curve network to polyscope nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. edges is the array of edges, each of which is a pair of 0-based node indices node. The type should be adaptable to an array of size_t -valued 2-vectors. The length will be the number of edges. Note: the inner vector type of the nodes input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetwork2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLine ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a polyline of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLine2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLoop ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a closed loop of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLoop2D exists with the same signature. See 2D data . Updating a curve network The locations of the nodes in a curve network can be updated with the member function updateNodePositions ( newPositions ) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). void CurveNetwork :: updateNodePositions ( const V & newPositions ) Update the node positions in a curve network structure. newPositions is the vector array of 3D node locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of nodes. Note: updatePointPositions2D exists with the same signature. See 2D data .","title":"Basics"},{"location":"structures/curve_network/basics/#curve-networks","text":"Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point!","title":"Curve Networks"},{"location":"structures/curve_network/basics/#registering-a-curve-network","text":"Curve network structures can be registered with Polyscope by passing the node position and edge indices. There are also two helpers for constructing lines and loops which only require the node locations and automatically build connectivity. As usual in Polyscope, the data adaptors allow these functions to accept a wide variety of data types as input\u2013 any nodes which are essentially a list of vectors and any edges which are a list of index tuples will work. The std :: vector <> types in the example below are just one possibility. Example: add a curve network #include \"polyscope/curve_network.h\" polyscope :: init (); std :: vector < glm :: vec3 > nodes = /* some nodes */ ; std :: vector < std :: array < size_t , 2 >> edges = /* edges between nodes */ ; // Add the curve network polyscope :: registerCurveNetwork ( \"my network\" , nodes , edges ); // visualize! polyscope :: show (); CurveNetwork * polyscope :: registerCurveNetwork ( std :: string name , const P & nodes , const E & edges ) Add a new curve network to polyscope nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. edges is the array of edges, each of which is a pair of 0-based node indices node. The type should be adaptable to an array of size_t -valued 2-vectors. The length will be the number of edges. Note: the inner vector type of the nodes input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetwork2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLine ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a polyline of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLine2D exists with the same signature. See 2D data . CurveNetwork * polyscope :: registerCurveNetworkLoop ( std :: string name , const P & nodes ) Add a new curve network to polyscope from a closed loop of points. The connectivity will be automatically created to connect the points in order. nodes is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of nodes. Note: the inner vector type of the points input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, registerCurveNetworkLoop2D exists with the same signature. See 2D data .","title":"Registering a curve network"},{"location":"structures/curve_network/basics/#updating-a-curve-network","text":"The locations of the nodes in a curve network can be updated with the member function updateNodePositions ( newPositions ) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). void CurveNetwork :: updateNodePositions ( const V & newPositions ) Update the node positions in a curve network structure. newPositions is the vector array of 3D node locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of nodes. Note: updatePointPositions2D exists with the same signature. See 2D data .","title":"Updating a curve network"},{"location":"structures/curve_network/color_quantities/","text":"Visualize color rgb-valued data at the nodes or edges of a curve network. Example: #include \"polyscope/curve_network.h\" std :: vector < std :: array < double , 3 >> randColor ( edges . size ()); for ( size_t i = 0 ; i < edges . size (); i ++ ) { randColor [ i ] = {{ polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit ()}}; } // visualize polyscope :: getCurveNetwork ( curveNetworkName ) -> addEdgeColorQuantity ( \"random color\" , randColor ); CurveNetwork :: addNodeColorQuantity ( std :: string name , const T & values ) Add a color quantity to the nodes of the curve network values is the array of colors at nodes. The type should be adaptable to a 3-vector array of float s. The length should be the number of nodes in the curve network. RGB values are interpreted in the range [ 0 , 1 ] . CurveNetwork :: addEdgeColorQuantity ( std :: string name , const T & values ) Add a color quantity to the edges of the curve network values is the array of colors at edges. The type should be adaptable to a 3-vector array of float s. The length should be the number of edges in the curve network. RGB values are interpreted in the range [ 0 , 1 ] .","title":"Color Quantities"},{"location":"structures/curve_network/scalar_quantities/","text":"Visualize scalar valued data at the nodes or edges of a curve network. Example: #include \"polyscope/curve_network.h\" std :: vector < double > xC ( nodes . size ()); for ( size_t i = 0 ; i < nodes . size (); i ++ ) { xC [ i ] = nodes [ i ]. x ; // (use the x coordinate as sample data) } // visualize polyscope :: getCurveNetwork ( curveNetworkName ) -> addNodeScalarQuantity ( \"sample value\" , xC ); CurveNetwork :: addNodeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity to the nodes of the curve network. values is the array of scalars at nodes. The type should be adaptable to a float scalar array. The length should be the number of nodes in the curve network. CurveNetwork :: addEdgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity to the edges of the curve network. values is the array of scalars at edges . The type should be adaptable to a float scalar array. The length should be the number of edges in the curve network.","title":"Scalar Quantities"},{"location":"structures/curve_network/vector_quantities/","text":"Visualize vector-valued data at the nodes or edges of a curve network. Example: add vectors at nodes #include \"polyscope/curve_network.h\" // Generate random vectors as example vector data std :: vector < glm :: vec3 > randVec ( nNodes ); for ( size_t iN = 0 ; iN < nNodes ; iN ++ ) { randVec [ iN ] = glm :: vec3 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }; } // Add the vector data to the curve network polyscope :: getCurveNetwork ( \"my curve\" ) -> addNodeVectorQuantity ( \"sample vectors\" , randVec ); // Visualize polyscope :: show (); CurveNetwork :: addNodeVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity to the nodes of a curve network. Vectors will be drawn with their roots at each edge. vectors is the array of vectors at nodes. The type should be adaptable to a 3-vector array of float s. The length should be the number of nodes in the curve network. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType :: AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D curve network), addNodeVectorQuantity2D exists with the same signature. See 2D data . CurveNetwork :: addEdgeVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity to the edges of a curve network. Vectors will be drawn with their roots at the center of each each. vectors is the array of vectors at edges. The type should be adaptable to a 3-vector array of float s. The length should be the number of edges in the curve network. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType :: AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D curve network), addEdgeVectorQuantity2D exists with the same signature. See 2D data .","title":"Vector Quantities"},{"location":"structures/point_cloud/basics/","text":"Point Clouds Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point. Registering a point cloud Example: a point cloud of random points #include \"polyscope/point_cloud.h\" std :: vector < glm :: vec3 > points ; // generate points for ( size_t i = 0 ; i < 3000 ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }); } // visualize! polyscope :: registerPointCloud ( \"really great points\" , points ); polyscope :: registerPointCloud ( std :: string name , const T & pointPositions ) Add a new point cloud structure to Polyscope. pointPositions is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of points. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D point cloud, registerPointCloud2D exists with the same signature. See 2D data . Updating a point cloud The locations of the points in a point cloud can be updated with the member function updatePointPositions ( newPositions ) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). void PointCloud :: updatePointPositions ( const V & newPositions ) Update the point positions in a point cloud structure. newPositions is the vector array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of points. Note: updatePointPositions2D exists with the same signature. See 2D data .","title":"Basics"},{"location":"structures/point_cloud/basics/#point-clouds","text":"Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point.","title":"Point Clouds"},{"location":"structures/point_cloud/basics/#registering-a-point-cloud","text":"Example: a point cloud of random points #include \"polyscope/point_cloud.h\" std :: vector < glm :: vec3 > points ; // generate points for ( size_t i = 0 ; i < 3000 ; i ++ ) { points . push_back ( glm :: vec3 { polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 , polyscope :: randomUnit () - .5 }); } // visualize! polyscope :: registerPointCloud ( \"really great points\" , points ); polyscope :: registerPointCloud ( std :: string name , const T & pointPositions ) Add a new point cloud structure to Polyscope. pointPositions is the array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of points. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D point cloud, registerPointCloud2D exists with the same signature. See 2D data .","title":"Registering a point cloud"},{"location":"structures/point_cloud/basics/#updating-a-point-cloud","text":"The locations of the points in a point cloud can be updated with the member function updatePointPositions ( newPositions ) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). void PointCloud :: updatePointPositions ( const V & newPositions ) Update the point positions in a point cloud structure. newPositions is the vector array of 3D point locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of points. Note: updatePointPositions2D exists with the same signature. See 2D data .","title":"Updating a point cloud"},{"location":"structures/point_cloud/color_quantities/","text":"Visualize color rgb-valued data at the points of a point cloud. Example: #include \"polyscope/point_cloud.h\" std :: vector < std :: array < double , 3 >> randColor ( points . size ()); for ( size_t i = 0 ; i < points . size (); i ++ ) { randColor [ i ] = {{ polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit ()}}; } // visualize polyscope :: getPointCloud ( pointCloudName ) -> addColorQuantity ( \"random color\" , randColor ); PointCloud :: addColorQuantity ( std :: string name , const T & values ) Add a color quantity to the point cloud. values is the array of colors at points. The type should be adaptable to a 3-vector array of float s. The length should be the number of points in the point cloud. RGB values are interpreted in the range [ 0 , 1 ] .","title":"Color Quantities"},{"location":"structures/point_cloud/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the points of a point cloud. Example: #include \"polyscope/point_cloud.h\" std :: vector < double > xC ( points . size ()); for ( size_t i = 0 ; i < points . size (); i ++ ) { xC [ i ] = points [ i ]. x ; } // visualize polyscope :: getPointCloud ( pointCloudName ) -> addScalarQuantity ( \"xC\" , xC ); PointCloud :: addScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity to the point cloud. values is the array of scalars at points. The type should be adaptable to a float scalar array. The length should be the number of points in the point cloud.","title":"Scalar Quantities"},{"location":"structures/point_cloud/vector_quantities/","text":"Visualize vector-valued data at the points of a point cloud. PointCloud :: addVectorQuantity ( std :: string name , const T & vectors , VectorType vectorType = VectorType :: STANDARD ) Add a vector quantity to the point cloud. vectors is the array of vectors at points. The type should be adaptable to a 3-vector array of float s. The length should be the number of points in the point cloud. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType :: AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D point cloud), addVectorQuantity2D exists with the same signature. See 2D data .","title":"Vector Quantities"},{"location":"structures/surface_mesh/basics/","text":"Surface Meshes Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/edges/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element. Registering a surface mesh Example: registering a surface mesh from libIGL #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include <igl/readOBJ.h> // Initialize Polyscope polyscope :: init (); // Read the mesh Eigen :: MatrixXd meshV ; Eigen :: MatrixXi meshF ; igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the GUI polyscope :: show (); Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices ) Add a new surface mesh structure to Polyscope. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of vertices. faceIndices is the nested array of vertex indices for each face. The type should be adaptable to a nested array of size_t . The outer length will be the number of faces. All indices should be valid 0-based indices in to the vertex list. Fortunately, although Polyscope accepts a general nested list of face vertex indices to support Polygonal meshes, passing a fixed-size Nx3 array for a triangle will work just fine, like Eigen :: MatrixXi . Note: the inner vector type of the vertex positions must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D surface mesh, registerSurfaceMesh2D exists with the same signature. See 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering. Updating a mesh The locations of the vertices in a mesh can be updated with the member function updateVertexPositions ( newPositions ) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). void SurfaceMesh :: updateVertexPositions ( const V & newPositions ) Update the vertex positions in a surface mesh structure. newPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of vertices. Note: updateVertexPositions2D exists with the same signature. See 2D data .","title":"Basics"},{"location":"structures/surface_mesh/basics/#surface-meshes","text":"Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/edges/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element.","title":"Surface Meshes"},{"location":"structures/surface_mesh/basics/#registering-a-surface-mesh","text":"Example: registering a surface mesh from libIGL #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" #include <igl/readOBJ.h> // Initialize Polyscope polyscope :: init (); // Read the mesh Eigen :: MatrixXd meshV ; Eigen :: MatrixXi meshF ; igl :: readOBJ ( filename , meshV , meshF ); // Register the mesh with Polyscope polyscope :: registerSurfaceMesh ( \"input mesh\" , meshV , meshF ); // Show the GUI polyscope :: show (); Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices ) Add a new surface mesh structure to Polyscope. vertexPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length will be the number of vertices. faceIndices is the nested array of vertex indices for each face. The type should be adaptable to a nested array of size_t . The outer length will be the number of faces. All indices should be valid 0-based indices in to the vertex list. Fortunately, although Polyscope accepts a general nested list of face vertex indices to support Polygonal meshes, passing a fixed-size Nx3 array for a triangle will work just fine, like Eigen :: MatrixXi . Note: the inner vector type of the vertex positions must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D surface mesh, registerSurfaceMesh2D exists with the same signature. See 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering.","title":"Registering a surface mesh"},{"location":"structures/surface_mesh/basics/#updating-a-mesh","text":"The locations of the vertices in a mesh can be updated with the member function updateVertexPositions ( newPositions ) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). void SurfaceMesh :: updateVertexPositions ( const V & newPositions ) Update the vertex positions in a surface mesh structure. newPositions is the vector array of 3D vertex locations. The type should be adaptable to an array of float -valued 3-vectors. The length must be equal to the current number of vertices. Note: updateVertexPositions2D exists with the same signature. See 2D data .","title":"Updating a mesh"},{"location":"structures/surface_mesh/color_quantities/","text":"Visualize color rgb-valued data at the elements of a surface mesh. Example : visualizing random colors at faces #include \"polyscope/surface_mesh.h\" // Make some random colors std :: vector < std :: array < double , 3 >> fColor ( nFaces ); for ( size_t iF = 0 ; iF < nFaces ; iF ++ ) { std :: vector < size_t >& face = faceIndices [ iF ]; fColor [ iF ] = {{ polyscope :: randomUnit (), polyscope :: randomUnit (), polyscope :: randomUnit ()}}; } // Visualize polyscope :: getSurfaceMesh ( \"name\" ) -> addFaceColorQuantity ( \"fColor\" , fColor ); Add colors to elements SurfaceMesh :: addVertexColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the vertices of the mesh. values is the array of colors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. RGB values are interpreted in the range [ 0 , 1 ] . SurfaceMesh :: addFaceColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the faces of the mesh. values is the array of colors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. RGB values are interpreted in the range [ 0 , 1 ] .","title":"Color Quantities"},{"location":"structures/surface_mesh/color_quantities/#add-colors-to-elements","text":"SurfaceMesh :: addVertexColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the vertices of the mesh. values is the array of colors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. RGB values are interpreted in the range [ 0 , 1 ] . SurfaceMesh :: addFaceColorQuantity ( std :: string name , const T & values ) Add a color quantity defined at the faces of the mesh. values is the array of colors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. RGB values are interpreted in the range [ 0 , 1 ] .","title":"Add colors to elements"},{"location":"structures/surface_mesh/count_quantities/","text":"Count quantities store integers defined at just a few elements of a mesh, rather than at every element. These useful for visualizing, e.g., singularities of a vector field at vertices. TODO TODO document count quantities. See polyscope / surface_mesh . h for add signatures.","title":"Count Quantities"},{"location":"structures/surface_mesh/distance_quantities/","text":"Visualize distance-valued data at the elements of a surface mesh. Distance quantities are basicly scalars, but are visualized with alternating stripes to show distance contours. Example : visualizing exact geodesic distance computed via libIGL\u2019s wrappers around Kirsanov\u2019s MMP implementation. // Compute distance from vertex iVertexSource Eigen :: VectorXi VS , FS , VT , FT ; VS . resize ( 1 ); VS << iVertexSource ; VT . setLinSpaced ( meshV . rows (), 0 , meshV . rows () - 1 ); Eigen :: VectorXd d ; igl :: exact_geodesic ( meshV , meshF , VS , FS , VT , FT , d ); // Add the distance quantity to the surface mesh polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexDistanceQuantity ( \"distance from vertex \" + std :: to_string ( iVertexSource ), d ); Add distance to vertices SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a signed distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. This quantity is very similar to addVertexDistanceQuantity , except the colormap is adjusted to scale symetrically for negative values.","title":"Distance Quantities"},{"location":"structures/surface_mesh/distance_quantities/#add-distance-to-vertices","text":"SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addVertexDistanceQuantity ( std :: string name , const T & values ) Add a signed distance quantity defined at the vertices of the mesh. values is the array of distances at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. This quantity is very similar to addVertexDistanceQuantity , except the colormap is adjusted to scale symetrically for negative values.","title":"Add distance to vertices"},{"location":"structures/surface_mesh/indexing_convention/","text":"Default ordering Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors ). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p [ i ] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering. Vertices The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setVertexPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for vertex-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Faces The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setFacePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for face-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Edges The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setEdgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for edge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Halfedges The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setHalfedgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. Corners The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setCornerPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for corner-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added. All at once As a convenience, you can alternately define a single function which passes all permutations needed at the same time. This is useful because you can write a single helper function which defines any necessary permutations for the mesh convention in your codebase; see the geometry-central integration for an example. The permutations should be passed as a std :: array < std :: pair < T , size_t > , 5 > , where T is any type that could be used in the set___Permutation () functions above\u2014one good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Each entry of this array is one of the permutations listed above: [vertices, faces, edges, halfedges, corners]. Any permutations which have size () == 0 will be untouched. The second entry of the pair is the optional size of the target index space, as in expectedSize above. These permutations can either be set with SurfaceMesh :: setAllPermutations () , or at construction time via a third argument to registerSurfaceMesh () . SurfaceMesh :: setAllPermutations ( const std :: array < std :: pair < T , size_t > , 5 >& perms ) Set all of the ordering permutations at once, as described above. The argument should be a std :: array <> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . If the size of your index space is different from size of the default index space, the second component of each pair must give this new size. Otherwise, the second component of the pair may be set to zero, to infer the size of the index space from the maximum index given. Must be set before any quantites are added. SurfaceMesh * polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices , const std :: array < std :: pair < P , size_t > , 5 >& perms , bool replaceIfPresent = true ) Register a mesh and immediately set all custom permutations, as described above. Equivalent to SurfaceMesh * s = registerSurfaceMesh ( name , vertexPositions , faceIndices , replaceIfPresent ); s -> setAllPermutations ( perms ); Other wise behave like the standard registerSurfaceMesh () . The argument should be a std :: array <> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Must be set before any quantites are added.","title":"Indexing Convention"},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","text":"Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors ). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p [ i ] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.","title":"Default ordering"},{"location":"structures/surface_mesh/indexing_convention/#vertices","text":"The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setVertexPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for vertex-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Vertices"},{"location":"structures/surface_mesh/indexing_convention/#faces","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setFacePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for face-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Faces"},{"location":"structures/surface_mesh/indexing_convention/#edges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setEdgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for edge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Edges"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setHalfedgePermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Halfedges"},{"location":"structures/surface_mesh/indexing_convention/#corners","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below. SurfaceMesh :: setCornerPermutation ( const T & permArr , size_t expectedSize = 0 ) Set a non-standard ordering for corner-valued data on a mesh. The argument should be an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: vector < size_t > . If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in permArr . Must be set before any quantites are added.","title":"Corners"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","text":"As a convenience, you can alternately define a single function which passes all permutations needed at the same time. This is useful because you can write a single helper function which defines any necessary permutations for the mesh convention in your codebase; see the geometry-central integration for an example. The permutations should be passed as a std :: array < std :: pair < T , size_t > , 5 > , where T is any type that could be used in the set___Permutation () functions above\u2014one good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Each entry of this array is one of the permutations listed above: [vertices, faces, edges, halfedges, corners]. Any permutations which have size () == 0 will be untouched. The second entry of the pair is the optional size of the target index space, as in expectedSize above. These permutations can either be set with SurfaceMesh :: setAllPermutations () , or at construction time via a third argument to registerSurfaceMesh () . SurfaceMesh :: setAllPermutations ( const std :: array < std :: pair < T , size_t > , 5 >& perms ) Set all of the ordering permutations at once, as described above. The argument should be a std :: array <> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . If the size of your index space is different from size of the default index space, the second component of each pair must give this new size. Otherwise, the second component of the pair may be set to zero, to infer the size of the index space from the maximum index given. Must be set before any quantites are added. SurfaceMesh * polyscope :: registerSurfaceMesh ( std :: string name , const V & vertexPositions , const F & faceIndices , const std :: array < std :: pair < P , size_t > , 5 >& perms , bool replaceIfPresent = true ) Register a mesh and immediately set all custom permutations, as described above. Equivalent to SurfaceMesh * s = registerSurfaceMesh ( name , vertexPositions , faceIndices , replaceIfPresent ); s -> setAllPermutations ( perms ); Other wise behave like the standard registerSurfaceMesh () . The argument should be a std :: array <> of an array-like type which can be interpreted as an array integers, see input adaptors . One good choice is a std :: array < std :: pair < std :: vector < size_t > , size_t > , 5 > . Must be set before any quantites are added.","title":"All at once"},{"location":"structures/surface_mesh/misc_quantities/","text":"Surface Graph Quantity The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph.","title":"Misc Quantities"},{"location":"structures/surface_mesh/misc_quantities/#surface-graph-quantity","text":"The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph.","title":"Surface Graph Quantity"},{"location":"structures/surface_mesh/parameterization_quantities/","text":"A parameterization is a set of 2D coordinates associated with a mesh, often referred to as \u201cUV coordinates\u201d. This sections details several functions for visualizing such parameterizations. # include \" polyscope/surface_mesh.h \" Example : visualizing an LSCM parameterization via libIGL using namespace Eigen ; using namespace std ; // Fix two points on the boundary VectorXi bnd , b ( 2 , 1 ); igl :: boundary_loop ( meshF , bnd ); if ( bnd . size () == 0 ) { polyscope :: warning ( \"mesh has no boundary, cannot parameterize\" ); return ; } b ( 0 ) = bnd ( 0 ); b ( 1 ) = bnd ( round ( bnd . size () / 2 )); MatrixXd bc ( 2 , 2 ); bc << 0 , 0 , 1 , 0 ; // LSCM parametrization Eigen :: MatrixXd V_uv ; igl :: lscm ( meshV , meshF , b , bc , V_uv ); polyscope :: getSurfaceMesh ( \"input mesh\" ) -> addVertexParameterizationQuantity ( \"LSCM parameterization\" , V_uv ); Adding SurfaceMesh :: addParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the corners of a mesh. coords is the array of 2D UV coordinates at corners. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of corners in the mesh. SurfaceMesh :: addVertexParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh. SurfaceMesh :: addLocalParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. this is similar to addVertexParameterizationQuantity , but has preset settings for style and type which are suitable for local parameterizations about a point. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh. Options Styles Several styles are available for how a parameterization is displayed. The enum class ParamVizStyle has options for how parameterizations are visualized: CHECKER : a two-color checker pattern GRID : a grid with thin lines LOCAL_CHECK : a checkboard over a radial colormap, centered around ( 0 , 0 ) LOCAL_RAD : distance stripes over a radial colormap, centered around ( 0 , 0 ) The function SurfaceParameterizationQuantity :: setStyle ( ParamVizStyle newStyle ) can be used to programmatically change the style. Types The enum class ParamCoordsType has options that control how parameter coordinates are interpreted: UNIT : UV coords are assumed to lie on the [ 0 , 1 ] interval WORLD : UV coords are assumed to be scaled like the world-space positions of the mesh These enums can be passed as an optional third argument when a parameterization is registered.","title":"Parameterization Quantities"},{"location":"structures/surface_mesh/parameterization_quantities/#adding","text":"SurfaceMesh :: addParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the corners of a mesh. coords is the array of 2D UV coordinates at corners. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of corners in the mesh. SurfaceMesh :: addVertexParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh. SurfaceMesh :: addLocalParameterizationQuantity ( std :: string name , const T & coords ) Add a new parameterization quantity to the structure, defined at the vertices of a mesh. this is similar to addVertexParameterizationQuantity , but has preset settings for style and type which are suitable for local parameterizations about a point. coords is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of float -valued 2-vectors. The length should be the number of vertices in the mesh.","title":"Adding"},{"location":"structures/surface_mesh/parameterization_quantities/#options","text":"","title":"Options"},{"location":"structures/surface_mesh/parameterization_quantities/#styles","text":"Several styles are available for how a parameterization is displayed. The enum class ParamVizStyle has options for how parameterizations are visualized: CHECKER : a two-color checker pattern GRID : a grid with thin lines LOCAL_CHECK : a checkboard over a radial colormap, centered around ( 0 , 0 ) LOCAL_RAD : distance stripes over a radial colormap, centered around ( 0 , 0 ) The function SurfaceParameterizationQuantity :: setStyle ( ParamVizStyle newStyle ) can be used to programmatically change the style.","title":"Styles"},{"location":"structures/surface_mesh/parameterization_quantities/#types","text":"The enum class ParamCoordsType has options that control how parameter coordinates are interpreted: UNIT : UV coords are assumed to lie on the [ 0 , 1 ] interval WORLD : UV coords are assumed to be scaled like the world-space positions of the mesh These enums can be passed as an optional third argument when a parameterization is registered.","title":"Types"},{"location":"structures/surface_mesh/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the elements of a surface mesh. Example : visualizing cotangent weights at edges with geometry-central #include \"geometrycentral/surface/vertex_position_geometry.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" polyscope :: init (); // Load mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geom ; std :: tie ( mesh , geom ) = loadMesh ( args :: get ( inputFilename )); geom -> requireVertexPositions (); // Register the geometry-central mesh auto psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , geom -> vertexPositions , mesh -> getFaceVertexList ()); psMesh -> setAllPermutations ( polyscopePermutations ( * mesh )); // set permutations, // so edge data is meaningful // Build cotan weights for the mesh geom -> requireEdgeCotanWeights (); // Visualize cotan weights psMesh -> addEdgeScalarQuantity ( \"edge cotan weights\" , geom -> edgeCotanWeights ); polyscope :: show (); Add scalars to elements SurfaceMesh :: addVertexScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the vertices of the mesh. values is the array of scalars at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addFaceScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the faces of the mesh. values is the array of scalars at faces. The type should be adaptable to a float scalar array. The length should be the number of faces in the mesh. SurfaceMesh :: addEdgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the edges of the mesh. values is the array of scalars at edges. The type should be adaptable to a float scalar array. The length should be the number of edges in the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. SurfaceMesh :: addHalfedgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the halfedges of the mesh. values is the array of scalars at halfedges. The type should be adaptable to a float scalar array. The length should be the number of halfedges in the mesh. Remember, before passing halfedge-valued data, be sure your indexing convention matches what Polyscope expects.","title":"Scalar Quantities"},{"location":"structures/surface_mesh/scalar_quantities/#add-scalars-to-elements","text":"SurfaceMesh :: addVertexScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the vertices of the mesh. values is the array of scalars at vertices. The type should be adaptable to a float scalar array. The length should be the number of vertices in the mesh. SurfaceMesh :: addFaceScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the faces of the mesh. values is the array of scalars at faces. The type should be adaptable to a float scalar array. The length should be the number of faces in the mesh. SurfaceMesh :: addEdgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the edges of the mesh. values is the array of scalars at edges. The type should be adaptable to a float scalar array. The length should be the number of edges in the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. SurfaceMesh :: addHalfedgeScalarQuantity ( std :: string name , const T & values , DataType type = DataType :: STANDARD ) Add a scalar quantity defined at the halfedges of the mesh. values is the array of scalars at halfedges. The type should be adaptable to a float scalar array. The length should be the number of halfedges in the mesh. Remember, before passing halfedge-valued data, be sure your indexing convention matches what Polyscope expects.","title":"Add scalars to elements"},{"location":"structures/surface_mesh/vector_quantities/","text":"Visualize vector-valued data at the elements of a surface mesh. Ambient vectors Ambient vectors are \u201cstandard\u201d vectors, which have X-Y-Z vector coordinates in world space. SurfaceMesh :: addVertexVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType :: AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addVertexVectorQuantity2D exists with the same signature. See 2D data . SurfaceMesh :: addFaceVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType :: AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addFaceVectorQuantity2D exists with the same signature. See 2D data . Tangent vectors Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element. Example: visualizing tangent vectors with geometry-central #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" polyscope :: init (); // Load mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Register the mesh with polyscope psMesh = polyscope :: registerSurfaceMesh ( \"mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh )); // Set vertex tangent spaces geometry -> requireVertexTangentBasis (); VertexData < Vector3 > vBasisX ( * mesh ); for ( Vertex v : mesh -> vertices ()) { vBasisX [ v ] = geometry -> vertexTangentBasis [ v ][ 0 ]; } polyscope :: getSurfaceMesh ( \"mesh\" ) -> setVertexTangentBasisX ( vBasisX ); // Make a vector field VertexData < Vector2 > vecField = /* some field */ // Register the field polyscope :: getSurfaceMesh ( \"mesh\" ) -> addVertexIntrinsicVectorQuantity ( \"great vectors\" , vecField ); polyscope :: show (); Specifying the tangent basis Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for mesh element. void SurfaceMesh :: setVertexTangentBasisX ( const T & vectors ) Specify the tangent coordinates at vertices, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each vertex. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. Note: As always for functions that take 3D vector inputs, there is a setVertexTangentBasisX2D with the same signature, which expects 2D vector inputs. See 2D data . void SurfaceMesh :: setFaceTangentBasisX ( const T & vectors ) Specify the tangent coordinates at faces, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each face. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. Note: As always for functions that take 3D vector inputs, there is a setFaceTangentBasisX2D with the same signature, which expects vector 2D inputs. See 2D data . Adding intrinsic tangent vectors In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh :: addVertexIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 2-vector array of float s. The length should be the number of vertices in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh :: vertexTangentSpaces . These tangent spaces can be manually specified as described above. SurfaceMesh :: addFaceIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 2-vector array of float s. The length should be the number of faces in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh :: facesTangentSpaces . These tangent spaces can be manually specified as described above. One forms One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh :: addOneFormIntrinsicVectorQuantity ( std :: string name , const T & data , const O & orientations ) Add a one-form quantity via a scalar at edges, which will be shown like a vector field. data is the array of scalars at edges. The type should be adaptable to an array of float s. The length should be the number of edges in the mesh. orientations 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. This input is an array of booleans at edges. The type should be adaptable to an array of char s (because std :: vector < bool > is broken). The length should be the number of edges in the mesh. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects.","title":"Vector Quantities"},{"location":"structures/surface_mesh/vector_quantities/#ambient-vectors","text":"Ambient vectors are \u201cstandard\u201d vectors, which have X-Y-Z vector coordinates in world space. SurfaceMesh :: addVertexVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType :: AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addVertexVectorQuantity2D exists with the same signature. See 2D data . SurfaceMesh :: addFaceVectorQuantity ( std :: string name , const T & vectors ) Add a vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. vectorType indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing VectorType :: AMBIENT ensures vectors have the proper world-space length. Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), addFaceVectorQuantity2D exists with the same signature. See 2D data .","title":"Ambient vectors"},{"location":"structures/surface_mesh/vector_quantities/#tangent-vectors","text":"Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element. Example: visualizing tangent vectors with geometry-central #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" polyscope :: init (); // Load mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Register the mesh with polyscope psMesh = polyscope :: registerSurfaceMesh ( \"mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList (), polyscopePermutations ( * mesh )); // Set vertex tangent spaces geometry -> requireVertexTangentBasis (); VertexData < Vector3 > vBasisX ( * mesh ); for ( Vertex v : mesh -> vertices ()) { vBasisX [ v ] = geometry -> vertexTangentBasis [ v ][ 0 ]; } polyscope :: getSurfaceMesh ( \"mesh\" ) -> setVertexTangentBasisX ( vBasisX ); // Make a vector field VertexData < Vector2 > vecField = /* some field */ // Register the field polyscope :: getSurfaceMesh ( \"mesh\" ) -> addVertexIntrinsicVectorQuantity ( \"great vectors\" , vecField ); polyscope :: show ();","title":"Tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#specifying-the-tangent-basis","text":"Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for mesh element. void SurfaceMesh :: setVertexTangentBasisX ( const T & vectors ) Specify the tangent coordinates at vertices, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each vertex. The type should be adaptable to a 3-vector array of float s. The length should be the number of vertices in the mesh. Note: As always for functions that take 3D vector inputs, there is a setVertexTangentBasisX2D with the same signature, which expects 2D vector inputs. See 2D data . void SurfaceMesh :: setFaceTangentBasisX ( const T & vectors ) Specify the tangent coordinates at faces, by giving the direction of the x-axis of the basis. vectors is an array of one 3D vector at each face. The type should be adaptable to a 3-vector array of float s. The length should be the number of faces in the mesh. Note: As always for functions that take 3D vector inputs, there is a setFaceTangentBasisX2D with the same signature, which expects vector 2D inputs. See 2D data .","title":"Specifying the tangent basis"},{"location":"structures/surface_mesh/vector_quantities/#adding-intrinsic-tangent-vectors","text":"In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh :: addVertexIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the vertices of the mesh. vectors is the array of vectors at vertices. The type should be adaptable to a 2-vector array of float s. The length should be the number of vertices in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh :: vertexTangentSpaces . These tangent spaces can be manually specified as described above. SurfaceMesh :: addFaceIntrinsicVectorQuantity ( std :: string name , const T & vectors , int nSym = 1 ) Add a tangent vector quantity defined at the faces of the mesh. vectors is the array of vectors at faces. The type should be adaptable to a 2-vector array of float s. The length should be the number of faces in the mesh. nSym is a symmetry order for visualization line field (n = 2) and cross field (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. The vectors will be interpreted in the basis of SurfaceMesh :: facesTangentSpaces . These tangent spaces can be manually specified as described above.","title":"Adding intrinsic tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#one-forms","text":"One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh :: addOneFormIntrinsicVectorQuantity ( std :: string name , const T & data , const O & orientations ) Add a one-form quantity via a scalar at edges, which will be shown like a vector field. data is the array of scalars at edges. The type should be adaptable to an array of float s. The length should be the number of edges in the mesh. orientations 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. This input is an array of booleans at edges. The type should be adaptable to an array of char s (because std :: vector < bool > is broken). The length should be the number of edges in the mesh. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects.","title":"One forms"}]}