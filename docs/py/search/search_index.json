{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polyscope is a C++/Python viewer and user interface for 3D data, like meshes and point clouds. Scientists, engineers, artists, and hackers can use Polyscope to prototype algorithms\u2014it is designed to easily integrate with existing codebases and popular libraries. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code. Polyscope uses a paradigm of structures and quantities . A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field. When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling visibility, color-mapping data and adjusting maps, \u201cpicking\u201d to click in the scene and query numerical quantities, etc. Note: There are two variants of this documentation, for C++ and Python. Use the buttons on the top bar to change language. A simple workflow for visualizing data in Polyscope looks like: C++ #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" // Initialize polyscope polyscope :: init (); // Register a point cloud // `points` is a Nx3 array-like container of points polyscope :: registerPointCloud ( \"my points\" , points ) // Register a surface mesh structure // `meshVerts` is a Vx3 array-like container of vertex positions // `meshFaces` is a Fx3 array-like container of face indices polyscope :: registerSurfaceMesh ( \"my mesh\" , meshVerts , meshFaces ); // Add a scalar and a vector function defined on the mesh // `scalarQuantity` is a length V array-like container of values // `vectorQuantity` is an Fx3 array-like container of vectors per face polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addVertexScalarQuantity ( \"my_scalar\" , scalarQuantity ); polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addFaceVectorQuantity ( \"my_vector\" , vectorQuantity ); // View the point cloud and mesh we just registered in the 3D UI polyscope :: show (); Python import polyscope as ps # Initialize polyscope ps . init () ### Register a point cloud # `my_points` is a Nx3 numpy array ps . register_point_cloud ( \"my points\" , my_points ) ### Register a mesh # `verts` is a Nx3 numpy array of vertex positions # `faces` is a Fx3 array of indices, or a nested list ps . register_surface_mesh ( \"my mesh\" , verts , faces , smooth_shade = True ) # Add a scalar function and a vector function defined on the mesh # vertex_scalar is a length V numpy array of values # face_vectors is an Fx3 array of vectors per face ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"my_scalar\" , vertex_scalar , defined_on = 'vertices' , cmap = 'blues' ) ps . get_surface_mesh ( \"my mesh\" ) . add_vector_quantity ( \"my_vector\" , face_vectors , defined_on = 'faces' , color = ( 0.2 , 0.5 , 0.5 )) # View the point cloud and mesh we just registered in the 3D UI ps . show () Polyscope is designed to make your life easier. It is simple to build, and fewer than 10 lines of code should be sufficient to start visualizing. In C++, some template magic means Polyscope can probably accept the data types you\u2019re already using! Author: Nicholas Sharp If Polyscope contributes to an academic publication, cite it as: @misc { polyscope , title = {Polyscope} , author = {Nicholas Sharp and others} , note = {www.polyscope.run} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"about/bindings/","text":"Python bindings Warning Python bindings are in the works! Check back soon.","title":"Bindings"},{"location":"about/bindings/#python-bindings","text":"Warning Python bindings are in the works! Check back soon.","title":"Python bindings"},{"location":"about/contributing/","text":"Polyscope is an open-source project, and you are encouraged to contribute! Polyscope is first and foremost a C++ library; these Python bindings are just wrappers. Any significant new features should first be implemented in C++, then wrapped in Python. A few high-level guidelines: All contributions must be released under Polyscope\u2019s MIT license. Significant new features need to be documented! This documentation lives in polyscope-docs . You can and should submit a request there at the same time as adding code to Polyscope. The documentation uses markdown. Modifying the docs amounts to editing a source file and rebuilding the site source. The the nodes there in README.md . To add a new page to the documentation, edit mkdocs.yml . Be sure to run the unit tests and add tests for any new features. Add a blurb to the release notes ! We\u2019ll expand these guidelines as Polyscope grows.","title":"Contributing"},{"location":"about/contributors/","text":"This page lists people who have contributed something to Polyscope, in no particular order. Thank you so much for you work! If you would like to be listed on this page, don\u2019t hesitate to ask. Nicholas Sharp Keenan Crane Yousuf Soliman Rohan Sawhney Chris Yu Mark Gillespie Connor Lin","title":"Contributors"},{"location":"about/dependencies/","text":"Polyscope stands on the shoulders of many outstanding open-source projects. These dependencies are all permissively licensed , and bundled with the project ; we just list them here to give due credit! Name Purpose Link GLFW Window and input management with openGL glfw.org Dear ImGui GUI interface (buttons, text boxes, etc) github.com/ocornut/imgui glad OpenGL loader (used on Windows/Linux) github.com/Dav1dde/glad glm Vector math and glsl utilities glm.g-truc.net stb Header-only libraries, esp. image loading github.com/nothings/stb json Read/write json text github.com/nlohmann/json mkdocs Doc generation mkdocs.org mkdocs-material Doc generation squidfunk.github.io/mkdocs-material/ googletest Unit testing github.com/google/googletest pybind11 (Python only) Python bindings github.com/pybind/pybind11 Eigen (Python only) numpy interop for bindings eigen.tuxfamily.org Additionally, Polyscope includes a few public-domain / permissively licensed assets. Some of the built-in matcaps are from the Blender project, and others were rendered using Blender. The built-in colormaps come from several sources as detailed on the colormap page , including Smith et. al. , cmocean , and matplotlib . The concrete texture on the ground is from cc0textures.com . Thank you, artists!","title":"Dependencies"},{"location":"about/license/","text":"The core Polyscope C++ library is released under an MIT license , and all of its dependencies are under similar permissive licenses (MIT, zlib, or public domain). These Python bindings are also released under an MIT license . The python bindings are generated using pybind11 , which is under a BSD 3-clause license, and Eigen , which is licensed under MPL2; again, these are permissive licenses. Polyscope is created and maintained by academics: citations let us know our work is having impact! Please cite Polyscope or otherwise give a shout-out if and when it contributes to published works. @misc { polyscope , title = {Polyscope} , author = {Nicholas Sharp and others} , note = {www.polyscope.run} , year = {2019} }","title":"License"},{"location":"about/release_notes/","text":"Release notes v0.1.0 Apr 11, 2020: Initial release of Python bindings. Bindings at cpp version v1.1 .","title":"Release notes"},{"location":"about/release_notes/#release-notes","text":"v0.1.0 Apr 11, 2020: Initial release of Python bindings. Bindings at cpp version v1.1 .","title":"Release notes"},{"location":"basics/camera_controls/","text":"These settings affect the 3D camera view in polyscope. It is often convenient to set them just before calling polyscope.init() , but they may generally be set anywhere. import polyscope as ps ps . set_navigation_style ( \"free\" ) ps . set_up_dir ( \"z_up\" ) # initialize ps . init () Options set_navigation_style ( s ) navigation style The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse. This value can be manually set under the view menu of the ui. Programmatically, pass a string for the following settings: 'turntable' The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions. 'free' The camera is free to take any orientation, rotation is always about relative to the current camera. 'planar' The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data ). Default: 'turntable' . Example: import polyscope as ps ps . set_navigation_style ( \"free\" ) set_up_dir ( s ) up direction 3D data is typically oriented with some natural \u201cup\u201d direction, but not everyone agrees as to which coordinate axis is \u201cup\u201d. Computer graphics and vision often use a Y-up convention, where science and engineering more commonly use Z-up. This setting affects default orientation of the view, the behavior of some navigation styles (esp. turntable ), and the orientation of the ground plane. This value can be manually set under the view menu of the ui. Programmatically, the setting strings are: 'x_up' The positive X-axis is up. 'y_up' The positive Y-axis is up. 'z_up' The positive Z-axis is up. Default: 'y_up' . Example: import polyscope as ps ps . set_up_dir ( \"z_up\" )","title":"Camera Controls"},{"location":"basics/camera_controls/#options","text":"set_navigation_style ( s )","title":"Options"},{"location":"basics/camera_controls/#navigation-style","text":"The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse. This value can be manually set under the view menu of the ui. Programmatically, pass a string for the following settings: 'turntable' The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions. 'free' The camera is free to take any orientation, rotation is always about relative to the current camera. 'planar' The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data ). Default: 'turntable' . Example: import polyscope as ps ps . set_navigation_style ( \"free\" ) set_up_dir ( s )","title":"navigation style"},{"location":"basics/camera_controls/#up-direction","text":"3D data is typically oriented with some natural \u201cup\u201d direction, but not everyone agrees as to which coordinate axis is \u201cup\u201d. Computer graphics and vision often use a Y-up convention, where science and engineering more commonly use Z-up. This setting affects default orientation of the view, the behavior of some navigation styles (esp. turntable ), and the orientation of the ground plane. This value can be manually set under the view menu of the ui. Programmatically, the setting strings are: 'x_up' The positive X-axis is up. 'y_up' The positive Y-axis is up. 'z_up' The positive Z-axis is up. Default: 'y_up' . Example: import polyscope as ps ps . set_up_dir ( \"z_up\" )","title":"up direction"},{"location":"basics/initializing/","text":"Initializing Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: import polyscope as ps # Initialize polyscope, creating graphics contexts and constructing a window. # Should be called exactly once. ps . init () # Build visualizations, here or in distant code # ... # ... # ... # Pass control flow to polyscope, displaying the interactive window. # Function will return when user closes the window. ps . show () # More of your code # ... # Show again. Data is preserved between calls to show() # unless explicitly removed. ps . show () Functions init() init() Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show() show() Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window. This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to show() .","title":"Initializing"},{"location":"basics/initializing/#initializing","text":"Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: import polyscope as ps # Initialize polyscope, creating graphics contexts and constructing a window. # Should be called exactly once. ps . init () # Build visualizations, here or in distant code # ... # ... # ... # Pass control flow to polyscope, displaying the interactive window. # Function will return when user closes the window. ps . show () # More of your code # ... # Show again. Data is preserved between calls to show() # unless explicitly removed. ps . show ()","title":"Initializing"},{"location":"basics/initializing/#functions","text":"init()","title":"Functions"},{"location":"basics/initializing/#init","text":"Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show()","title":"init()"},{"location":"basics/initializing/#show","text":"Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window. This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to show() .","title":"show()"},{"location":"basics/parameters/","text":"Many structures and quantities in Polyscope have optional values which can be set to control their appearance or behavior, such as the radius of points in a point cloud or the color of a mesh. These values can generally be manually adjusted in the GUI, or set programmatically in code. This page documents special features in Polyscope which provide extra functionality while setting these parameters. Persistent values In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values . Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match. Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) ps_cloud . set_color (( 0.5 , 0.5 , 0.5 )) # the persistent value is recorded in the cache # ... later ... new_cloud = ps . register_point_cloud ( \"my cloud\" , new_points ); # new_cloud will automatically pick up the pointColor we set above, # since this point cloud has the same name Note that this persistence behavior applies even when variables are manually manipulated in the GUI. Scaled values Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. Many Polyscope parameters take a relative option, which is usually True by default, to set lengths relatively. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) # radius will be 0.05 * lengthScale when used ps_cloud -> set_radius ( 0.05 ); ps_cloud -> set_radius ( 0.05 , relative = True ); # same as previous (default is True) However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use. # radius will be 1.6 when used ps_cloud -> set_radius ( 1.6 , relative = False ) Note that scaled values can be (and often are) used as persistent values , as described above; the two concepts are complementary.","title":"Parameters"},{"location":"basics/parameters/#persistent-values","text":"In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values . Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match. Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) ps_cloud . set_color (( 0.5 , 0.5 , 0.5 )) # the persistent value is recorded in the cache # ... later ... new_cloud = ps . register_point_cloud ( \"my cloud\" , new_points ); # new_cloud will automatically pick up the pointColor we set above, # since this point cloud has the same name Note that this persistence behavior applies even when variables are manually manipulated in the GUI.","title":"Persistent values"},{"location":"basics/parameters/#scaled-values","text":"Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. Many Polyscope parameters take a relative option, which is usually True by default, to set lengths relatively. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) # radius will be 0.05 * lengthScale when used ps_cloud -> set_radius ( 0.05 ); ps_cloud -> set_radius ( 0.05 , relative = True ); # same as previous (default is True) However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use. # radius will be 1.6 when used ps_cloud -> set_radius ( 1.6 , relative = False ) Note that scaled values can be (and often are) used as persistent values , as described above; the two concepts are complementary.","title":"Scaled values"},{"location":"basics/program_options/","text":"These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling polyscope.init() , but they may generally be set anywhere. import polyscope as ps # a few options ps . set_program_name ( \"important app\" ) ps . set_verbosity ( 0 ) ps . set_use_prefs_file ( False ) # initialize ps . init () Options set_program_name ( name ) program name A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: import polyscope as ps ps . set_program_name ( \"important app\" ) set_verbosity ( v ) verbosity How much useful info should polyscope print to stdout? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: import polyscope as ps ps . set_verbosity ( 0 ) set_print_prefix ( p ) print prefix A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: import polyscope as ps ps . set_print_prefix ( \"[MYAPP] \" ); # prints now look like \"[MYAPP] loaded openGL\" set_errors_throw_exceptions ( b ) errors throw execptions If true, errors in polyscope raise execptions. If false, a polyscope error is shown in the UI, but processing attempts to continue. Default: False . set_max_fps ( f ) max fps The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . set_use_prefs_file ( b ) use prefs file Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If False , if will be neither written nor read. Default: True . set_always_redraw ( b ) always redraw Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is True , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: False .","title":"Program Options"},{"location":"basics/program_options/#options","text":"set_program_name ( name )","title":"Options"},{"location":"basics/program_options/#program-name","text":"A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: import polyscope as ps ps . set_program_name ( \"important app\" ) set_verbosity ( v )","title":"program name"},{"location":"basics/program_options/#verbosity","text":"How much useful info should polyscope print to stdout? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: import polyscope as ps ps . set_verbosity ( 0 ) set_print_prefix ( p )","title":"verbosity"},{"location":"basics/program_options/#print-prefix","text":"A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: import polyscope as ps ps . set_print_prefix ( \"[MYAPP] \" ); # prints now look like \"[MYAPP] loaded openGL\" set_errors_throw_exceptions ( b )","title":"print prefix"},{"location":"basics/program_options/#errors-throw-execptions","text":"If true, errors in polyscope raise execptions. If false, a polyscope error is shown in the UI, but processing attempts to continue. Default: False . set_max_fps ( f )","title":"errors throw execptions"},{"location":"basics/program_options/#max-fps","text":"The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . set_use_prefs_file ( b )","title":"max fps"},{"location":"basics/program_options/#use-prefs-file","text":"Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If False , if will be neither written nor read. Default: True . set_always_redraw ( b )","title":"use prefs file"},{"location":"basics/program_options/#always-redraw","text":"Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is True , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: False .","title":"always redraw"},{"location":"basics/scene_options/","text":"These are settings which affect the visual display of the scene. It is often convenient to set them just before calling polyscope.init() , but they may generally be set anywhere. import polyscope as ps # enable auto centering and scaling ps . set_autocenter_structures ( True ) ps . set_autoscale_structures ( True ) # initialize ps . init () set_autocenter_structures ( b ) autocenter structures If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: False . set_autoscale_structures ( b ) autoscale structures If true, all structures will have their transform set to rescale their length to 1 immediately after being registered. This scales the content nicely in view, but obscures any important absolute world positions. Default: False .","title":"Scene Options"},{"location":"basics/scene_options/#autocenter-structures","text":"If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: False . set_autoscale_structures ( b )","title":"autocenter structures"},{"location":"basics/scene_options/#autoscale-structures","text":"If true, all structures will have their transform set to rescale their length to 1 immediately after being registered. This scales the content nicely in view, but obscures any important absolute world positions. Default: False .","title":"autoscale structures"},{"location":"features/2D_data/","text":"Polyscope is primarily focused on 3D data, but can also be used for 2D visualization. This section descibes a few helpers which make it easier to do so. Adding 2D data Functions which accept 3D positions (or vectors) as input can alternately takes 2D positions, and append a 0 z-coordinate. In Python (unlike the C++ api), we can use 2D data by simply passing it as the argument of a function which would otherwise take 3D data. For instance, register_point_cloud(name, data) normally expects data to be a Nx3 array of 3D positions, but passing an Nx2 array also works just fine. Any other functions which don\u2019t take 3D positions can be used as normal, like add_scalar_quantity() . Planar camera mode The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: ps.set_navigation_style(\"planar\")","title":"2D Data"},{"location":"features/2D_data/#adding-2d-data","text":"Functions which accept 3D positions (or vectors) as input can alternately takes 2D positions, and append a 0 z-coordinate. In Python (unlike the C++ api), we can use 2D data by simply passing it as the argument of a function which would otherwise take 3D data. For instance, register_point_cloud(name, data) normally expects data to be a Nx3 array of 3D positions, but passing an Nx2 array also works just fine. Any other functions which don\u2019t take 3D positions can be used as normal, like add_scalar_quantity() .","title":"Adding 2D data"},{"location":"features/2D_data/#planar-camera-mode","text":"The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: ps.set_navigation_style(\"planar\")","title":"Planar camera mode"},{"location":"features/color_maps/","text":"Built-in color maps Different color maps are appropriate for different situations: sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below). diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases 0 semantially means \u201cnothing\u201d, and the endpoints have opposite meaning. cyclic maps data defined on the circle, like an angle decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes Polyscope supports the following built-in color maps: Name Type String Key viridis sequential viridis blues sequential blues reds sequential reds coolwarm diverging coolwarm pink-green diverging pink-green phase cyclic phase spectral decorative spectral rainbow decorative rainbow jet decorative jet Loading custom color maps Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from [Appearance] --> [Color maps] --> [Load color map] , or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting stb_image can read). load_color_map ( cmap_name , filename ) load_color_map Load a new colormap from the image file filename , which will be assigned the name cmap_name . Example: import polyscope as ps ps . load_color_map ( \"fancy cmap\" , \"my_cmap.png\" ) Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9 Phase is from the cmocean package. link \u21a9 The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib . \u21a9","title":"Color Maps"},{"location":"features/color_maps/#built-in-color-maps","text":"Different color maps are appropriate for different situations: sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below). diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases 0 semantially means \u201cnothing\u201d, and the endpoints have opposite meaning. cyclic maps data defined on the circle, like an angle decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes Polyscope supports the following built-in color maps: Name Type String Key viridis sequential viridis blues sequential blues reds sequential reds coolwarm diverging coolwarm pink-green diverging pink-green phase cyclic phase spectral decorative spectral rainbow decorative rainbow jet decorative jet","title":"Built-in color maps"},{"location":"features/color_maps/#loading-custom-color-maps","text":"Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from [Appearance] --> [Color maps] --> [Load color map] , or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting stb_image can read). load_color_map ( cmap_name , filename )","title":"Loading custom color maps"},{"location":"features/color_maps/#load_color_map","text":"Load a new colormap from the image file filename , which will be assigned the name cmap_name . Example: import polyscope as ps ps . load_color_map ( \"fancy cmap\" , \"my_cmap.png\" ) Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9 Phase is from the cmocean package. link \u21a9 The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib . \u21a9","title":"load_color_map"},{"location":"features/materials/","text":"Polyscope uses matcaps to render the appearance of objects in the scene, as opposed to more traditional configurations of lights and shading models, etc. A matcap is a small image of a material, which is sampled by the renderer to query the materials\u2019 appearance from a some angle. Scene information like lighting is implicitly baked in to the matcap image. Most objects in Polyscope (surface meshes, point clouds, vectors, etc) expose a material = 'matname' option to choose a material for the object\u2019s appearance. Additionally, materials can generally be set in the UI from [Options] --> [Material] . Blended materials In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities). Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps. How it works Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components. At runtime, to generate a color from a triple of rgb values each in the range [0,1] , we sample the images like: outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color. Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space. Materials which which support this blending are denoted by (rgb) in the options menu. Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options. Built-in materials Polyscope supports the following built-in materials: Name String Key Blendable Image clay clay yes wax wax yes candy candy yes flat flat yes mud 1 mud no ceramic 1 ceramic no jade 1 jade no normal 1 normal no Loading custom materials Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from [Appearance] --> [Materials] --> [Load material] , or programatically using the function below. For blendable matcaps, if the single filename mat.hdr is given, Polyscope will try to load mat_r.hdr , mat_g.hdr , etc. Ideally, matcap images should be linear .hdr images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with intensity=1 and gamma=2.2 before use. Most common image formats are accepted (anything stb_image can read). load_static_material ( mat_name , filename ) load_static_material Load a new static (non-blendable) material from a single image file filename . The new material will be called mat_nam . Example: import polyscope as ps ps . load_static_material ( \"fancy mat\" , \"my_image.png\" ) load_blendable_material ( mat_name , filenames = None , filename_base = None , filename_ext = None ) load_blendable_material Load a new blendable material, which will be called matName . There are two different ways to specify which files to load the material images from: Specify filenames , a tuple of four string filenames corresponding to red, green, blue, and black basis materials Specify filename_base , and filename_ext , to generate the four filenames as filename_base + \"_r\" + filename_ext , etc. Example: import polyscope as ps ps . load_blendable_material ( \"fancy blendable mat\" , filenames = ( \"my_image_r.png\" , \"my_image_g.png\" , \"my_image_b.png\" , \"my_image_k.png\" )) # OR ps . load_blendable_material ( \"fancy blendable mat\" , filename_base = \"my_image\" , filename_ext = \".png\" ) The matcaps are from the Blender matcap repository, available under a CC0/public domain license . Thanks to the Blender community for contributing them! \u21a9 \u21a9 \u21a9 \u21a9","title":"Materials"},{"location":"features/materials/#blended-materials","text":"In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities). Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps. How it works Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components. At runtime, to generate a color from a triple of rgb values each in the range [0,1] , we sample the images like: outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color. Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space. Materials which which support this blending are denoted by (rgb) in the options menu. Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options.","title":"Blended materials"},{"location":"features/materials/#built-in-materials","text":"Polyscope supports the following built-in materials: Name String Key Blendable Image clay clay yes wax wax yes candy candy yes flat flat yes mud 1 mud no ceramic 1 ceramic no jade 1 jade no normal 1 normal no","title":"Built-in materials"},{"location":"features/materials/#loading-custom-materials","text":"Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from [Appearance] --> [Materials] --> [Load material] , or programatically using the function below. For blendable matcaps, if the single filename mat.hdr is given, Polyscope will try to load mat_r.hdr , mat_g.hdr , etc. Ideally, matcap images should be linear .hdr images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with intensity=1 and gamma=2.2 before use. Most common image formats are accepted (anything stb_image can read). load_static_material ( mat_name , filename )","title":"Loading custom materials"},{"location":"features/materials/#load_static_material","text":"Load a new static (non-blendable) material from a single image file filename . The new material will be called mat_nam . Example: import polyscope as ps ps . load_static_material ( \"fancy mat\" , \"my_image.png\" ) load_blendable_material ( mat_name , filenames = None , filename_base = None , filename_ext = None )","title":"load_static_material"},{"location":"features/materials/#load_blendable_material","text":"Load a new blendable material, which will be called matName . There are two different ways to specify which files to load the material images from: Specify filenames , a tuple of four string filenames corresponding to red, green, blue, and black basis materials Specify filename_base , and filename_ext , to generate the four filenames as filename_base + \"_r\" + filename_ext , etc. Example: import polyscope as ps ps . load_blendable_material ( \"fancy blendable mat\" , filenames = ( \"my_image_r.png\" , \"my_image_g.png\" , \"my_image_b.png\" , \"my_image_k.png\" )) # OR ps . load_blendable_material ( \"fancy blendable mat\" , filename_base = \"my_image\" , filename_ext = \".png\" ) The matcaps are from the Blender matcap repository, available under a CC0/public domain license . Thanks to the Blender community for contributing them! \u21a9 \u21a9 \u21a9 \u21a9","title":"load_blendable_material"},{"location":"features/messages/","text":"Using messages We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: import polyscope as ps ps . init () # Generate a single warning. # Has no effect on the GUI until polyscope gets control flow # back, which happens here in the show() call below. ps . warning ( \"Something went slightly wrong\" ) # Generate a lot of warnings. Becase all of these warnings # have the same base message (the first string), they will # be batched together and only shown as one dialog. The detail # message for the first such warning will also be shown. for i in range ( 5000 ): ps . warning ( \"Some problems come in groups\" , \"some details: \" + str ( i )) # The previous warnings would be displayed here ps . show () # Generating an error. # The UI will block and show this error immediately. After # the error is dismissed, the call will return. ps . error ( \"Resistance is futile.\" ); Messages info ( message ) info Simply logs a message to stdout . warning ( message , detail = \"\" ) warning Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detail field need not be used. However, if issuing warnings in a loop, warnings with the same base message are batched together, so the UI doesn\u2019t get completely overwhelmed (see example above). error ( message ) error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns.","title":"Messages"},{"location":"features/messages/#using-messages","text":"We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: import polyscope as ps ps . init () # Generate a single warning. # Has no effect on the GUI until polyscope gets control flow # back, which happens here in the show() call below. ps . warning ( \"Something went slightly wrong\" ) # Generate a lot of warnings. Becase all of these warnings # have the same base message (the first string), they will # be batched together and only shown as one dialog. The detail # message for the first such warning will also be shown. for i in range ( 5000 ): ps . warning ( \"Some problems come in groups\" , \"some details: \" + str ( i )) # The previous warnings would be displayed here ps . show () # Generating an error. # The UI will block and show this error immediately. After # the error is dismissed, the call will return. ps . error ( \"Resistance is futile.\" );","title":"Using messages"},{"location":"features/messages/#messages","text":"info ( message )","title":"Messages"},{"location":"features/messages/#info","text":"Simply logs a message to stdout . warning ( message , detail = \"\" )","title":"info"},{"location":"features/messages/#warning","text":"Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detail field need not be used. However, if issuing warnings in a loop, warnings with the same base message are batched together, so the UI doesn\u2019t get completely overwhelmed (see example above). error ( message )","title":"warning"},{"location":"features/messages/#error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns.","title":"error"},{"location":"features/screenshots/","text":"Taking screenshots Polyscope includes simple functionality for saving screenshots of the UI to disk. The imGUI windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [screenshot] button in the options UI window, or programmatically using the functions below. Clicking the UI button is equivalent to calling screenshot() below, generating a numbered screenshot file in the current directory. screenshot ( filename = None , transparentBG = True ) Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be one of .png , .tga , or .bmp . If no name is is given, screenshots are saved to the current directory, with file named like screenshot_000000.tga numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent.","title":"Screenshots"},{"location":"features/screenshots/#taking-screenshots","text":"Polyscope includes simple functionality for saving screenshots of the UI to disk. The imGUI windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [screenshot] button in the options UI window, or programmatically using the functions below. Clicking the UI button is equivalent to calling screenshot() below, generating a numbered screenshot file in the current directory. screenshot ( filename = None , transparentBG = True ) Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be one of .png , .tga , or .bmp . If no name is is given, screenshots are saved to the current directory, with file named like screenshot_000000.tga numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparentBG is true , the background will be rendered as transparent.","title":"Taking screenshots"},{"location":"features/user_callback/","text":"Not Available User-callback functionality is not currently exposed in Python bindings. Remember that you can always call show() , close the Polyscope window to continue executing your code, then call show() again later to view the scene again.","title":"User Callback"},{"location":"installing/","text":"Polyscope supports Python 2 and 3 on Linux, macOS, and Windows. At runtime, your environment must support OpenGL >= 3.3 core , and have the ability to open windows in a display. This includes nearly all modern desktop/laptop computers, but not all headless servers and virtual machines. Installing from PyPi python -m pip install polyscope Using python -m pip install rather than just pip install helps when your system has multiple version of Python installed, ensuring the correct pip is used. Just be sure python refers to the install of Python you intend to use. Ideally, this install will resolve to a precompiled wheel for your platform\u2014see troubleshooting if not. Otherwise, the setup script will compile the Polyscope C++ library from source, which may take a few minutes, and requires a suitable C++ toolchain (see building from source ). Troubleshooting On common platforms, pip should always be able to install from a binary .whl file. If it fails to select a binary wheel, it will try to compile from source, leading to long install times or compilation errors if your toolchain is not configured. Here are some common fixes: Ensure you\u2019re targeting the latest Polyscope python -m pip install polyscope --upgrade Very old versions of pip may not be able to use the precompiled wheels. Upgrade pip with python -m pip install pip --upgrade . Precompiled wheels are available on pip for Python 2.7 and 3.5-3.8 (aka most common versions), check yours with python --version , and update your Python install if needed. Installing from Conda conda install -c conda-forge polyscope Note Python 2.7 builds on conda may have dependency problems (a false dependency on Python 3); the issue will be resolved soon. Remember that that you can still use pip in conjuction with conda, like python -m pip install polyscope . Installing manually To manually download the sources: git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py Polyscope can then by installed with pip as python -m pip install . Or manually installed with the setup script using python setup.py install Building from source If a pre-compiled wheel is not available, the setup scripts (either run automatically via pip or manually with setup.py ) will need to compile the underlying C++ library. Your system must have a suitable C++ compiler available to build Polyscope, as well as build tools like CMake installed. The Polyscope C++ repository has a few more details about compiling. Polyscope is a 3D graphics program, so it may be difficult to build on servers without graphics support, or extremely old machines. In particular, OpenGL >= 3.3 core is a strict requirement. Development builds To compile Polyscope locally without setup.py (e.g., if you are developing the library) use git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py mkdir build && cd build cmake .. make -j4 this will generate a file something like polyscope_bindings.cpython-36m-x86_64-linux-gnu.so (the particular name depends on your platform), which contains the low-level bindings to C++ Polyscope. This is a pybind11 build; it can be further customized using any pybind11 CMake options, for instance to choose which version of Python is used. The actual Polyscope python library lives in src/polyscope , which is a wrapper around these low-level bindings. You are now ready to import polyscope , so long as both the compiled bindings and src/polyscope can be found on your PYTHONPATH .","title":"Installing"},{"location":"installing/#installing-from-pypi","text":"python -m pip install polyscope Using python -m pip install rather than just pip install helps when your system has multiple version of Python installed, ensuring the correct pip is used. Just be sure python refers to the install of Python you intend to use. Ideally, this install will resolve to a precompiled wheel for your platform\u2014see troubleshooting if not. Otherwise, the setup script will compile the Polyscope C++ library from source, which may take a few minutes, and requires a suitable C++ toolchain (see building from source ).","title":"Installing from PyPi"},{"location":"installing/#troubleshooting","text":"On common platforms, pip should always be able to install from a binary .whl file. If it fails to select a binary wheel, it will try to compile from source, leading to long install times or compilation errors if your toolchain is not configured. Here are some common fixes: Ensure you\u2019re targeting the latest Polyscope python -m pip install polyscope --upgrade Very old versions of pip may not be able to use the precompiled wheels. Upgrade pip with python -m pip install pip --upgrade . Precompiled wheels are available on pip for Python 2.7 and 3.5-3.8 (aka most common versions), check yours with python --version , and update your Python install if needed.","title":"Troubleshooting"},{"location":"installing/#installing-from-conda","text":"conda install -c conda-forge polyscope Note Python 2.7 builds on conda may have dependency problems (a false dependency on Python 3); the issue will be resolved soon. Remember that that you can still use pip in conjuction with conda, like python -m pip install polyscope .","title":"Installing from Conda"},{"location":"installing/#installing-manually","text":"To manually download the sources: git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py Polyscope can then by installed with pip as python -m pip install . Or manually installed with the setup script using python setup.py install","title":"Installing manually"},{"location":"installing/#building-from-source","text":"If a pre-compiled wheel is not available, the setup scripts (either run automatically via pip or manually with setup.py ) will need to compile the underlying C++ library. Your system must have a suitable C++ compiler available to build Polyscope, as well as build tools like CMake installed. The Polyscope C++ repository has a few more details about compiling. Polyscope is a 3D graphics program, so it may be difficult to build on servers without graphics support, or extremely old machines. In particular, OpenGL >= 3.3 core is a strict requirement.","title":"Building from source"},{"location":"installing/#development-builds","text":"To compile Polyscope locally without setup.py (e.g., if you are developing the library) use git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py mkdir build && cd build cmake .. make -j4 this will generate a file something like polyscope_bindings.cpython-36m-x86_64-linux-gnu.so (the particular name depends on your platform), which contains the low-level bindings to C++ Polyscope. This is a pybind11 build; it can be further customized using any pybind11 CMake options, for instance to choose which version of Python is used. The actual Polyscope python library lives in src/polyscope , which is a wrapper around these low-level bindings. You are now ready to import polyscope , so long as both the compiled bindings and src/polyscope can be found on your PYTHONPATH .","title":"Development builds"},{"location":"structures/structure_management/","text":"A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) Then, in a distant part of your code, add a scalar function to it with: ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"some values\" , values ) This avoids the need to pass a reference to the structure you created around your entire codebase. Alternately, one can directly use the handle returned by register_surface_mesh() , instead of keying on a name string. The following structures available in Polyscope. Many more structures are in development! Surface Mesh Point Cloud Curve Network in progress : Camera View in progress : Tet Mesh Registering structures Each structure offers a register___(name, ...) function (like register_point_cloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a structure object which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. Accessing structures Polyscope offers two patterns for calling methods on a registered structure: you can either use the handle returned after structure creation, or refer to the structure by name. import polyscope as ps # register a structure ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # access with the handle ps_mesh . add_scalar_quantity ( \"some values\" , values ) # access by name ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"some values\" , values ) The former is concise and programmatic, while the latter avoids the need to keep track of a variable. As before, each structure offers a get___(name) method, like get_surface_mesh(name) which can be used to get a handle to the structure of that type by name. Removing structures If no longer needed, structures can be removed by name or by handle. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. import polyscope as ps # register a structure and some data ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . add_scalar_quantity ( \"some values\" , values ) # look at it ps . show () # (user exits ui) # remove the structure # (these two forms are equivalent, choose one) ps_mesh . remove () ps . remove_surface_mesh ( \"my_mesh\" ) # actually, just remove everything ps . remove_all_structures ()","title":"Structure Management"},{"location":"structures/structure_management/#registering-structures","text":"Each structure offers a register___(name, ...) function (like register_point_cloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a structure object which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions.","title":"Registering structures"},{"location":"structures/structure_management/#accessing-structures","text":"Polyscope offers two patterns for calling methods on a registered structure: you can either use the handle returned after structure creation, or refer to the structure by name. import polyscope as ps # register a structure ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # access with the handle ps_mesh . add_scalar_quantity ( \"some values\" , values ) # access by name ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"some values\" , values ) The former is concise and programmatic, while the latter avoids the need to keep track of a variable. As before, each structure offers a get___(name) method, like get_surface_mesh(name) which can be used to get a handle to the structure of that type by name.","title":"Accessing structures"},{"location":"structures/structure_management/#removing-structures","text":"If no longer needed, structures can be removed by name or by handle. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. import polyscope as ps # register a structure and some data ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . add_scalar_quantity ( \"some values\" , values ) # look at it ps . show () # (user exits ui) # remove the structure # (these two forms are equivalent, choose one) ps_mesh . remove () ps . remove_surface_mesh ( \"my_mesh\" ) # actually, just remove everything ps . remove_all_structures ()","title":"Removing structures"},{"location":"structures/curve_network/basics/","text":"Curve Networks Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point! Registering a curve network Curve network structures can be registered with Polyscope by passing the node position and edge indices. Polyscope also makes it easy to automatically construct lines and loops by just passing edges='line' or edges='loop' . Example: a network of random curves import numpy as np import polyscope as ps ps . init () # generate some random nodes and edges between them nodes = np . random . rand ( 100 , 3 ) edges = np . random . randint ( 0 , 100 , size = ( 250 , 2 )) # visualize! ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) ps . show () register_curve_network ( name , nodes , edges , enabled = None , radius = None , color = None , material = None ) Add a new curve network structure to Polyscope. name string, a name for the structure nodes , an Nx3 numpy float array of node locations (or Nx2 for 2D) edges , an Ex2 numpy integer array of edge connections, as 0-based indices in to the nodes array, OR the string line / loop , to generate node connectivity as a line or loop, respectively. Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the nodes and edges relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the network as rgb in [0,1] material string, name of material to use for network if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D node positions are also supported, see 2D data . Updating a curve network The locations of the nodes in a curve network can be updated with the member function update_node_positions(newPositions) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). CurveNetwork . update_node_positions ( newPos ) Update the node positions in a curve network structure. newPos must be valid input as to initially construct the nodes of the network, with the same number of nodes as the network curently has. Options Options control the appearance of the network . Note that these options can also be passed as keyword arguments to the initial register_curve_network() , as noted above. Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? is_enabled () set_enabled ( newVal = True ) yes radius size of rendered nodes/edges get_radius () set_radius ( newVal , relative = True ) yes color default color for the network get_color () set_color ( newVal ) yes material material for structure get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the curve network network = polyscope . register_curve_network ( \"my net\" , nodes , edges ) network . set_enabled ( False ) # disable network . set_enabled () # default is true network . set_radius ( 0.02 ) # radius is relative to a scene length scale by default network . set_radius ( 1.7 , relative = False ) # radius in absolute world units network . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] network . set_material ( \"candy\" ) # alternately: ps . register_curve_network ( \"my net 2\" , nodes , edges , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ))","title":"Basics"},{"location":"structures/curve_network/basics/#curve-networks","text":"Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point!","title":"Curve Networks"},{"location":"structures/curve_network/basics/#registering-a-curve-network","text":"Curve network structures can be registered with Polyscope by passing the node position and edge indices. Polyscope also makes it easy to automatically construct lines and loops by just passing edges='line' or edges='loop' . Example: a network of random curves import numpy as np import polyscope as ps ps . init () # generate some random nodes and edges between them nodes = np . random . rand ( 100 , 3 ) edges = np . random . randint ( 0 , 100 , size = ( 250 , 2 )) # visualize! ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) ps . show () register_curve_network ( name , nodes , edges , enabled = None , radius = None , color = None , material = None ) Add a new curve network structure to Polyscope. name string, a name for the structure nodes , an Nx3 numpy float array of node locations (or Nx2 for 2D) edges , an Ex2 numpy integer array of edge connections, as 0-based indices in to the nodes array, OR the string line / loop , to generate node connectivity as a line or loop, respectively. Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the nodes and edges relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the network as rgb in [0,1] material string, name of material to use for network if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D node positions are also supported, see 2D data .","title":"Registering a curve network"},{"location":"structures/curve_network/basics/#updating-a-curve-network","text":"The locations of the nodes in a curve network can be updated with the member function update_node_positions(newPositions) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). CurveNetwork . update_node_positions ( newPos ) Update the node positions in a curve network structure. newPos must be valid input as to initially construct the nodes of the network, with the same number of nodes as the network curently has.","title":"Updating a curve network"},{"location":"structures/curve_network/basics/#options","text":"Options control the appearance of the network . Note that these options can also be passed as keyword arguments to the initial register_curve_network() , as noted above. Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? is_enabled () set_enabled ( newVal = True ) yes radius size of rendered nodes/edges get_radius () set_radius ( newVal , relative = True ) yes color default color for the network get_color () set_color ( newVal ) yes material material for structure get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the curve network network = polyscope . register_curve_network ( \"my net\" , nodes , edges ) network . set_enabled ( False ) # disable network . set_enabled () # default is true network . set_radius ( 0.02 ) # radius is relative to a scene length scale by default network . set_radius ( 1.7 , relative = False ) # radius in absolute world units network . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] network . set_material ( \"candy\" ) # alternately: ps . register_curve_network ( \"my net 2\" , nodes , edges , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ))","title":"Options"},{"location":"structures/curve_network/color_quantities/","text":"Visualize color rgb-valued data at the nodes or edges of a curve network. Example: import numpy as np import polyscope as ps # register a curve network N_node = 100 N_edge = 250 nodes = np . random . rand ( N_node , 3 ) edges = np . random . randint ( 0 , N_node , size = ( N_edge , 2 )) ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) # visualize some random colors per-node vals_node = np . random . rand ( N_node , 3 ) ps_net . add_color_quantity ( \"rand vals\" , vals_node ) # visualize some random colors per-edge vals_edge = np . random . rand ( N_edge , 3 ) ps_net . add_color_quantity ( \"rand vals2\" , vals_edge , defined_on = 'edges' ) # view the network with all of these quantities ps . show () CurveNetwork . add_color_quantity ( name , values , defined_on = 'nodes' , enabled = None ) Add a scalar quantity to the network. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at nodes/edges defined_on string, one of nodes or edges , is this data a color per-node or a value per-edge? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Color Quantities"},{"location":"structures/curve_network/scalar_quantities/","text":"Visualize scalar valued data at the nodes or edges of a curve network. Example: import numpy as np import polyscope as ps # register a curve network N_node = 100 N_edge = 250 nodes = np . random . rand ( N_node , 3 ) edges = np . random . randint ( 0 , N_node , size = ( N_edge , 2 )) ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) # visualize some random data per-node vals_node = np . random . rand ( N_node ) ps_net . add_scalar_quantity ( \"rand vals\" , vals_node ) # visualize some random data per-edge vals_edge = np . random . rand ( N_edge ) ps_net . add_scalar_quantity ( \"rand vals2\" , vals_edge , defined_on = 'edges' ) # as always, we can customize the initial appearance ps_net . add_scalar_quantity ( \"rand vals2 opt\" , vals_edge , defined_on = 'edges' , enabled = True , vminmax = ( - 3. , 3. ), cmap = 'reds' ) # view the network with all of these quantities ps . show () CurveNetwork . add_scalar_quantity ( name , values , defined_on = 'nodes' , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the network. name string, a name for the quantity values a length N numpy array, scalars at nodes/edges defined_on string, one of nodes or edges , is this data a value per-node or a value per-edge? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) datatype , one of standard , symmetric , or magnitude , affects default colormap and map range vminmax , a 2-tuple of floats, specifying the min and max range to colormap in to cmap , which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Scalar Quantities"},{"location":"structures/curve_network/vector_quantities/","text":"Visualize vector-valued data at the nodes or edges of a curve network. Example: import numpy as np import polyscope as ps ps . init () # register a curve network N_node = 100 N_edge = 250 nodes = np . random . rand ( N_node , 3 ) edges = np . random . randint ( 0 , N_node , size = ( N_edge , 2 )) ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) # visualize some random vectors per-node vecs_node = np . random . rand ( N_node , 3 ) ps_net . add_vector_quantity ( \"rand vecs\" , vecs_node ) # visualize some random vectors per-edge vecs_edge = np . random . rand ( N_edge , 3 ) ps_net . add_vector_quantity ( \"rand vecs edge\" , vecs_edge , defined_on = 'edges' ) # set radius/length/color of the vectors ps_net . add_vector_quantity ( \"rand vecs opt\" , vecs_node , radius = 0.001 , length = 0.005 , color = ( 0.2 , 0.5 , 0.5 )) # ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space ps_net . add_vector_quantity ( \"vecs ambient\" , vecs_node , vectortype = 'ambient' ) # view the network with all of these quantities ps . show () CurveNetwork . add_vector_quantity ( name , values , defined_on = 'nodes' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the network. name string, a name for the quantity values an Nx3 numpy array, vectors at nodes/edges (or Nx2 for 2D data) defined_on string, one of nodes or edges , is this data a vector per-node or a vector per-edge? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Vector Quantities"},{"location":"structures/point_cloud/basics/","text":"Point Clouds Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point. Registering a point cloud Example: a point cloud of random points import numpy as np import polyscope as ps ps . init () # generate some points points = np . random . rand ( 100 , 3 ) # visualize! ps_cloud = ps . register_point_cloud ( \"my points\" , points ) ps . show () register_point_cloud ( name , points , enabled = None , radius = None , color = None , material = None ) Add a new point cloud structure to Polyscope. name is the name for the structure, as a string points is an N x 3 numpy array of point locations Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the points relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the points as rgb in [0,1] material string, name of material to use for cloud if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D point clouds are also supported, see 2D data . Updating a point cloud The locations of the points in a point cloud can be updated with the member function update_point_positions(newPositions) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). Example: update positions (continued from above) new_pos = np . random . rand ( 100 , 3 ) ps_cloud . update_point_positions ( new_pos ) ps . show () PointCloud . update_point_positions ( newPos ) Update the point positions in a point cloud structure. newPos must be valid input as to initially construct a point cloud, with the same number of points. Options Options control the appearance of the cloud. Note that these options can also be passed as keyword arguments to the initial register_point_cloud() , as noted above. Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? is_enabled () set_enabled ( newVal = True ) yes point radius size of rendered points get_radius () set_radius ( newVal , relative = True ) yes point color default color for points get_color () set_color ( newVal ) yes material material for point get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the point cloud cloud = polyscope . register_point_cloud ( \"my points\" , points ) cloud . set_enabled ( False ) # disable cloud . set_enabled () # default is true cloud . set_radius ( 0.02 ) # radius is relative to a scene length scale by default cloud . set_radius ( 1.7 , relative = False ) # radius in absolute world units cloud . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] cloud . set_material ( \"candy\" ) # alternately: ps . register_point_cloud ( \"my points 2\" , points , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ))","title":"Basics"},{"location":"structures/point_cloud/basics/#point-clouds","text":"Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point.","title":"Point Clouds"},{"location":"structures/point_cloud/basics/#registering-a-point-cloud","text":"Example: a point cloud of random points import numpy as np import polyscope as ps ps . init () # generate some points points = np . random . rand ( 100 , 3 ) # visualize! ps_cloud = ps . register_point_cloud ( \"my points\" , points ) ps . show () register_point_cloud ( name , points , enabled = None , radius = None , color = None , material = None ) Add a new point cloud structure to Polyscope. name is the name for the structure, as a string points is an N x 3 numpy array of point locations Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the points relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the points as rgb in [0,1] material string, name of material to use for cloud if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D point clouds are also supported, see 2D data .","title":"Registering a point cloud"},{"location":"structures/point_cloud/basics/#updating-a-point-cloud","text":"The locations of the points in a point cloud can be updated with the member function update_point_positions(newPositions) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). Example: update positions (continued from above) new_pos = np . random . rand ( 100 , 3 ) ps_cloud . update_point_positions ( new_pos ) ps . show () PointCloud . update_point_positions ( newPos ) Update the point positions in a point cloud structure. newPos must be valid input as to initially construct a point cloud, with the same number of points.","title":"Updating a point cloud"},{"location":"structures/point_cloud/basics/#options","text":"Options control the appearance of the cloud. Note that these options can also be passed as keyword arguments to the initial register_point_cloud() , as noted above. Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? is_enabled () set_enabled ( newVal = True ) yes point radius size of rendered points get_radius () set_radius ( newVal , relative = True ) yes point color default color for points get_color () set_color ( newVal ) yes material material for point get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the point cloud cloud = polyscope . register_point_cloud ( \"my points\" , points ) cloud . set_enabled ( False ) # disable cloud . set_enabled () # default is true cloud . set_radius ( 0.02 ) # radius is relative to a scene length scale by default cloud . set_radius ( 1.7 , relative = False ) # radius in absolute world units cloud . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] cloud . set_material ( \"candy\" ) # alternately: ps . register_point_cloud ( \"my points 2\" , points , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ))","title":"Options"},{"location":"structures/point_cloud/color_quantities/","text":"Visualize color rgb-valued data at the points of a point cloud. Example: import numpy as np import polyscope as ps # register a point cloud N = 100 points = np . random . rand ( N , 3 ) ps_cloud = ps . register_point_cloud ( \"my points\" , points ) # generate some random color per-point vals = np . random . rand ( N , 3 ) # basic color visualization ps_cloud . add_color_quantity ( \"rand colors\" , vals ) ps . show () PointCloud . add_color_quantity ( name , values , enabled = None ) Add a color quantity to the point cloud. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at points Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Color Quantities"},{"location":"structures/point_cloud/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the points of a point cloud. Example: import numpy as np import polyscope as ps # register a point cloud N = 100 points = np . random . rand ( N , 3 ) ps_cloud = ps . register_point_cloud ( \"my points\" , points ) # generate some random data per-point vals = np . random . rand ( N ) # basic visualization ps_cloud . add_scalar_quantity ( \"rand vals\" , vals ) # manually specify a range for colormapping ps_cloud . add_scalar_quantity ( \"rand vals with range\" , vals , vminmax = ( - 5. , 5. )) # use a different colormap ps_cloud . add_scalar_quantity ( \"rand vals with range\" , vals , cmap = 'blues' ) # use the 'datatype' to specify default visualization semantics vals_gaussian = np . random . normal ( size = N ) ps_cloud . add_scalar_quantity ( \"gaussian vals symmetric\" , vals_gaussian , datatype = 'symmetric' ) # view the point cloud with all of these quantities ps . show () PointCloud . add_scalar_quantity ( name , values , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the point cloud. name string, a name for the quantity values a length N numpy array, scalars at points Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used) datatype , one of standard , symmetric , or magnitude , affects default colormap and map range vminmax , a 2-tuple of floats, specifying the min and max range to colormap in to cmap , which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Scalar Quantities"},{"location":"structures/point_cloud/vector_quantities/","text":"Visualize vector-valued data at the points of a point cloud. Example: import numpy as np import polyscope as ps # register a point cloud N = 100 points = np . random . rand ( N , 3 ) ps_cloud = ps . register_point_cloud ( \"my points\" , points ) # generate some random vectors per-point vecs = np . random . rand ( N , 3 ) # basic visualization ps_cloud . add_vector_quantity ( \"rand vecs\" , vecs ) # set radius/length/color of the vectors ps_cloud . add_vector_quantity ( \"rand vecs\" , vecs , radius = 0.001 , length = 0.005 , color = ( 0.2 , 0.5 , 0.5 )) # ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space ps_cloud . add_vector_quantity ( \"vecs ambient\" , vecs , vectortype = 'ambient' ) # view the point cloud with all of these quantities ps . show () PointCloud . add_vector_quantity ( name , values , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the point cloud. name string, a name for the quantity values an Nx3 numpy array, vectors at points (or Nx2 for 2D data) Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Vector Quantities"},{"location":"structures/surface_mesh/basics/","text":"Surface Meshes Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold, and all faces need not have the same degree. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element. Registering a surface mesh Example: registering a mesh import numpy as np import polyscope as ps ps . init () vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces # visualize! ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps . show () Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. register_surface_mesh ( name , vertices , faces , enabled = None , color = None , edge_color = None , smooth_shade = None , edge_width = None , material = None ) Add a new surface mesh structure to Polyscope. name string, a name for the structure vertices , an Nx3 numpy float array of vertex locations (or Nx2 for 2D) faces , an FxD numpy integer array of faces, as 0-based indices in to the vertices array, OR a plain python list-of-lists of indices (or really, anything twice-iterable which yields integers). The latter option enables meshes where not all faces have the same degree. Additional optional keyword arguments: enabled boolean, is the structure enabled initially color float 3-tuple, default color values for the mesh as rgb in [0,1] edge_color float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set edge_width too) edge_width float, width of edges in rendered mesh; default sets 0 to disable edges, 1 is a reasonable value to enable smooth_shade boolean, if True use smooth shading (default: False for flat shading) material string, name of material to use for the mesh if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D vertex positions are also supported, see 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering. Updating a mesh The locations of the vertices in a mesh can be updated with the member function update_vertex_positions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). SurfaceMesh . update_vertex_positions ( newPos ) Update the vertex positions in a surface mesh structure. newPos must be valid input as to initially construct the vertex positions, with the same number of vertices. Options Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool is_enabled () set_enabled ( newVal ) yes surface color the color of the mesh get_color () set_color ( val ) yes edge color the color of the edges of the mesh get_edge_color () set_edge_color ( val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges get_edge_width () set_edge_width ( val ) yes shade smooth use smooth shading along faces or simple flat faces get_smoooth_shade () set_smooth_shade ( isSmooth ) yes material material for structure get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the mesh import numpy as np import polyscope as ps vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . set_enabled ( False ) # disable ps_mesh . set_enabled () # default is true ps_mesh . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] ps_mesh . set_edge_color (( 0.8 , 0.8 , 0.8 )) ps_mesh . set_edge_width ( 1.0 ) ps_mesh . set_smooth_shade ( True ) ps_mesh . set_material ( \"candy\" ) # alternately: ps . register_surface_mesh ( \"my mesh2\" , vertices , faces , enabled = False , color = ( 1. , 0. , 0. ), edge_color = (( 0.8 , 0.8 , 0.8 )), edge_width = 1.0 , smooth_shade = True , material = 'candy' )","title":"Basics"},{"location":"structures/surface_mesh/basics/#surface-meshes","text":"Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold, and all faces need not have the same degree. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element.","title":"Surface Meshes"},{"location":"structures/surface_mesh/basics/#registering-a-surface-mesh","text":"Example: registering a mesh import numpy as np import polyscope as ps ps . init () vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces # visualize! ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps . show () Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. register_surface_mesh ( name , vertices , faces , enabled = None , color = None , edge_color = None , smooth_shade = None , edge_width = None , material = None ) Add a new surface mesh structure to Polyscope. name string, a name for the structure vertices , an Nx3 numpy float array of vertex locations (or Nx2 for 2D) faces , an FxD numpy integer array of faces, as 0-based indices in to the vertices array, OR a plain python list-of-lists of indices (or really, anything twice-iterable which yields integers). The latter option enables meshes where not all faces have the same degree. Additional optional keyword arguments: enabled boolean, is the structure enabled initially color float 3-tuple, default color values for the mesh as rgb in [0,1] edge_color float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set edge_width too) edge_width float, width of edges in rendered mesh; default sets 0 to disable edges, 1 is a reasonable value to enable smooth_shade boolean, if True use smooth shading (default: False for flat shading) material string, name of material to use for the mesh if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D vertex positions are also supported, see 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering.","title":"Registering a surface mesh"},{"location":"structures/surface_mesh/basics/#updating-a-mesh","text":"The locations of the vertices in a mesh can be updated with the member function update_vertex_positions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). SurfaceMesh . update_vertex_positions ( newPos ) Update the vertex positions in a surface mesh structure. newPos must be valid input as to initially construct the vertex positions, with the same number of vertices.","title":"Updating a mesh"},{"location":"structures/surface_mesh/basics/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the structure enabled? bool is_enabled () set_enabled ( newVal ) yes surface color the color of the mesh get_color () set_color ( val ) yes edge color the color of the edges of the mesh get_edge_color () set_edge_color ( val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges get_edge_width () set_edge_width ( val ) yes shade smooth use smooth shading along faces or simple flat faces get_smoooth_shade () set_smooth_shade ( isSmooth ) yes material material for structure get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the mesh import numpy as np import polyscope as ps vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . set_enabled ( False ) # disable ps_mesh . set_enabled () # default is true ps_mesh . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] ps_mesh . set_edge_color (( 0.8 , 0.8 , 0.8 )) ps_mesh . set_edge_width ( 1.0 ) ps_mesh . set_smooth_shade ( True ) ps_mesh . set_material ( \"candy\" ) # alternately: ps . register_surface_mesh ( \"my mesh2\" , vertices , faces , enabled = False , color = ( 1. , 0. , 0. ), edge_color = (( 0.8 , 0.8 , 0.8 )), edge_width = 1.0 , smooth_shade = True , material = 'candy' )","title":"Options"},{"location":"structures/surface_mesh/color_quantities/","text":"Visualize color rgb-valued data at the elements of a surface mesh. Example: import numpy as np import polyscope as ps N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # visualize some random data per-vertex colors_vert = np . random . rand ( N_vert , 3 ) ps_mesh . add_color_quantity ( \"rand colors\" , colors_vert ) # visualize some random data per-face colors_face = np . random . rand ( N_face , 3 ) ps_mesh . add_color_quantity ( \"rand colors2\" , colors_face , defined_on = 'faces' ) # view the mesh with all of these quantities ps . show () SurfaceMesh . add_color_quantity ( name , values , defined_on = 'vertices' , enabled = None ) Add a scalar quantity to the network. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at vertices/faces defined_on string, one of vertices or faces , is this data a color per vertex or a color per face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Color Quantities"},{"location":"structures/surface_mesh/count_quantities/","text":"Count quantities store integers defined at just a few elements of a mesh, rather than at every element. These useful for visualizing, e.g., singularities of a vector field at vertices. TODO TODO document count quantities. See polyscope/surface_mesh.h for add signatures.","title":"Count quantities"},{"location":"structures/surface_mesh/distance_quantities/","text":"Visualize distance-valued data at the elements of a surface mesh. Distance quantities are basically scalars, but are visualized with alternating stripes to show distance contours. Example: import numpy as np import polyscope as ps ps . init () N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) dists = # your distances, a length N_vert array # visualize the distance ps_mesh . add_distance_quantity ( \"distances\" , dists , enabled = True , stripe_size = 0.01 ) # use defaults for signed distances ps_mesh . add_distance_quantity ( \"signed distances\" , dists , signed = True ) # view the mesh with these quantities ps . show () SurfaceMesh . add_distance_quantity ( name , values , defined_on = 'vertices' , enabled = None , signed = False , vminmax = None , stripe_size = None , stripe_size_relative = True , cmap = None ) Add a distance quantity to the mesh. name string, a name for the quantity values a length N numpy array, distance scalars defined_on for now, only 'vertices' is supported signed boolean, if true the data is assumed to represent signed distances, and symmetric ranges/colormaps are used by default Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) vminmax a 2-tuple of floats, specifying the min and max range to colormap in to stripe_size float, the width of stripes in the visualization stripe_size_relative boolean, if true stripe_size is interpreted relative to the scene length scale, otherwise absolute cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Distance Quantities"},{"location":"structures/surface_mesh/indexing_convention/","text":"Default ordering Polyscope abstracts over data types by accepting generic ordered arrays of data to visualize. Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in a mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering. Vertices The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_vertex_permutation ( perm , expected_size = None ) Set a non-standard ordering for vertex-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Faces The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_face_permutation ( perm , expected_size = None ) Set a non-standard ordering for face-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Edges The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_edge_permutation ( perm , expected_size = None ) Set a non-standard ordering for edge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Halfedges The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_halfedge_permutation ( perm , expected_size = None ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Corners The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_corner_permutation ( perm , expected_size = None ) Set a non-standard ordering for corner-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. All at once As a convenience, you can alternately use a single function which passes all permutations needed at the same time. This might ease writing a single helper function which defines any necessary permutations for the mesh convention in your codebase. SurfaceMesh . set_all_permutations ( vertex_perm = None , vertex_perm_size = None , face_perm = None , face_perm_size = None , edge_perm = None , edge_perm_size = None , corner_perm = None , corner_perm_size = None , halfedge_perm = None , halfedge_perm_size = None ) Any non- None keyword arguments will simply be forwarded to the appropriate set_XXX_permutation() variant as above.","title":"Indexing Convention"},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","text":"Polyscope abstracts over data types by accepting generic ordered arrays of data to visualize. Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in a mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.","title":"Default ordering"},{"location":"structures/surface_mesh/indexing_convention/#vertices","text":"The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_vertex_permutation ( perm , expected_size = None ) Set a non-standard ordering for vertex-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Vertices"},{"location":"structures/surface_mesh/indexing_convention/#faces","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_face_permutation ( perm , expected_size = None ) Set a non-standard ordering for face-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Faces"},{"location":"structures/surface_mesh/indexing_convention/#edges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_edge_permutation ( perm , expected_size = None ) Set a non-standard ordering for edge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Edges"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_halfedge_permutation ( perm , expected_size = None ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Halfedges"},{"location":"structures/surface_mesh/indexing_convention/#corners","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_corner_permutation ( perm , expected_size = None ) Set a non-standard ordering for corner-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Corners"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","text":"As a convenience, you can alternately use a single function which passes all permutations needed at the same time. This might ease writing a single helper function which defines any necessary permutations for the mesh convention in your codebase. SurfaceMesh . set_all_permutations ( vertex_perm = None , vertex_perm_size = None , face_perm = None , face_perm_size = None , edge_perm = None , edge_perm_size = None , corner_perm = None , corner_perm_size = None , halfedge_perm = None , halfedge_perm_size = None ) Any non- None keyword arguments will simply be forwarded to the appropriate set_XXX_permutation() variant as above.","title":"All at once"},{"location":"structures/surface_mesh/misc_quantities/","text":"Surface Graph Quantity The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes radius the radius the graph is drawn with double getRadius () setRadius ( double val , bool isRelative = true ) yes color the color to draw the graph with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Misc quantities"},{"location":"structures/surface_mesh/misc_quantities/#surface-graph-quantity","text":"The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph.","title":"Surface Graph Quantity"},{"location":"structures/surface_mesh/misc_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes radius the radius the graph is drawn with double getRadius () setRadius ( double val , bool isRelative = true ) yes color the color to draw the graph with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/parameterization_quantities/","text":"A parameterization is a set of 2D coordinates associated with a mesh, often referred to as \u201cUV coordinates\u201d. This sections details several functions for visualizing such parameterizations. Example: import numpy as np import polyscope as ps ps . init () N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # parameterization per vertex param_vert = np . random . rand ( N_vert , 2 ) ps_mesh . add_parameterization_quantity ( \"rand param\" , param_vert ) # parameterization per corner param_corner = np . random . rand ( ps_mesh . n_corners (), 2 ) ps_mesh . add_parameterization_quantity ( \"rand param corner\" , param_corner , defined_on = 'corners' ) # use options to customize visualization ps_mesh . add_parameterization_quantity ( \"rand param corner2\" , param_corner , defined_on = 'corners' , coords_type = 'world' , viz_style = 'local_rad' ) # with custom checker/grid color cA = ( 0.1 , 0.2 , 0.3 ) cB = ( 0.4 , 0.5 , 0.6 ) ps_mesh . add_parameterization_quantity ( \"rand param corner3\" , param_corner , defined_on = 'corners' , coords_type = 'unit' , viz_style = 'grid' , grid_colors = ( cA , cB )) # view the mesh with all of these quantities ps . show () Adding SurfaceMesh . add_parameterization_quantity ( name , values , defined_on = 'vertices' , coords_type = 'unit' , enabled = None , viz_style = None , grid_colors = None , checker_colors = None , checker_size = None , cmap = None ) Add a parameterization quantity to the mesh. name string, a name for the quantity values an Nx2 numpy array, coordinates at vertices/corners defined_on one of 'vertices','corners' , is this a coordinate per vertex or per corner? coords_type string, one of 'unit' , 'world' (see below) Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) viz_style string, one of 'checker' , 'grid' , 'local_check' , 'local_rad' (see below) grid_colors 2-tuple of rgb colors, used to color the grid visualization checker_colors 2-tuple of rgb colors, used to color the checkerboard visualization checker_size float, the size of checkers/grid/stripes cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set. Options Styles Several styles are available for how a parameterization is displayed. The viz_style option determines how parameterizations are visualized: checker : a two-color checker pattern grid : a two-color grid with thin lines local_check : a checkerboard over a radial colormap, centered around (0,0) local_rad : distance stripes over a radial colormap, centered around (0,0) Types The coords_type options determines how parameter coordinates are interpreted for scaling: unit : UV coords are assumed to lie on the [0,1] interval world : UV coords are assumed to be scaled like the world-space positions of the mesh","title":"Parameterization Quantities"},{"location":"structures/surface_mesh/parameterization_quantities/#adding","text":"SurfaceMesh . add_parameterization_quantity ( name , values , defined_on = 'vertices' , coords_type = 'unit' , enabled = None , viz_style = None , grid_colors = None , checker_colors = None , checker_size = None , cmap = None ) Add a parameterization quantity to the mesh. name string, a name for the quantity values an Nx2 numpy array, coordinates at vertices/corners defined_on one of 'vertices','corners' , is this a coordinate per vertex or per corner? coords_type string, one of 'unit' , 'world' (see below) Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) viz_style string, one of 'checker' , 'grid' , 'local_check' , 'local_rad' (see below) grid_colors 2-tuple of rgb colors, used to color the grid visualization checker_colors 2-tuple of rgb colors, used to color the checkerboard visualization checker_size float, the size of checkers/grid/stripes cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Adding"},{"location":"structures/surface_mesh/parameterization_quantities/#options","text":"","title":"Options"},{"location":"structures/surface_mesh/parameterization_quantities/#styles","text":"Several styles are available for how a parameterization is displayed. The viz_style option determines how parameterizations are visualized: checker : a two-color checker pattern grid : a two-color grid with thin lines local_check : a checkerboard over a radial colormap, centered around (0,0) local_rad : distance stripes over a radial colormap, centered around (0,0)","title":"Styles"},{"location":"structures/surface_mesh/parameterization_quantities/#types","text":"The coords_type options determines how parameter coordinates are interpreted for scaling: unit : UV coords are assumed to lie on the [0,1] interval world : UV coords are assumed to be scaled like the world-space positions of the mesh","title":"Types"},{"location":"structures/surface_mesh/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the elements of a surface mesh. Example: import numpy as np import polyscope as ps ps . init () N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # visualize some random data per-vertex vals_vert = np . random . rand ( N_vert ) ps_mesh . add_scalar_quantity ( \"rand vals\" , vals_vert ) # visualize some random data per-face vals_face = np . random . rand ( N_face ) ps_mesh . add_scalar_quantity ( \"rand vals2\" , vals_face , defined_on = 'faces' ) # visualize some random data per-edge (halfedges are also supported) vals_edge = np . random . rand ( ps_mesh . n_edges ()) ps_mesh . add_scalar_quantity ( \"rand vals3\" , vals_edge , defined_on = 'edges' ) # as always, we can customize the initial appearance ps_mesh . add_scalar_quantity ( \"rand vals3 opt\" , vals_edge , defined_on = 'edges' , enabled = True , vminmax = ( - 3. , 3. ), cmap = 'reds' ) # view the mesh with all of these quantities ps . show () SurfaceMesh . add_scalar_quantity ( name , values , defined_on = 'vertices' , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the mesh. name string, a name for the quantity values a length N numpy array, scalars at vertices/faces/etc defined_on one of 'vertices','faces','edges','halfedges' , is this data a value per vertex or a value per face, etc? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) datatype one of standard , symmetric , or magnitude , affects default colormap and map range vminmax a 2-tuple of floats, specifying the min and max range to colormap in to cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Scalar Quantities"},{"location":"structures/surface_mesh/vector_quantities/","text":"Visualize vector-valued data at the elements of a surface mesh. Example: import numpy as np import polyscope as ps ps . init () # register a surface mesh N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # visualize some random vectors per vertex vecs_vert = np . random . rand ( N_vert , 3 ) ps_mesh . add_vector_quantity ( \"rand vecs\" , vecs_vert ) # set radius/length/color of the vectors ps_mesh . add_vector_quantity ( \"rand vecs opt\" , vecs_vert , radius = 0.001 , length = 0.005 , color = ( 0.2 , 0.5 , 0.5 )) # ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space ps_mesh . add_vector_quantity ( \"vecs ambient\" , vecs_vert , vectortype = 'ambient' ) # view the mesh with all of these quantities ps . show () SurfaceMesh . add_vector_quantity ( name , values , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the mesh. name string, a name for the quantity values an Nx3 numpy array, vectors at vertices/faces (or Nx2 for 2D data) defined_on string, one of vertices or faces , is this data a vector per-vertex or a vector per-face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set. Tangent vectors Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element. Specifying the tangent basis Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for each mesh element. SurfaceMesh . set_vertex_tangent_basisX ( vectors ) Specify the tangent coordinate system at vertices, by giving the direction of the x-axis of the basis. vectors is an Vx3 (or Vx2 for 2D) array of one 3D vector at each vertex, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal. SurfaceMesh . set_face_tangent_basisX ( vectors ) Specify the tangent coordinate system at faces, by giving the direction of the x-axis of the basis. vectors is an Fx3 (or Fx2 for 2D) array of one 3D vector at each face, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal. Adding intrinsic tangent vectors In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh . add_intrinsic_vector_quantity ( name , values , n_sym = 1 , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None , ribbon = None ) Add a vector quantity to the mesh. Remember to specify your tangent basis first! name string, a name for the quantity values an Nx2 numpy array, of tangent vectors at vertices/faces n_sym is a symmetry order for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. defined_on string, one of vertices or faces , is this data a vector per-vertex or a vector per-face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set. One forms One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh . add_one_form_vector_quantity ( name , values , orientations , enabled = None , length = None , radius = None , color = None , ribbon = None ) Add a one-form vector quantity to the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. name string, a name for the quantity values a length n_edges numpy float array, integrated 1-form values at edges orientations a length n_edges numpy boolean array. 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Vector Quantities"},{"location":"structures/surface_mesh/vector_quantities/#tangent-vectors","text":"Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element.","title":"Tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#specifying-the-tangent-basis","text":"Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for each mesh element. SurfaceMesh . set_vertex_tangent_basisX ( vectors ) Specify the tangent coordinate system at vertices, by giving the direction of the x-axis of the basis. vectors is an Vx3 (or Vx2 for 2D) array of one 3D vector at each vertex, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal. SurfaceMesh . set_face_tangent_basisX ( vectors ) Specify the tangent coordinate system at faces, by giving the direction of the x-axis of the basis. vectors is an Fx3 (or Fx2 for 2D) array of one 3D vector at each face, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal.","title":"Specifying the tangent basis"},{"location":"structures/surface_mesh/vector_quantities/#adding-intrinsic-tangent-vectors","text":"In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh . add_intrinsic_vector_quantity ( name , values , n_sym = 1 , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None , ribbon = None ) Add a vector quantity to the mesh. Remember to specify your tangent basis first! name string, a name for the quantity values an Nx2 numpy array, of tangent vectors at vertices/faces n_sym is a symmetry order for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. defined_on string, one of vertices or faces , is this data a vector per-vertex or a vector per-face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Adding intrinsic tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#one-forms","text":"One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh . add_one_form_vector_quantity ( name , values , orientations , enabled = None , length = None , radius = None , color = None , ribbon = None ) Add a one-form vector quantity to the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. name string, a name for the quantity values a length n_edges numpy float array, integrated 1-form values at edges orientations a length n_edges numpy boolean array. 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"One forms"}]}