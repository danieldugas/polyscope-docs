{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polyscope is a C++/Python viewer and user interface for 3D data such as meshes and point clouds. It allows you to register your data and quickly generate informative and beautiful visualizations, either programmatically or via a dynamic GUI. Polyscope is designed to be lightweight\u2014it does not \u201ctake ownership\u201d over your entire program, and it is easy to integrate with existing codebases and popular libraries. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code. Polyscope uses a paradigm of structures and quantities . A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field. When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling visibility, color-mapping data and adjusting maps, \u201cpicking\u201d to click in the scene and query numerical quantities, etc. Note: There are two variants of this documentation, for C++ and Python. Use the buttons on the top bar to change language. A simple workflow for visualizing data in Polyscope looks like: Python import polyscope as ps # Initialize polyscope ps . init () ### Register a point cloud # `my_points` is a Nx3 numpy array ps . register_point_cloud ( \"my points\" , my_points ) ### Register a mesh # `verts` is a Nx3 numpy array of vertex positions # `faces` is a Fx3 array of indices, or a nested list ps . register_surface_mesh ( \"my mesh\" , verts , faces , smooth_shade = True ) # Add a scalar function and a vector function defined on the mesh # vertex_scalar is a length V numpy array of values # face_vectors is an Fx3 array of vectors per face ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"my_scalar\" , vertex_scalar , defined_on = 'vertices' , cmap = 'blues' ) ps . get_surface_mesh ( \"my mesh\" ) . add_vector_quantity ( \"my_vector\" , face_vectors , defined_on = 'faces' , color = ( 0.2 , 0.5 , 0.5 )) # View the point cloud and mesh we just registered in the 3D UI ps . show () C++ #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" // Initialize polyscope polyscope :: init (); // Register a point cloud // `points` is a Nx3 array-like container of points polyscope :: registerPointCloud ( \"my points\" , points ) // Register a surface mesh structure // `meshVerts` is a Vx3 array-like container of vertex positions // `meshFaces` is a Fx3 array-like container of face indices polyscope :: registerSurfaceMesh ( \"my mesh\" , meshVerts , meshFaces ); // Add a scalar and a vector function defined on the mesh // `scalarQuantity` is a length V array-like container of values // `vectorQuantity` is an Fx3 array-like container of vectors per face polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addVertexScalarQuantity ( \"my_scalar\" , scalarQuantity ); polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addFaceVectorQuantity ( \"my_vector\" , vectorQuantity ); // View the point cloud and mesh we just registered in the 3D UI polyscope :: show (); Polyscope is designed to make your life easier. It is simple to build, and fewer than 10 lines of code should be sufficient to start visualizing. Author: Nicholas Sharp If Polyscope contributes to an academic publication, cite it as: @misc { polyscope , title = {Polyscope} , author = {Nicholas Sharp and others} , note = {www.polyscope.run} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"about/bindings/","text":"Python bindings Warning Python bindings are in the works! Check back soon.","title":"Bindings"},{"location":"about/bindings/#python-bindings","text":"Warning Python bindings are in the works! Check back soon.","title":"Python bindings"},{"location":"about/contributing/","text":"Polyscope is an open-source project, and you are encouraged to contribute! The core library is lives in this repository , with documentation here and Python bindings here . All contributions will be released under Polyscope\u2019s MIT license. How to make a great pull request: Implement a feature or fix a bug Write a new unit test and run tests Submit a PR and ensure automated tests pass Update the documentation Create any new Python bindings Of course, contributions that only do some of the above are still welcome and appreciated! But doing all of these steps means your pull request is most likely to be merged right away. The sections below go in to more detail on each of these steps. C++ implementation C++ vs. Python contributions Polyscope is implemented as a C++ library, with a thin binding layer to Python. All functionality is implemented on the C++ side\u2014pull requests which implement new features solely on the Python side or using external Python dependencies generally will not be accepted. Please file an issue asking first if you are unsure! Of course, bugfixes and additions to the Python binding layer itself are an exception. Conversely, any new C++ features are strongly encouraged to add corresponding Python bindings! See below. A few general pointers: The UI (menus, dialogs, buttons, etc) is managed using Dear ImGUI , which is very well-documented and has many resources available online. Core rendering logic and shaders are implemented in the /render subdirectory , particularly engine.h . The engine is written to abstract over rendering backends, but at the moment only openGL is supported. There is also a \u201cmock\u201d backend for testing; new rendering features should be mirrored in both gl_engine.cpp and mock_gl_engine.cpp . Polyscope shaders use a custom in-house shader builder , which performs string manipulation with a simple substitution language to build shaders at runtime which support optional features like slice planes, transparency, different quantity visualization policies, etc. The shaders themselves also explicitly track some metadata like what attributes and uniforms they require. Examples of base shaders can be found e.g. here , and substitution rules here . For any shader or rule to be available in Polyscope, it must be registered in GLEngine::populateDefaultShadersAndRules() , and also in the corresponding function of the mock engine for testing. If adding a new structure or quantity, be sure to make use of the data adaptors for all user inputs. See here for an example. Generally, this means functions which take user data should be templated, and the input then passed through standardizeArray<>() or standardizeVectorArray<>() , etc. If adding new options or parameters to a structure/quantity. Be sure to follow proper encapsulation principles (create getters & setters), and use a persistent values . Check out PointCloud::pointColor for a good basic example. Also, all length-valued quantities should use scaled values (as in PointCloud::pointRadius ). Unit testing Whenever possible, add a unit test that somehow exercises any new functionality or verifies that the bug has been fixed. Polyscope uses the googletest testing framework. See documentation there for test macros, executable options, etc. In a perfect world, we would actually test that the rendered output from Polyscope is pixel-perfect. However, this is hard for a lot of reasons, so instead most of our tests are just \u201csmoke tests\u201d that call functions with some dummy data and ensure no errors are thrown. In fact, these tests are often run on headless servers, where we cannot even initialize an openGL environment. For this reason, in addition to the usual openGL backend , we also have an openGL_mock backend ( implemented here ) for testing on headless servers. This backend cannot actually render anything, but still performs many rendering-related sanity checks. If making changes to the rendering engine & shaders, you may find that changes need to be mirrored in mock_gl_engine.cpp . To run unit tests locally on your own machine (here, via unix terminal commands), use cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j4 ./bin/polyscope-test backend = openGL3_glfw which should create a window onscreen and run tests for a few seconds. Additionally , run the tests again like ./bin/polyscope-test which will use the openGL_mock backend (you will not see anything onscreen). This is how testing will be performed on the headless CI servers. If both sets of tests pass without errors, you are good to go. PRs & automated tests Once your feature seems ready and unit tests are passing, submit a pull request to the main repository . This will trigger continuous integration (CI) tests via Github Actions to automatically compile the code on a collection of windows/mac/linux machines with various compilers, and verify that tests pass. If there are any issues, a failed \u201ccheck\u201d will show on the pull request page which you can click to learn more. If this is your first contribution to Polyscope, a maintainer will need to manually approve the CI run (this is a github restriction). You are welcome to reach out in the PR chat to sort out any problems. We may request changes! If a PR ever goes more than a few days without a response feel free to ping @nmwsharp. Documentation Documentation is hosted in its own separate repository . Polyscope docs use the mkdocs documentation engine, with the mkdocs-material theme (this theme is quite large and adds significant functionality beyond base mkdocs). The documentation is written in a large collection of markdown files; it is not automatically scraped from the code, or code comments, etc, so we must manually keep it up to date. There are two duplicate copies of all the docs for C++ and Python, stored in parallel directories /cpp and /py . A few shared files and assets are stored in the /shared directory, or symlinked from the /py subdirectory to point to a file the /cpp directory. We try to keep these two parallel versions in sync as much as possible, only differing where necessary between C++ and Python. To preview the documentation while editing, first install the necessary packages with pip install mkdocs mkdocs-material==6.2.8 mkdocs-macros-plugin pygments . Then run python3 -m mkdocs serve (run this command from the /cpp directory to view C++ docs, and likewise for /py ). A local address will be printed to your terminal, which you can navigate to in-browser to see the docs. Hopefully editing the docs markdown files should be self-evident, you can mainly copy existing content & formatting. Any new files need to be added the manifests in mkdocs.yml . Don\u2019t forget to add a blurb to the release notes ! If you are not able to build the docs for any reason, it is fine to just edit the markdown files and submit a docs PR with that. To actually update the hosted documentation files online at polyscope.run, the documentation site needs to be recompiled and committed to the to the /docs subdirectory. The build_commit_push.sh script can handle this for you, rebuilding both C++ & Python docs and committing the result to the /docs subdirectory: sh build_commit_push.sh If you include these built docs changes in your PR, the webpage will automatically update when it is merged. Otherwise the maintainers (usually @nmwsharp) will need to run this command and commit the update after accepting your PR. Python bindings Python bindings for Polyscope are stored in their own separate repository . We use pybind11 to generate bindings. These bindings are kept as thin wrappers as much as possible, just doing a minimal translation between the C++ interface and typical Python calling conventions. The bindings are actually managed internally as two separate Python packages: polyscope_bindings (which contains the raw bindings generated by our pybind11 code), and the higher-level polyscope (which contains the actual, nice user-facing Python functions). The separation is because there is no way to write additional Python code in the pybind11-generated package, but we often want to do some translation and error checking on the Python side before invoking the bindings. As such, adding a binding generally means writing code in two places: Add a new pybind11 C++ binding, like those here Add a new Python wrapper function which calls the generated binding, like the ones here Note that a few stylistic conventions between Python and C++. In particular, we do not expose classes for quantities, but set options via optional keyword arguments when the quantity is added. The pybind11 C++ bindings take Eigen arrays as arguments, because pybind11 performs automatic translation between Eigen/numpy. Python binding unit tests are stored in /test/polyscope_test.py . As with C++, these are mainly just simple \u201csmoke tests\u201d which call the functions with dummy data and ensure no errors are thrown. All new bindings functions need a test! To build and test the bindings, first compile the bindings from the polyscope-py root directory like mkdir build cd build cmake .. make -j8 the run python polyscope_test.py . As you write code, these bindings must be recompiled to reflect any changes to the pybind11 C++. When testing, make sure there is not another copy of Polyscope for Python installed in your system, which might unintentionally be used instead of the development version! Also, the adjacent demo_app.py can be used for simple testing. Don\u2019t forget, the Python bindings have a parallel set of docs in the /py directory . Updates to Python should be reflected there. When all your tests are passing, create a pull request! As with C++, submitting a pull request to the Python bindings will trigger a cloud build and some automated checks. Actually deploying a new Python version to pip and conda package managers is a somewhat significant process, so we typically group together updates before cutting a new version. Ping @nmwsharp to get a new version deployed. Major and minor versions of the Python library are kept in-sync with the C++ library versions, whereas patch versions ( 1.2.4 \u2013> 1.2.5 ) are used for new updates to the Python bindings only.","title":"Contributing"},{"location":"about/contributing/#c-implementation","text":"C++ vs. Python contributions Polyscope is implemented as a C++ library, with a thin binding layer to Python. All functionality is implemented on the C++ side\u2014pull requests which implement new features solely on the Python side or using external Python dependencies generally will not be accepted. Please file an issue asking first if you are unsure! Of course, bugfixes and additions to the Python binding layer itself are an exception. Conversely, any new C++ features are strongly encouraged to add corresponding Python bindings! See below. A few general pointers: The UI (menus, dialogs, buttons, etc) is managed using Dear ImGUI , which is very well-documented and has many resources available online. Core rendering logic and shaders are implemented in the /render subdirectory , particularly engine.h . The engine is written to abstract over rendering backends, but at the moment only openGL is supported. There is also a \u201cmock\u201d backend for testing; new rendering features should be mirrored in both gl_engine.cpp and mock_gl_engine.cpp . Polyscope shaders use a custom in-house shader builder , which performs string manipulation with a simple substitution language to build shaders at runtime which support optional features like slice planes, transparency, different quantity visualization policies, etc. The shaders themselves also explicitly track some metadata like what attributes and uniforms they require. Examples of base shaders can be found e.g. here , and substitution rules here . For any shader or rule to be available in Polyscope, it must be registered in GLEngine::populateDefaultShadersAndRules() , and also in the corresponding function of the mock engine for testing. If adding a new structure or quantity, be sure to make use of the data adaptors for all user inputs. See here for an example. Generally, this means functions which take user data should be templated, and the input then passed through standardizeArray<>() or standardizeVectorArray<>() , etc. If adding new options or parameters to a structure/quantity. Be sure to follow proper encapsulation principles (create getters & setters), and use a persistent values . Check out PointCloud::pointColor for a good basic example. Also, all length-valued quantities should use scaled values (as in PointCloud::pointRadius ).","title":"C++ implementation"},{"location":"about/contributing/#unit-testing","text":"Whenever possible, add a unit test that somehow exercises any new functionality or verifies that the bug has been fixed. Polyscope uses the googletest testing framework. See documentation there for test macros, executable options, etc. In a perfect world, we would actually test that the rendered output from Polyscope is pixel-perfect. However, this is hard for a lot of reasons, so instead most of our tests are just \u201csmoke tests\u201d that call functions with some dummy data and ensure no errors are thrown. In fact, these tests are often run on headless servers, where we cannot even initialize an openGL environment. For this reason, in addition to the usual openGL backend , we also have an openGL_mock backend ( implemented here ) for testing on headless servers. This backend cannot actually render anything, but still performs many rendering-related sanity checks. If making changes to the rendering engine & shaders, you may find that changes need to be mirrored in mock_gl_engine.cpp . To run unit tests locally on your own machine (here, via unix terminal commands), use cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j4 ./bin/polyscope-test backend = openGL3_glfw which should create a window onscreen and run tests for a few seconds. Additionally , run the tests again like ./bin/polyscope-test which will use the openGL_mock backend (you will not see anything onscreen). This is how testing will be performed on the headless CI servers. If both sets of tests pass without errors, you are good to go.","title":"Unit testing"},{"location":"about/contributing/#prs-automated-tests","text":"Once your feature seems ready and unit tests are passing, submit a pull request to the main repository . This will trigger continuous integration (CI) tests via Github Actions to automatically compile the code on a collection of windows/mac/linux machines with various compilers, and verify that tests pass. If there are any issues, a failed \u201ccheck\u201d will show on the pull request page which you can click to learn more. If this is your first contribution to Polyscope, a maintainer will need to manually approve the CI run (this is a github restriction). You are welcome to reach out in the PR chat to sort out any problems. We may request changes! If a PR ever goes more than a few days without a response feel free to ping @nmwsharp.","title":"PRs &amp; automated tests"},{"location":"about/contributing/#documentation","text":"Documentation is hosted in its own separate repository . Polyscope docs use the mkdocs documentation engine, with the mkdocs-material theme (this theme is quite large and adds significant functionality beyond base mkdocs). The documentation is written in a large collection of markdown files; it is not automatically scraped from the code, or code comments, etc, so we must manually keep it up to date. There are two duplicate copies of all the docs for C++ and Python, stored in parallel directories /cpp and /py . A few shared files and assets are stored in the /shared directory, or symlinked from the /py subdirectory to point to a file the /cpp directory. We try to keep these two parallel versions in sync as much as possible, only differing where necessary between C++ and Python. To preview the documentation while editing, first install the necessary packages with pip install mkdocs mkdocs-material==6.2.8 mkdocs-macros-plugin pygments . Then run python3 -m mkdocs serve (run this command from the /cpp directory to view C++ docs, and likewise for /py ). A local address will be printed to your terminal, which you can navigate to in-browser to see the docs. Hopefully editing the docs markdown files should be self-evident, you can mainly copy existing content & formatting. Any new files need to be added the manifests in mkdocs.yml . Don\u2019t forget to add a blurb to the release notes ! If you are not able to build the docs for any reason, it is fine to just edit the markdown files and submit a docs PR with that. To actually update the hosted documentation files online at polyscope.run, the documentation site needs to be recompiled and committed to the to the /docs subdirectory. The build_commit_push.sh script can handle this for you, rebuilding both C++ & Python docs and committing the result to the /docs subdirectory: sh build_commit_push.sh If you include these built docs changes in your PR, the webpage will automatically update when it is merged. Otherwise the maintainers (usually @nmwsharp) will need to run this command and commit the update after accepting your PR.","title":"Documentation"},{"location":"about/contributing/#python-bindings","text":"Python bindings for Polyscope are stored in their own separate repository . We use pybind11 to generate bindings. These bindings are kept as thin wrappers as much as possible, just doing a minimal translation between the C++ interface and typical Python calling conventions. The bindings are actually managed internally as two separate Python packages: polyscope_bindings (which contains the raw bindings generated by our pybind11 code), and the higher-level polyscope (which contains the actual, nice user-facing Python functions). The separation is because there is no way to write additional Python code in the pybind11-generated package, but we often want to do some translation and error checking on the Python side before invoking the bindings. As such, adding a binding generally means writing code in two places: Add a new pybind11 C++ binding, like those here Add a new Python wrapper function which calls the generated binding, like the ones here Note that a few stylistic conventions between Python and C++. In particular, we do not expose classes for quantities, but set options via optional keyword arguments when the quantity is added. The pybind11 C++ bindings take Eigen arrays as arguments, because pybind11 performs automatic translation between Eigen/numpy. Python binding unit tests are stored in /test/polyscope_test.py . As with C++, these are mainly just simple \u201csmoke tests\u201d which call the functions with dummy data and ensure no errors are thrown. All new bindings functions need a test! To build and test the bindings, first compile the bindings from the polyscope-py root directory like mkdir build cd build cmake .. make -j8 the run python polyscope_test.py . As you write code, these bindings must be recompiled to reflect any changes to the pybind11 C++. When testing, make sure there is not another copy of Polyscope for Python installed in your system, which might unintentionally be used instead of the development version! Also, the adjacent demo_app.py can be used for simple testing. Don\u2019t forget, the Python bindings have a parallel set of docs in the /py directory . Updates to Python should be reflected there. When all your tests are passing, create a pull request! As with C++, submitting a pull request to the Python bindings will trigger a cloud build and some automated checks. Actually deploying a new Python version to pip and conda package managers is a somewhat significant process, so we typically group together updates before cutting a new version. Ping @nmwsharp to get a new version deployed. Major and minor versions of the Python library are kept in-sync with the C++ library versions, whereas patch versions ( 1.2.4 \u2013> 1.2.5 ) are used for new updates to the Python bindings only.","title":"Python bindings"},{"location":"about/contributors/","text":"This page lists people who have contributed something to Polyscope, in no particular order. Thank you so much for you work! If you would like to be listed on this page, don\u2019t hesitate to ask. Nicholas Sharp Keenan Crane Yousuf Soliman Rohan Sawhney Chris Yu Mark Gillespie Connor Lin","title":"Contributors"},{"location":"about/dependencies/","text":"Polyscope stands on the shoulders of many outstanding open-source projects. These dependencies are all permissively licensed , and bundled with the project ; we just list them here to give due credit! Name Purpose Link GLFW Window and input management with openGL glfw.org Dear ImGui GUI interface (buttons, text boxes, etc) github.com/ocornut/imgui glad OpenGL loader (used on Windows/Linux) github.com/Dav1dde/glad glm Vector math and glsl utilities glm.g-truc.net stb Header-only libraries, esp. image loading github.com/nothings/stb json Read/write json text github.com/nlohmann/json mkdocs Doc generation mkdocs.org mkdocs-material Doc generation squidfunk.github.io/mkdocs-material/ googletest Unit testing github.com/google/googletest pybind11 (Python only) Python bindings github.com/pybind/pybind11 Eigen (Python only) numpy interop for bindings eigen.tuxfamily.org Additionally, Polyscope includes a few public-domain / permissively licensed assets. Some of the built-in matcaps are from the Blender project, and others were rendered using Blender. The built-in colormaps come from several sources as detailed on the colormap page , including Smith et. al. , cmocean , and matplotlib . The concrete texture on the ground is from cc0textures.com . Thank you, artists!","title":"Dependencies"},{"location":"about/license/","text":"The core Polyscope C++ library is released under an MIT license , and all of its dependencies are under similar permissive licenses (MIT, zlib, or public domain). These Python bindings are also released under an MIT license . The python bindings are generated using pybind11 , which is under a BSD 3-clause license, and Eigen , which is licensed under MPL2; again, these are permissive licenses. Polyscope is created and maintained by academics: citations let us know our work is having impact! Please cite Polyscope or otherwise give a shout-out if and when it contributes to published works. @misc { polyscope , title = {Polyscope} , author = {Nicholas Sharp and others} , note = {www.polyscope.run} , year = {2019} }","title":"License"},{"location":"about/release_notes/","text":"Release notes v1.3.0 Dec 1, 2021 Adds callbacks in Python and imgui bindings, high-performance mode for big point clouds, volume mesh inspection with slice planes, more slice plane config options, better control of structure transformations and scene extents, orthographic view, back face coloring options, advanced options for customizing ImGui, support for shared linking, and bug fixes. v1.2.0 July 29, 2021: Update to latest cpp version, moving forward major and minor version will be synced between the core cpp library and these bindings. Add volume meshes, slice planes, and transparent rendering. Support soft ground shadows, point clouds with variable radius, and back face culling options for surface meshes. Better programmatic camera controls. Generalize isoline support for all scalar quantities. Change the font. Overhaul to a more flexible shader system, internally, change default screenshot format back to png , fix size validation bugs with surface mesh, require explicit tangent spaces. v0.1.1 Sept 27, 2020: Update to latest cpp. Bind reset camera function. Bindings at cpp version v1.1.1 . v0.1.0 Apr 11, 2020: Initial release of Python bindings. Bindings at cpp version v1.1 .","title":"Release notes"},{"location":"about/release_notes/#release-notes","text":"v1.3.0 Dec 1, 2021 Adds callbacks in Python and imgui bindings, high-performance mode for big point clouds, volume mesh inspection with slice planes, more slice plane config options, better control of structure transformations and scene extents, orthographic view, back face coloring options, advanced options for customizing ImGui, support for shared linking, and bug fixes. v1.2.0 July 29, 2021: Update to latest cpp version, moving forward major and minor version will be synced between the core cpp library and these bindings. Add volume meshes, slice planes, and transparent rendering. Support soft ground shadows, point clouds with variable radius, and back face culling options for surface meshes. Better programmatic camera controls. Generalize isoline support for all scalar quantities. Change the font. Overhaul to a more flexible shader system, internally, change default screenshot format back to png , fix size validation bugs with surface mesh, require explicit tangent spaces. v0.1.1 Sept 27, 2020: Update to latest cpp. Bind reset camera function. Bindings at cpp version v1.1.1 . v0.1.0 Apr 11, 2020: Initial release of Python bindings. Bindings at cpp version v1.1 .","title":"Release notes"},{"location":"basics/camera_controls/","text":"These settings affect the 3D camera view in polyscope. It is often convenient to set them just before calling polyscope.init() , but they may generally be set anywhere. import polyscope as ps import numpy as np ps . set_navigation_style ( \"free\" ) ps . set_up_dir ( \"z_up\" ) # initialize ps . init () # set the camera pose explicitly ps . look_at (( 0. , 0. , 5. ), ( 1. , 1. , 1. )) # (alternately, use numpy vectors) ps . look_at ( np . array (( 0. , 0. , 5. )), np . array (( 1. , 1. , 1. ))) # show the GUI ps . show () Options set_navigation_style ( s ) navigation style The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse. This value can be manually set under the view menu of the ui. Programmatically, pass a string for the following settings: 'turntable' The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions. 'free' The camera is free to take any orientation, rotation is always about relative to the current camera. 'planar' The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data ). Default: 'turntable' . Example: import polyscope as ps ps . set_navigation_style ( \"free\" ) set_up_dir ( s ) up direction 3D data is typically oriented with some natural \u201cup\u201d direction, but not everyone agrees as to which coordinate axis is \u201cup\u201d. Computer graphics and vision often use a Y-up convention, where science and engineering more commonly use Z-up. This setting affects default orientation of the view, the behavior of some navigation styles (esp. turntable ), and the orientation of the ground plane. This value can be manually set under the view menu of the ui. Programmatically, the setting strings are: 'x_up' The positive X-axis is up. 'neg_x_up' The negative X-axis is up. 'y_up' The positive Y-axis is up. 'neg_y_up' The negative Y-axis is up. 'z_up' The positive Z-axis is up. 'neg_z_up' The negative Z-axis is up. Default: 'y_up' . Example: import polyscope as ps ps . set_up_dir ( \"z_up\" ) look_at ( camera_location , target , fly_to = False ) look at Set the camera to be located at the 3D position camera_location and looking at the 3D position target , both in world coordinates. The up direction for the camera is set to be the scene\u2019s up direction. If fly_to=True , the camera will smoothly animate to the new configuration. The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components. Example: polyscope . look_at (( 0. , 0. , 5. ), ( 1. , 1. , 1. )) look_at_dir ( camera_location , target , up_dir , fly_to = False ) Set the camera to be located at the 3D position camera_location and looking at the 3D position target , oriented with the up direction up_dir , all in world coordinates. If fly_to=True , the camera will smoothly animate to the new configuration. Note that setting the up direction for the camera view with this function is separate from the scene\u2019s up direction with set_up_dir() , which affects things like ground plane placement, and manual view manipulation. The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components. Example: polyscope . look_at_dir (( 0. , 0. , 5. ), ( 1. , 1. , 1. ), ( - 1. , - 1. , 0. )) reset_camera_to_home_view () reset camera to home view Reset the camera view to the home view (a reasonable default view scaled to the scene). Note: The \u201chome\u201d view is dependent on the data in the scene; it is computed from the bounding boxes of all registered structures to ensure that everything is nicely scaled and in view. As such, one should generally call this function after registering data. Example: ps . reset_camera_to_home_view () Orthographic view By default, Polyscope\u2019s view uses perspective projection . Perspective projections roughly correspond to how images are usually perceived by our eyes and cameras. Alternately orthographic projection is also supported. Orthographic projections are common in engineering and architecture, because they have the property that distances are preserved in the projected image, regardless of whether the object is near or far from the camera. In perspective mode, zooming (for instance, by manually scrolling the mouse) translates the camera forward in space. In orthographic mode, it instead adjusts the field of view without moving the camera. This is because counter-intuitively, translating the camera forward does not actually change the view in an orthographic projection! set_view_projection_mode ( mode_name ) set projection mode Set the camera view projection to be either orthographic or perspective (default). Example: # Enable the orthographic view ps . set_view_projection_mode ( \"orthographic\" ) # Go back to default perspective projection ps . set_view_projection_mode ( \"perspective\" )","title":"Camera Controls"},{"location":"basics/camera_controls/#options","text":"set_navigation_style ( s )","title":"Options"},{"location":"basics/camera_controls/#navigation-style","text":"The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse. This value can be manually set under the view menu of the ui. Programmatically, pass a string for the following settings: 'turntable' The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions. 'free' The camera is free to take any orientation, rotation is always about relative to the current camera. 'planar' The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data ). Default: 'turntable' . Example: import polyscope as ps ps . set_navigation_style ( \"free\" ) set_up_dir ( s )","title":"navigation style"},{"location":"basics/camera_controls/#up-direction","text":"3D data is typically oriented with some natural \u201cup\u201d direction, but not everyone agrees as to which coordinate axis is \u201cup\u201d. Computer graphics and vision often use a Y-up convention, where science and engineering more commonly use Z-up. This setting affects default orientation of the view, the behavior of some navigation styles (esp. turntable ), and the orientation of the ground plane. This value can be manually set under the view menu of the ui. Programmatically, the setting strings are: 'x_up' The positive X-axis is up. 'neg_x_up' The negative X-axis is up. 'y_up' The positive Y-axis is up. 'neg_y_up' The negative Y-axis is up. 'z_up' The positive Z-axis is up. 'neg_z_up' The negative Z-axis is up. Default: 'y_up' . Example: import polyscope as ps ps . set_up_dir ( \"z_up\" ) look_at ( camera_location , target , fly_to = False )","title":"up direction"},{"location":"basics/camera_controls/#look-at","text":"Set the camera to be located at the 3D position camera_location and looking at the 3D position target , both in world coordinates. The up direction for the camera is set to be the scene\u2019s up direction. If fly_to=True , the camera will smoothly animate to the new configuration. The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components. Example: polyscope . look_at (( 0. , 0. , 5. ), ( 1. , 1. , 1. )) look_at_dir ( camera_location , target , up_dir , fly_to = False ) Set the camera to be located at the 3D position camera_location and looking at the 3D position target , oriented with the up direction up_dir , all in world coordinates. If fly_to=True , the camera will smoothly animate to the new configuration. Note that setting the up direction for the camera view with this function is separate from the scene\u2019s up direction with set_up_dir() , which affects things like ground plane placement, and manual view manipulation. The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components. Example: polyscope . look_at_dir (( 0. , 0. , 5. ), ( 1. , 1. , 1. ), ( - 1. , - 1. , 0. )) reset_camera_to_home_view ()","title":"look at"},{"location":"basics/camera_controls/#reset-camera-to-home-view","text":"Reset the camera view to the home view (a reasonable default view scaled to the scene). Note: The \u201chome\u201d view is dependent on the data in the scene; it is computed from the bounding boxes of all registered structures to ensure that everything is nicely scaled and in view. As such, one should generally call this function after registering data. Example: ps . reset_camera_to_home_view ()","title":"reset camera to home view"},{"location":"basics/camera_controls/#orthographic-view","text":"By default, Polyscope\u2019s view uses perspective projection . Perspective projections roughly correspond to how images are usually perceived by our eyes and cameras. Alternately orthographic projection is also supported. Orthographic projections are common in engineering and architecture, because they have the property that distances are preserved in the projected image, regardless of whether the object is near or far from the camera. In perspective mode, zooming (for instance, by manually scrolling the mouse) translates the camera forward in space. In orthographic mode, it instead adjusts the field of view without moving the camera. This is because counter-intuitively, translating the camera forward does not actually change the view in an orthographic projection! set_view_projection_mode ( mode_name )","title":"Orthographic view"},{"location":"basics/camera_controls/#set-projection-mode","text":"Set the camera view projection to be either orthographic or perspective (default). Example: # Enable the orthographic view ps . set_view_projection_mode ( \"orthographic\" ) # Go back to default perspective projection ps . set_view_projection_mode ( \"perspective\" )","title":"set projection mode"},{"location":"basics/initializing/","text":"Initializing Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: import polyscope as ps # Initialize polyscope, creating graphics contexts and constructing a window. # Should be called exactly once. ps . init () # Build visualizations, here or in distant code # ... # ... # ... # Pass control flow to polyscope, displaying the interactive window. # Function will return when user closes the window. ps . show () # More of your code # ... # Show again. Data is preserved between calls to show() # unless explicitly removed. ps . show () Functions init() init() Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show() show() Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window. This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to show() .","title":"Initializing"},{"location":"basics/initializing/#initializing","text":"Once polyscope is a part of your project, creating visualizations is very easy. Polyscope needs to be initialized once, typically near the beginning of your program. Example: import polyscope as ps # Initialize polyscope, creating graphics contexts and constructing a window. # Should be called exactly once. ps . init () # Build visualizations, here or in distant code # ... # ... # ... # Pass control flow to polyscope, displaying the interactive window. # Function will return when user closes the window. ps . show () # More of your code # ... # Show again. Data is preserved between calls to show() # unless explicitly removed. ps . show ()","title":"Initializing"},{"location":"basics/initializing/#functions","text":"init()","title":"Functions"},{"location":"basics/initializing/#init","text":"Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization. Performs one-time work like setting up openGL and creating a window. show()","title":"init()"},{"location":"basics/initializing/#show","text":"Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window. This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to show() .","title":"show()"},{"location":"basics/parameters/","text":"Many structures and quantities in Polyscope have optional values which can be set to control their appearance or behavior, such as the radius of points in a point cloud or the color of a mesh. These values can generally be manually adjusted in the GUI, or set programmatically in code. This page documents special features in Polyscope which provide extra functionality while setting these parameters. Persistent values In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values . Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match. Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) ps_cloud . set_color (( 0.5 , 0.5 , 0.5 )) # the persistent value is recorded in the cache # ... later ... new_cloud = ps . register_point_cloud ( \"my cloud\" , new_points ); # new_cloud will automatically pick up the pointColor we set above, # since this point cloud has the same name Note that this persistence behavior applies even when variables are manually manipulated in the GUI. Scaled values Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. Many Polyscope parameters take a relative option, which is usually True by default, to set lengths relatively. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) # radius will be 0.05 * lengthScale when used ps_cloud . set_radius ( 0.05 ); ps_cloud . set_radius ( 0.05 , relative = True ); # same as previous (default is True) However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use. # radius will be 1.6 when used ps_cloud . set_radius ( 1.6 , relative = False ) Note that scaled values can be (and often are) used as persistent values , as described above; the two concepts are complementary.","title":"Parameters"},{"location":"basics/parameters/#persistent-values","text":"In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values . Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match. Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) ps_cloud . set_color (( 0.5 , 0.5 , 0.5 )) # the persistent value is recorded in the cache # ... later ... new_cloud = ps . register_point_cloud ( \"my cloud\" , new_points ); # new_cloud will automatically pick up the pointColor we set above, # since this point cloud has the same name Note that this persistence behavior applies even when variables are manually manipulated in the GUI.","title":"Persistent values"},{"location":"basics/parameters/#scaled-values","text":"Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. Many Polyscope parameters take a relative option, which is usually True by default, to set lengths relatively. ps_cloud = ps . get_point_cloud ( \"my cloud\" ) # radius will be 0.05 * lengthScale when used ps_cloud . set_radius ( 0.05 ); ps_cloud . set_radius ( 0.05 , relative = True ); # same as previous (default is True) However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use. # radius will be 1.6 when used ps_cloud . set_radius ( 1.6 , relative = False ) Note that scaled values can be (and often are) used as persistent values , as described above; the two concepts are complementary.","title":"Scaled values"},{"location":"basics/program_options/","text":"These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling polyscope.init() , but they may generally be set anywhere. import polyscope as ps # a few options ps . set_program_name ( \"important app\" ) ps . set_verbosity ( 0 ) ps . set_use_prefs_file ( False ) # initialize ps . init () Options set_program_name ( name ) program name A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: import polyscope as ps ps . set_program_name ( \"important app\" ) set_verbosity ( v ) verbosity How much useful info should polyscope print to stdout? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: import polyscope as ps ps . set_verbosity ( 0 ) set_print_prefix ( p ) print prefix A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: import polyscope as ps ps . set_print_prefix ( \"[MYAPP] \" ); # prints now look like \"[MYAPP] loaded openGL\" set_errors_throw_exceptions ( b ) errors throw execptions If true, errors in polyscope raise execptions. If false, a polyscope error is shown in the UI, but processing attempts to continue. Default: False . set_enable_render_error_checks ( b ) render error checks If true, the rendering subsystem will eagerly check for and report errors. This comes at some small performance cost, but can help catch problems. Default: True when compiled in Debug mode, False in Release mode (this python library is generally compiled in release mode) set_SSAA_factor ( n ) SSAA anti-aliasing factor Enable super-sampling anti-aliasing for a prettier rendered scene. SSAA renders the scene at multiple samples for each pixel, then averages them to resolve final pixel values. Cost scales quadratically with the value of this parameter, so it will quickly become expensive. Reasonable values are in the range 1 to 4 . Using 2 is generally sufficient for anti-aliasing. Default: 1 (no anti-aliasing) set_max_fps ( f ) max fps The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . set_use_prefs_file ( b ) use prefs file Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If False , if will be neither written nor read. Default: True . set_always_redraw ( b ) always redraw Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is True , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: False . set_build_gui ( b ) build gui This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope. If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs. Default: True . set_open_imgui_window_for_user_callback ( b ) open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like polyscope.imgui.Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: True . set_invoke_user_callback_for_nested_show ( b ) invoke user callback for nested show Suppose you call polyscope.show() , and within your callback, another instance of polyscope.show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope.show() . Default: False . set_give_focus_on_show ( b ) give focus on show If true, the Polyscope window will request focus from the window manager whenever show() is called. If false, the focus state will be left unchanged. Default: False .","title":"Program Options"},{"location":"basics/program_options/#options","text":"set_program_name ( name )","title":"Options"},{"location":"basics/program_options/#program-name","text":"A general name to use when referring to the program in window headings, etc. Default: Polyscope . Example: import polyscope as ps ps . set_program_name ( \"important app\" ) set_verbosity ( v )","title":"program name"},{"location":"basics/program_options/#verbosity","text":"How much useful info should polyscope print to stdout? Default: 1 . 0 print nothing 1 print occasionally >= 2 print a lot Example: import polyscope as ps ps . set_verbosity ( 0 ) set_print_prefix ( p )","title":"verbosity"},{"location":"basics/program_options/#print-prefix","text":"A string used as a prefix for all messages printed to the terminal by polyscope. Default: [polyscope] . Example: import polyscope as ps ps . set_print_prefix ( \"[MYAPP] \" ); # prints now look like \"[MYAPP] loaded openGL\" set_errors_throw_exceptions ( b )","title":"print prefix"},{"location":"basics/program_options/#errors-throw-execptions","text":"If true, errors in polyscope raise execptions. If false, a polyscope error is shown in the UI, but processing attempts to continue. Default: False . set_enable_render_error_checks ( b )","title":"errors throw execptions"},{"location":"basics/program_options/#render-error-checks","text":"If true, the rendering subsystem will eagerly check for and report errors. This comes at some small performance cost, but can help catch problems. Default: True when compiled in Debug mode, False in Release mode (this python library is generally compiled in release mode) set_SSAA_factor ( n )","title":"render error checks"},{"location":"basics/program_options/#ssaa-anti-aliasing-factor","text":"Enable super-sampling anti-aliasing for a prettier rendered scene. SSAA renders the scene at multiple samples for each pixel, then averages them to resolve final pixel values. Cost scales quadratically with the value of this parameter, so it will quickly become expensive. Reasonable values are in the range 1 to 4 . Using 2 is generally sufficient for anti-aliasing. Default: 1 (no anti-aliasing) set_max_fps ( f )","title":"SSAA anti-aliasing factor"},{"location":"basics/program_options/#max-fps","text":"The main loop will not run at more than maxFPS iterations per second. -1 disables, running the loop as fast as possible. Default: 60 . set_use_prefs_file ( b )","title":"max fps"},{"location":"basics/program_options/#use-prefs-file","text":"Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a json -formatted plaintext file called .polyscope.ini . This option controls the use of the preferences file. If False , if will be neither written nor read. Default: True . set_always_redraw ( b )","title":"use prefs file"},{"location":"basics/program_options/#always-redraw","text":"Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities. If this option is True , the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: False . set_build_gui ( b )","title":"always redraw"},{"location":"basics/program_options/#build-gui","text":"This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope. If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs. Default: True . set_open_imgui_window_for_user_callback ( b )","title":"build gui"},{"location":"basics/program_options/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like polyscope.imgui.Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: True . set_invoke_user_callback_for_nested_show ( b )","title":"open imgui window for user callback"},{"location":"basics/program_options/#invoke-user-callback-for-nested-show","text":"Suppose you call polyscope.show() , and within your callback, another instance of polyscope.show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope.show() . Default: False . set_give_focus_on_show ( b )","title":"invoke user callback for nested show"},{"location":"basics/program_options/#give-focus-on-show","text":"If true, the Polyscope window will request focus from the window manager whenever show() is called. If false, the focus state will be left unchanged. Default: False .","title":"give focus on show"},{"location":"basics/scene_options/","text":"These are settings which affect the visual display of the scene. It is often convenient to set them just before calling polyscope.init() , but they may generally be set anywhere. import polyscope as ps # enable auto centering and scaling ps . set_autocenter_structures ( True ) ps . set_autoscale_structures ( True ) # initialize ps . init () set_autocenter_structures ( b ) autocenter structures If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: False . set_autoscale_structures ( b ) autoscale structures If true, all structures will have their transform set to rescale their length to 1 immediately after being registered. This scales the content nicely in view, but obscures any important absolute world positions. Default: False . Extents By default, Polyscope computes a bounding box and length scale for the structures in the scene, and uses them to adjust the rendered view. For instance, the camera view is initially pointed at the center of the bounding box, and the length scale is used to set reasonable values for the radii of points, curves, and vectors. However, sometimes it important to fix these extents rather than automatically computing them from data. One such case is producing precisely consistent visualizations across many inputs which might have slightly different extents. Another is when outlier data makes the automatically-computed extents egregiously large. The settings below can be used to manually adjust these extents. These parameters can be adjust in the UI under [View] --> [Scene Extents] . Example: fix the length scale to the unit bounding box import polyscope as ps ps . init () ps . set_automatically_compute_scene_extents ( False ) ps . set_length_scale ( 1. ) low = np . array (( - 1 , - 1. , - 1. )) high = np . array (( 1. , 1. , 1. )) ps . set_bounding_box ( low , high ) get_length_scale () Get the current representative length scale for the scene. Returns a float. set_length_scale ( s ) Set a representative length scale for the scene. Takes a float. When Polyscope automatically computes this, most structures simply use the length of the diagonal of the bounding box. get_bounding_box () Get the current bounding box for the scene, in world coordinates. Returns a tuple of length-3 numpy vectors. The first and second elements of the tuple are the lower and upper corners of the bounding box, respectively. set_bounding_box ( low , high ) Set a bounding box for the scene, in world coordinates. Takes two length-3 numpy vectors, which are the lower and upper corners of the bounding box, respectively. set_automatically_compute_scene_extents ( b ) If true, the length scale and bounding box parameters will be automatically computed from the registered structures, and updated whenever a a structure is added or changed. If false, these parameters will be left unchanged. If set to false before the first structure is registered, you are required to set the bounding box and length scale manually. Takes a boolean. Default: true .","title":"Scene Options"},{"location":"basics/scene_options/#autocenter-structures","text":"If true, all structures will have their transform set to center their bounding box immediately after being registered. This centers the content nicely in view, but obscures any important absolute world positions. Default: False . set_autoscale_structures ( b )","title":"autocenter structures"},{"location":"basics/scene_options/#autoscale-structures","text":"If true, all structures will have their transform set to rescale their length to 1 immediately after being registered. This scales the content nicely in view, but obscures any important absolute world positions. Default: False .","title":"autoscale structures"},{"location":"basics/scene_options/#extents","text":"By default, Polyscope computes a bounding box and length scale for the structures in the scene, and uses them to adjust the rendered view. For instance, the camera view is initially pointed at the center of the bounding box, and the length scale is used to set reasonable values for the radii of points, curves, and vectors. However, sometimes it important to fix these extents rather than automatically computing them from data. One such case is producing precisely consistent visualizations across many inputs which might have slightly different extents. Another is when outlier data makes the automatically-computed extents egregiously large. The settings below can be used to manually adjust these extents. These parameters can be adjust in the UI under [View] --> [Scene Extents] . Example: fix the length scale to the unit bounding box import polyscope as ps ps . init () ps . set_automatically_compute_scene_extents ( False ) ps . set_length_scale ( 1. ) low = np . array (( - 1 , - 1. , - 1. )) high = np . array (( 1. , 1. , 1. )) ps . set_bounding_box ( low , high ) get_length_scale () Get the current representative length scale for the scene. Returns a float. set_length_scale ( s ) Set a representative length scale for the scene. Takes a float. When Polyscope automatically computes this, most structures simply use the length of the diagonal of the bounding box. get_bounding_box () Get the current bounding box for the scene, in world coordinates. Returns a tuple of length-3 numpy vectors. The first and second elements of the tuple are the lower and upper corners of the bounding box, respectively. set_bounding_box ( low , high ) Set a bounding box for the scene, in world coordinates. Takes two length-3 numpy vectors, which are the lower and upper corners of the bounding box, respectively. set_automatically_compute_scene_extents ( b ) If true, the length scale and bounding box parameters will be automatically computed from the registered structures, and updated whenever a a structure is added or changed. If false, these parameters will be left unchanged. If set to false before the first structure is registered, you are required to set the bounding box and length scale manually. Takes a boolean. Default: true .","title":"Extents"},{"location":"features/2D_data/","text":"Polyscope is primarily focused on 3D data, but can also be used for 2D visualization. This section descibes a few helpers which make it easier to do so. Adding 2D data Functions which accept 3D positions (or vectors) as input can alternately takes 2D positions, and append a 0 z-coordinate. In Python (unlike the C++ api), we can use 2D data by simply passing it as the argument of a function which would otherwise take 3D data. For instance, register_point_cloud(name, data) normally expects data to be a Nx3 array of 3D positions, but passing an Nx2 array also works just fine. Any other functions which don\u2019t take 3D positions can be used as normal, like add_scalar_quantity() . Planar camera mode The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: ps.set_navigation_style(\"planar\")","title":"2D Data"},{"location":"features/2D_data/#adding-2d-data","text":"Functions which accept 3D positions (or vectors) as input can alternately takes 2D positions, and append a 0 z-coordinate. In Python (unlike the C++ api), we can use 2D data by simply passing it as the argument of a function which would otherwise take 3D data. For instance, register_point_cloud(name, data) normally expects data to be a Nx3 array of 3D positions, but passing an Nx2 array also works just fine. Any other functions which don\u2019t take 3D positions can be used as normal, like add_scalar_quantity() .","title":"Adding 2D data"},{"location":"features/2D_data/#planar-camera-mode","text":"The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to Planar . In the UI, this option is in the main Polyscope window, set to Turntable by default. Setting the camera mode to Planar will also hide the ground plane. To set this option programmatically, use: ps.set_navigation_style(\"planar\")","title":"Planar camera mode"},{"location":"features/callbacks_and_UIs/","text":"When polyscope.show() has been called, Polyscope will optionally invoke user-supplied callback function as each frame of the interface is redrawn. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc. Setting a per-frame callback Pass in a Python function (with no arguments and no return value), and Polyscope will execute it as each frame of the interface is drawn. Example: import polyscope as ps ps . init () def callback (): # Executed every frame # Do computation here, define custom UIs, etc. print ( \"executing callback\" ) polyscope . set_user_callback ( callback ) ps . show () ps . clear_user_callback () set_user_callback ( func ) set_user_callback Set a function which will be called by polyscope on every UI draw iteration. The argument should be a Python function, which takes no arguments. clear_user_callback () clear_user_callback Clear the callback function. Creating custom UIs One of the most important uses of the per-frame callback is to define custom UIs. You can use these UIs to add buttons which execute custom functions, adjust the value of parameters, display information, etc. Polyscope uses Dear ImGui as an immediate-mode UI framework. Please see the documentation there to understand the basic paradigm and capabilities. The Polyscope python package includes bindings to a significant subset of ImGui in the polyscope.imgui submodule. These bindings are not yet exhaustively documented, but they follow the naming conventions of ImGui as closely as possible for simplicity. Documentation of ImGui functions and parameters lives here , and you can find the list of bound functions, types, and enums here . Common usage should be covered by the example below. Example: Create the following UI in a Python callback import polyscope as ps import polyscope.imgui as psim # A bunch of parameters which we will manipulate via the UI defined below. # There is nothing special about these variables, you could manipulate any other # kind of Python values the same way, such as entries in a dict, or class members. is_true1 = False is_true2 = True ui_int = 7 ui_float1 = - 3.2 ui_float2 = 0.8 ui_color3 = ( 1. , 0.5 , 0.5 ) ui_color4 = ( 0.3 , 0.5 , 0.5 , 0.8 ) ui_angle_rad = 0.2 ui_text = \"some input text\" ui_options = [ \"option A\" , \"option B\" , \"option C\" ] ui_options_selected = ui_options [ 1 ] def my_function (): # ... do something important here ... print ( \"executing function\" ) # Define our callback function, which Polyscope will repeatedly execute while running the UI. # We can write any code we want here, but in particular it is an opportunity to create ImGui # interface elements and define a custom UI. def callback (): # If we want to use local variables & assign to them in the UI code below, # we need to mark them as nonlocal. This is because of how Python scoping # rules work, not anything particular about Polyscope or ImGui. # Of course, you can also use any other kind of python variable as a controllable # value in the UI, such as a value from a dictionary, or a class member. Just be # sure to assign the result of the ImGui call to the value, as in the examples below. nonlocal is_true1 , is_true2 , ui_int , ui_float1 , ui_float2 , ui_color3 , ui_color4 , ui_text , ui_options_selected , ui_angle_rad # == Settings # Use settings like this to change the UI appearance. # Note that it is a push/pop pair, with the matching pop() below. psim . PushItemWidth ( 150 ) # == Show text in the UI psim . TextUnformatted ( \"Some sample text\" ) psim . TextUnformatted ( \"An important value: {} \" . format ( 42 )) psim . Separator () # == Buttons if ( psim . Button ( \"A button\" )): # This code is executed when the button is pressed print ( \"Hello\" ) # By default, each element goes on a new line. Use this # to put the next element on the _same_ line. psim . SameLine () if ( psim . Button ( \"Another button\" )): # This code is executed when the button is pressed my_function () # == Set parameters # These commands allow the user to adjust the value of variables. # It is important that we assign the return result to the variable to # update it. # For most elements, the return is actually a tuple `(changed, newval)`, # where `changed` indicates whether the setting was modified on this # frame, and `newval` gives the new value of the variable (or the same # old value if unchanged). # # For numeric inputs, ctrl-click on the box to type in a value. # Checkbox changed , is_true1 = psim . Checkbox ( \"flag1\" , is_true1 ) if ( changed ): # optionally, use this conditional to take action on the new value pass psim . SameLine () changed , is_true2 = psim . Checkbox ( \"flag2\" , is_true2 ) # Input ints changed , ui_int = psim . InputInt ( \"ui_int\" , ui_int , step = 1 , step_fast = 10 ) # Input floats using two different styles of widget changed , ui_float1 = psim . InputFloat ( \"ui_float1\" , ui_float1 ) psim . SameLine () changed , ui_float2 = psim . SliderFloat ( \"ui_float2\" , ui_float2 , v_min =- 5 , v_max = 5 ) # Input colors changed , ui_color3 = psim . ColorEdit3 ( \"ui_color3\" , ui_color3 ) psim . SameLine () changed , ui_color4 = psim . ColorEdit4 ( \"ui_color4\" , ui_color4 ) # Input text changed , ui_text = psim . InputText ( \"enter text\" , ui_text ) # Combo box to choose from options # There, the options are a list of strings in `ui_options`, # and the currently selected element is stored in `ui_options_selected`. psim . PushItemWidth ( 200 ) changed = psim . BeginCombo ( \"Pick one\" , ui_options_selected ) if changed : for val in ui_options : if psim . Selectable ( val , ui_options_selected == val ): ui_options_selected = val psim . EndCombo () psim . PopItemWidth () # Use tree headers to logically group options # This a stateful option to set the tree node below to be open initially. # The second argument is a flag, which works like a bitmask. # Many ImGui elements accept flags to modify their behavior. psim . SetNextItemOpen ( True , psim . ImGuiCond_FirstUseEver ) # The body is executed only when the sub-menu is open. Note the push/pop pair! if ( psim . TreeNode ( \"Collapsible sub-menu\" )): psim . TextUnformatted ( \"Detailed information\" ) if ( psim . Button ( \"sub-button\" )): print ( \"hello\" ) # There are many different UI elements offered by ImGui, many of which # are bound in python by Polyscope. See ImGui's documentation in `imgui.h`, # or the polyscope bindings in `polyscope/src/cpp/imgui.cpp`. changed , ui_angle_rad = psim . SliderAngle ( \"ui_float2\" , ui_angle_rad , v_degrees_min =- 90 , v_degrees_max = 90 ) psim . TreePop () psim . PopItemWidth () ps . init () ps . set_user_callback ( callback ) ps . show () Options set_build_gui ( b ) build gui This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope. If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs. Default: True . set_open_imgui_window_for_user_callback ( b ) open imgui window for user callback If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like polyscope.imgui.Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: True . set_invoke_user_callback_for_nested_show ( b ) invoke user callback for nested show Suppose you call polyscope.show() , and within your callback, another instance of polyscope.show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope.show() . Default: False . set_give_focus_on_show ( b ) give focus on show If true, the Polyscope window will request focus from the window manager whenever show() is called. If false, the focus state will be left unchanged. Default: False .","title":"Callbacks & Custom UIs"},{"location":"features/callbacks_and_UIs/#setting-a-per-frame-callback","text":"Pass in a Python function (with no arguments and no return value), and Polyscope will execute it as each frame of the interface is drawn. Example: import polyscope as ps ps . init () def callback (): # Executed every frame # Do computation here, define custom UIs, etc. print ( \"executing callback\" ) polyscope . set_user_callback ( callback ) ps . show () ps . clear_user_callback () set_user_callback ( func )","title":"Setting a per-frame callback"},{"location":"features/callbacks_and_UIs/#set_user_callback","text":"Set a function which will be called by polyscope on every UI draw iteration. The argument should be a Python function, which takes no arguments. clear_user_callback ()","title":"set_user_callback"},{"location":"features/callbacks_and_UIs/#clear_user_callback","text":"Clear the callback function.","title":"clear_user_callback"},{"location":"features/callbacks_and_UIs/#creating-custom-uis","text":"One of the most important uses of the per-frame callback is to define custom UIs. You can use these UIs to add buttons which execute custom functions, adjust the value of parameters, display information, etc. Polyscope uses Dear ImGui as an immediate-mode UI framework. Please see the documentation there to understand the basic paradigm and capabilities. The Polyscope python package includes bindings to a significant subset of ImGui in the polyscope.imgui submodule. These bindings are not yet exhaustively documented, but they follow the naming conventions of ImGui as closely as possible for simplicity. Documentation of ImGui functions and parameters lives here , and you can find the list of bound functions, types, and enums here . Common usage should be covered by the example below. Example: Create the following UI in a Python callback import polyscope as ps import polyscope.imgui as psim # A bunch of parameters which we will manipulate via the UI defined below. # There is nothing special about these variables, you could manipulate any other # kind of Python values the same way, such as entries in a dict, or class members. is_true1 = False is_true2 = True ui_int = 7 ui_float1 = - 3.2 ui_float2 = 0.8 ui_color3 = ( 1. , 0.5 , 0.5 ) ui_color4 = ( 0.3 , 0.5 , 0.5 , 0.8 ) ui_angle_rad = 0.2 ui_text = \"some input text\" ui_options = [ \"option A\" , \"option B\" , \"option C\" ] ui_options_selected = ui_options [ 1 ] def my_function (): # ... do something important here ... print ( \"executing function\" ) # Define our callback function, which Polyscope will repeatedly execute while running the UI. # We can write any code we want here, but in particular it is an opportunity to create ImGui # interface elements and define a custom UI. def callback (): # If we want to use local variables & assign to them in the UI code below, # we need to mark them as nonlocal. This is because of how Python scoping # rules work, not anything particular about Polyscope or ImGui. # Of course, you can also use any other kind of python variable as a controllable # value in the UI, such as a value from a dictionary, or a class member. Just be # sure to assign the result of the ImGui call to the value, as in the examples below. nonlocal is_true1 , is_true2 , ui_int , ui_float1 , ui_float2 , ui_color3 , ui_color4 , ui_text , ui_options_selected , ui_angle_rad # == Settings # Use settings like this to change the UI appearance. # Note that it is a push/pop pair, with the matching pop() below. psim . PushItemWidth ( 150 ) # == Show text in the UI psim . TextUnformatted ( \"Some sample text\" ) psim . TextUnformatted ( \"An important value: {} \" . format ( 42 )) psim . Separator () # == Buttons if ( psim . Button ( \"A button\" )): # This code is executed when the button is pressed print ( \"Hello\" ) # By default, each element goes on a new line. Use this # to put the next element on the _same_ line. psim . SameLine () if ( psim . Button ( \"Another button\" )): # This code is executed when the button is pressed my_function () # == Set parameters # These commands allow the user to adjust the value of variables. # It is important that we assign the return result to the variable to # update it. # For most elements, the return is actually a tuple `(changed, newval)`, # where `changed` indicates whether the setting was modified on this # frame, and `newval` gives the new value of the variable (or the same # old value if unchanged). # # For numeric inputs, ctrl-click on the box to type in a value. # Checkbox changed , is_true1 = psim . Checkbox ( \"flag1\" , is_true1 ) if ( changed ): # optionally, use this conditional to take action on the new value pass psim . SameLine () changed , is_true2 = psim . Checkbox ( \"flag2\" , is_true2 ) # Input ints changed , ui_int = psim . InputInt ( \"ui_int\" , ui_int , step = 1 , step_fast = 10 ) # Input floats using two different styles of widget changed , ui_float1 = psim . InputFloat ( \"ui_float1\" , ui_float1 ) psim . SameLine () changed , ui_float2 = psim . SliderFloat ( \"ui_float2\" , ui_float2 , v_min =- 5 , v_max = 5 ) # Input colors changed , ui_color3 = psim . ColorEdit3 ( \"ui_color3\" , ui_color3 ) psim . SameLine () changed , ui_color4 = psim . ColorEdit4 ( \"ui_color4\" , ui_color4 ) # Input text changed , ui_text = psim . InputText ( \"enter text\" , ui_text ) # Combo box to choose from options # There, the options are a list of strings in `ui_options`, # and the currently selected element is stored in `ui_options_selected`. psim . PushItemWidth ( 200 ) changed = psim . BeginCombo ( \"Pick one\" , ui_options_selected ) if changed : for val in ui_options : if psim . Selectable ( val , ui_options_selected == val ): ui_options_selected = val psim . EndCombo () psim . PopItemWidth () # Use tree headers to logically group options # This a stateful option to set the tree node below to be open initially. # The second argument is a flag, which works like a bitmask. # Many ImGui elements accept flags to modify their behavior. psim . SetNextItemOpen ( True , psim . ImGuiCond_FirstUseEver ) # The body is executed only when the sub-menu is open. Note the push/pop pair! if ( psim . TreeNode ( \"Collapsible sub-menu\" )): psim . TextUnformatted ( \"Detailed information\" ) if ( psim . Button ( \"sub-button\" )): print ( \"hello\" ) # There are many different UI elements offered by ImGui, many of which # are bound in python by Polyscope. See ImGui's documentation in `imgui.h`, # or the polyscope bindings in `polyscope/src/cpp/imgui.cpp`. changed , ui_angle_rad = psim . SliderAngle ( \"ui_float2\" , ui_angle_rad , v_degrees_min =- 90 , v_degrees_max = 90 ) psim . TreePop () psim . PopItemWidth () ps . init () ps . set_user_callback ( callback ) ps . show ()","title":"Creating custom UIs"},{"location":"features/callbacks_and_UIs/#options","text":"set_build_gui ( b )","title":"Options"},{"location":"features/callbacks_and_UIs/#build-gui","text":"This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope. If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs. Default: True . set_open_imgui_window_for_user_callback ( b )","title":"build gui"},{"location":"features/callbacks_and_UIs/#open-imgui-window-for-user-callback","text":"If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like polyscope.imgui.Button(\"do stuff\") . If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any). Default: True . set_invoke_user_callback_for_nested_show ( b )","title":"open imgui window for user callback"},{"location":"features/callbacks_and_UIs/#invoke-user-callback-for-nested-show","text":"Suppose you call polyscope.show() , and within your callback, another instance of polyscope.show() is called\u2014this is a nested show. Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option. If true, your callback will be executed as normal for every main loop iteration, even in nested show windows. If false, your callback will only be executed for initial, outermost calls to polyscope.show() . Default: False . set_give_focus_on_show ( b )","title":"invoke user callback for nested show"},{"location":"features/callbacks_and_UIs/#give-focus-on-show","text":"If true, the Polyscope window will request focus from the window manager whenever show() is called. If false, the focus state will be left unchanged. Default: False .","title":"give focus on show"},{"location":"features/color_maps/","text":"Built-in color maps Different color maps are appropriate for different situations: sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below). diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases 0 semantially means \u201cnothing\u201d, and the endpoints have opposite meaning. cyclic maps data defined on the circle, like an angle decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes Polyscope supports the following built-in color maps: Name Type String Key viridis sequential viridis blues sequential blues reds sequential reds coolwarm diverging coolwarm pink-green diverging pink-green phase cyclic phase spectral decorative spectral rainbow decorative rainbow jet decorative jet turbo decorative turbo Loading custom color maps Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from [Appearance] --> [Color maps] --> [Load color map] , or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting stb_image can read). load_color_map ( cmap_name , filename ) load_color_map Load a new colormap from the image file filename , which will be assigned the name cmap_name . Example: import polyscope as ps ps . load_color_map ( \"fancy cmap\" , \"my_cmap.png\" ) Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9 Phase is from the cmocean package. link \u21a9 Turbo is by Anton Mikhailov and others at Google. link \u21a9 The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib . \u21a9","title":"Color Maps"},{"location":"features/color_maps/#built-in-color-maps","text":"Different color maps are appropriate for different situations: sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below). diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases 0 semantially means \u201cnothing\u201d, and the endpoints have opposite meaning. cyclic maps data defined on the circle, like an angle decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes Polyscope supports the following built-in color maps: Name Type String Key viridis sequential viridis blues sequential blues reds sequential reds coolwarm diverging coolwarm pink-green diverging pink-green phase cyclic phase spectral decorative spectral rainbow decorative rainbow jet decorative jet turbo decorative turbo","title":"Built-in color maps"},{"location":"features/color_maps/#loading-custom-color-maps","text":"Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from [Appearance] --> [Color maps] --> [Load color map] , or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting stb_image can read). load_color_map ( cmap_name , filename )","title":"Loading custom color maps"},{"location":"features/color_maps/#load_color_map","text":"Load a new colormap from the image file filename , which will be assigned the name cmap_name . Example: import polyscope as ps ps . load_color_map ( \"fancy cmap\" , \"my_cmap.png\" ) Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9 Phase is from the cmocean package. link \u21a9 Turbo is by Anton Mikhailov and others at Google. link \u21a9 The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib . \u21a9","title":"load_color_map"},{"location":"features/ground_and_shadows/","text":"The Polyscope scene view includes a ground plane which optionally supports reflection and soft-shadow effects. This section outlines the various modes and options available for the ground plane. Ground plane and shadow modes none no ground plane, nor reflection/shadows are shown tile a tiled ground plane tile_reflection a tiled ground plane with a reflection of the scene (default) shadow_only a transparent ground plane with a soft vertical shadow of the scene The ground plane and shadow settings can also be manually adjusted in the GUI under the [Appearance] --> [Ground Plane] menu. Example: adjust the ground plane & shadow appearance import polyscope as ps ps . init () # set soft shadows on the ground ps . set_ground_plane_mode ( \"shadow_only\" ) # set +Z as up direction ps . set_ground_plane_height_factor ( - 0.25 ) # adjust the plane height ps . set_shadow_darkness ( 0.1 ) # lighter shadows # ... load your mesh, point cloud, etc ... # take screenshot from the current camera view, which will have transparent shadows ps . screenshot ( \"test_image.png\" , True ); # open the GUI ps . show ( 3 ) set_ground_plane_mode ( mode_str ) Set the mode used for the ground plane, as described above. Should be one of none , tile , tile_reflection , or shadow_only . Default: tile_reflection . Some more details: the ground plane is automatically faded away whenever the scene is viewed from underneath the ground, and also faded away in the distance far from the scene, as determined by the scene bounding box. Shadows are properly transparent, exporting a screenshot with transparency will set alpha = shadow_darkness values for shadowed areas, and set alpha=0 for unshadowed parts of the ground plane. The shadow_blur_iters and shadow_darkness parameters below adjust the visual appearance of soft shadows for the ground plane mode shadow_only . set_shadow_blur_iters ( i ) The number of blur iterations used to blur soft shadows. Increase to make the shadows more fuzzy. Default: 2 . set_shadow_darkness ( val ) How dark the shadows are. 0 is totally transparent (white), and 1 is fully black. When taking screenshots with transparency, these will become alpha transparency values for the shadowed regions. Default: .25 . Ground plane positioning The orientation of the ground plane is determined by the up direction for the scene , which can be set along any of the coordinate directions such as +X , -Z , etc. The height of the ground plane is set by default from the bounding box of the scene. The options::groundPlaneHeightFactor can be set to adjust the relative offset of the ground plane from the bounding box. set_ground_plane_height_factor ( x , is_relative = True ) The offset of the ground plane from the bottom of the bounding box for the scene. Use postive/negative values to shift the ground plane up/down. This parameter is a scaled value . By default, values will be interpreted relative to the scene length scale, whereas calling set_ground_plane_height_factor(0.1, is_relative=False) will specify a value in absolute units. Default: 0 .","title":"Ground and Shadows"},{"location":"features/ground_and_shadows/#ground-plane-and-shadow-modes","text":"none no ground plane, nor reflection/shadows are shown tile a tiled ground plane tile_reflection a tiled ground plane with a reflection of the scene (default) shadow_only a transparent ground plane with a soft vertical shadow of the scene The ground plane and shadow settings can also be manually adjusted in the GUI under the [Appearance] --> [Ground Plane] menu. Example: adjust the ground plane & shadow appearance import polyscope as ps ps . init () # set soft shadows on the ground ps . set_ground_plane_mode ( \"shadow_only\" ) # set +Z as up direction ps . set_ground_plane_height_factor ( - 0.25 ) # adjust the plane height ps . set_shadow_darkness ( 0.1 ) # lighter shadows # ... load your mesh, point cloud, etc ... # take screenshot from the current camera view, which will have transparent shadows ps . screenshot ( \"test_image.png\" , True ); # open the GUI ps . show ( 3 ) set_ground_plane_mode ( mode_str ) Set the mode used for the ground plane, as described above. Should be one of none , tile , tile_reflection , or shadow_only . Default: tile_reflection . Some more details: the ground plane is automatically faded away whenever the scene is viewed from underneath the ground, and also faded away in the distance far from the scene, as determined by the scene bounding box. Shadows are properly transparent, exporting a screenshot with transparency will set alpha = shadow_darkness values for shadowed areas, and set alpha=0 for unshadowed parts of the ground plane. The shadow_blur_iters and shadow_darkness parameters below adjust the visual appearance of soft shadows for the ground plane mode shadow_only . set_shadow_blur_iters ( i ) The number of blur iterations used to blur soft shadows. Increase to make the shadows more fuzzy. Default: 2 . set_shadow_darkness ( val ) How dark the shadows are. 0 is totally transparent (white), and 1 is fully black. When taking screenshots with transparency, these will become alpha transparency values for the shadowed regions. Default: .25 .","title":"Ground plane and shadow modes"},{"location":"features/ground_and_shadows/#ground-plane-positioning","text":"The orientation of the ground plane is determined by the up direction for the scene , which can be set along any of the coordinate directions such as +X , -Z , etc. The height of the ground plane is set by default from the bounding box of the scene. The options::groundPlaneHeightFactor can be set to adjust the relative offset of the ground plane from the bounding box. set_ground_plane_height_factor ( x , is_relative = True ) The offset of the ground plane from the bottom of the bounding box for the scene. Use postive/negative values to shift the ground plane up/down. This parameter is a scaled value . By default, values will be interpreted relative to the scene length scale, whereas calling set_ground_plane_height_factor(0.1, is_relative=False) will specify a value in absolute units. Default: 0 .","title":"Ground plane positioning"},{"location":"features/materials/","text":"Polyscope uses matcaps to render the appearance of objects in the scene, as opposed to more traditional configurations of lights and shading models, etc. A matcap is a small image of a material, which is sampled by the renderer to query the materials\u2019 appearance from a some angle. Scene information like lighting is implicitly baked in to the matcap image. Most objects in Polyscope (surface meshes, point clouds, vectors, etc) expose a material = 'matname' option to choose a material for the object\u2019s appearance. Additionally, materials can generally be set in the UI from [Options] --> [Material] . Blended materials In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities). Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps. How it works Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components. At runtime, to generate a color from a triple of rgb values each in the range [0,1] , we sample the images like: outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color. Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space. Materials which which support this blending are denoted by (rgb) in the options menu. Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options. Built-in materials Polyscope supports the following built-in materials: Name String Key Blendable Image clay clay yes wax wax yes candy candy yes flat flat yes mud 1 mud no ceramic 1 ceramic no jade 1 jade no normal 1 normal no Loading custom materials Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from [Appearance] --> [Materials] --> [Load material] , or programatically using the function below. For blendable matcaps, if the single filename mat.hdr is given, Polyscope will try to load mat_r.hdr , mat_g.hdr , etc. Ideally, matcap images should be linear .hdr images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with intensity=1 and gamma=2.2 before use. Most common image formats are accepted (anything stb_image can read). load_static_material ( mat_name , filename ) load_static_material Load a new static (non-blendable) material from a single image file filename . The new material will be called mat_nam . Example: import polyscope as ps ps . load_static_material ( \"fancy mat\" , \"my_image.png\" ) load_blendable_material ( mat_name , filenames = None , filename_base = None , filename_ext = None ) load_blendable_material Load a new blendable material, which will be called matName . There are two different ways to specify which files to load the material images from: Specify filenames , a tuple of four string filenames corresponding to red, green, blue, and black basis materials Specify filename_base , and filename_ext , to generate the four filenames as filename_base + \"_r\" + filename_ext , etc. Example: import polyscope as ps ps . load_blendable_material ( \"fancy blendable mat\" , filenames = ( \"my_image_r.png\" , \"my_image_g.png\" , \"my_image_b.png\" , \"my_image_k.png\" )) # OR ps . load_blendable_material ( \"fancy blendable mat\" , filename_base = \"my_image\" , filename_ext = \".png\" ) The matcaps are from the Blender matcap repository, available under a CC0/public domain license . Thanks to the Blender community for contributing them! \u21a9 \u21a9 \u21a9 \u21a9","title":"Materials"},{"location":"features/materials/#blended-materials","text":"In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities). Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps. How it works Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components. At runtime, to generate a color from a triple of rgb values each in the range [0,1] , we sample the images like: outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color. Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space. Materials which which support this blending are denoted by (rgb) in the options menu. Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options.","title":"Blended materials"},{"location":"features/materials/#built-in-materials","text":"Polyscope supports the following built-in materials: Name String Key Blendable Image clay clay yes wax wax yes candy candy yes flat flat yes mud 1 mud no ceramic 1 ceramic no jade 1 jade no normal 1 normal no","title":"Built-in materials"},{"location":"features/materials/#loading-custom-materials","text":"Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from [Appearance] --> [Materials] --> [Load material] , or programatically using the function below. For blendable matcaps, if the single filename mat.hdr is given, Polyscope will try to load mat_r.hdr , mat_g.hdr , etc. Ideally, matcap images should be linear .hdr images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with intensity=1 and gamma=2.2 before use. Most common image formats are accepted (anything stb_image can read). load_static_material ( mat_name , filename )","title":"Loading custom materials"},{"location":"features/materials/#load_static_material","text":"Load a new static (non-blendable) material from a single image file filename . The new material will be called mat_nam . Example: import polyscope as ps ps . load_static_material ( \"fancy mat\" , \"my_image.png\" ) load_blendable_material ( mat_name , filenames = None , filename_base = None , filename_ext = None )","title":"load_static_material"},{"location":"features/materials/#load_blendable_material","text":"Load a new blendable material, which will be called matName . There are two different ways to specify which files to load the material images from: Specify filenames , a tuple of four string filenames corresponding to red, green, blue, and black basis materials Specify filename_base , and filename_ext , to generate the four filenames as filename_base + \"_r\" + filename_ext , etc. Example: import polyscope as ps ps . load_blendable_material ( \"fancy blendable mat\" , filenames = ( \"my_image_r.png\" , \"my_image_g.png\" , \"my_image_b.png\" , \"my_image_k.png\" )) # OR ps . load_blendable_material ( \"fancy blendable mat\" , filename_base = \"my_image\" , filename_ext = \".png\" ) The matcaps are from the Blender matcap repository, available under a CC0/public domain license . Thanks to the Blender community for contributing them! \u21a9 \u21a9 \u21a9 \u21a9","title":"load_blendable_material"},{"location":"features/messages/","text":"Using messages We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: import polyscope as ps ps . init () # Generate a single warning. # Has no effect on the GUI until polyscope gets control flow # back, which happens here in the show() call below. ps . warning ( \"Something went slightly wrong\" ) # Generate a lot of warnings. Becase all of these warnings # have the same base message (the first string), they will # be batched together and only shown as one dialog. The detail # message for the first such warning will also be shown. for i in range ( 5000 ): ps . warning ( \"Some problems come in groups\" , \"some details: \" + str ( i )) # The previous warnings would be displayed here ps . show () # Generating an error. # The UI will block and show this error immediately. After # the error is dismissed, the call will return. ps . error ( \"Resistance is futile.\" ); Messages info ( message ) info Simply logs a message to stdout . warning ( message , detail = \"\" ) warning Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detail field need not be used. However, if issuing warnings in a loop, warnings with the same base message are batched together, so the UI doesn\u2019t get completely overwhelmed (see example above). error ( message ) error Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns.","title":"Messages"},{"location":"features/messages/#using-messages","text":"We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging. Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way. There are a few levels of messages available: error A very bad error; immediately shows and blocks the UI for user response. warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program. info A low-priority message, which is just printed to stdout . Messages can be dismissed by clicking the button in dialog box, or pressing [space] . Example: import polyscope as ps ps . init () # Generate a single warning. # Has no effect on the GUI until polyscope gets control flow # back, which happens here in the show() call below. ps . warning ( \"Something went slightly wrong\" ) # Generate a lot of warnings. Becase all of these warnings # have the same base message (the first string), they will # be batched together and only shown as one dialog. The detail # message for the first such warning will also be shown. for i in range ( 5000 ): ps . warning ( \"Some problems come in groups\" , \"some details: \" + str ( i )) # The previous warnings would be displayed here ps . show () # Generating an error. # The UI will block and show this error immediately. After # the error is dismissed, the call will return. ps . error ( \"Resistance is futile.\" );","title":"Using messages"},{"location":"features/messages/#messages","text":"info ( message )","title":"Messages"},{"location":"features/messages/#info","text":"Simply logs a message to stdout . warning ( message , detail = \"\" )","title":"info"},{"location":"features/messages/#warning","text":"Create a warning message, to be displayed the next time the UI gets flow control. When issuing a one-off warning, the detail field need not be used. However, if issuing warnings in a loop, warnings with the same base message are batched together, so the UI doesn\u2019t get completely overwhelmed (see example above). error ( message )","title":"warning"},{"location":"features/messages/#error","text":"Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns.","title":"error"},{"location":"features/screenshots/","text":"Polyscope includes simple functionality for saving screenshots from the current camera view to disk. The ImGUI interface windows will be automatically hidden when taking a screenshot. Screenshots can be taken manually by pressing the [screenshot] button in the options GUI window, or programmatically using the functions below. Clicking the GUI button generates a numbered screenshot file in the current directory; the arrow to the side of the button can be used to adjust file format and transparency settings for these screenshots. It is not necessary to call show() before taking screenshots. You can set up you scene and programmatically configure the camera view , then call screenshot() to save a rendered image to disk, all without any user interaction. Example: Register a mesh, position the camera, and take a screenshot import polyscope as ps # Initialize ps . init () # Register a mesh verts = # ... your data ... faces = # ... your data ... ps_mesh = ps . register_surface_mesh ( \"my mesh\" , verts , faces ) # Position the camera ps . look_at (( 0. , 0. , 5. ), ( 1. , 1. , 1. )) # Adjust some screenshot default settings if you'd like ps . set_screenshot_extension ( \".jpg\" ); # Take a screenshot # It will be written to your current directory as screenshot_000000.jpg, etc ps . screenshot () screenshot ( filename = None , transparent_bg = True ) Saves a screenshot to the path given as filename , with format inferred from the file extension. The extension should be one of .png , or .jpg . If no name is is given, screenshots are saved to the current directory, with file named like screenshot_000000.png numbered automatically in increasing order. The numbering is reset to 0 for each run of the program; existing files will be silently overwritten. If transparent_bg is true , the background will be rendered as transparent, and set as transparency alpha in the saved image if the file format supports it. set_screenshot_extension ( ext ) screenshot extension Set the extension used when taking automatically-numbered screenshots, either with screenshot() or by clicking the GUI button. The extension should be .png , or .jpg .","title":"Screenshots"},{"location":"features/screenshots/#screenshot-extension","text":"Set the extension used when taking automatically-numbered screenshots, either with screenshot() or by clicking the GUI button. The extension should be .png , or .jpg .","title":"screenshot extension"},{"location":"features/slice_planes/","text":"Geometric data often has complex internal structures. Slice planes can be added to the scene to cull away parts of an object and inspect its interior. These planes can be manipulated either programmatically or manually in the GUI. Your browser does not support the video tag. Example : sweep a slice plane through the scene to produce the animation above import numpy as np import polyscope as ps ps . init () # Read & register the mesh vertices = # your vertices faces = # your faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # Add a slice plane ps_plane = ps . add_scene_slice_plane () ps_plane . set_draw_plane ( True ) # render the semi-transparent gridded plane ps_plane . set_draw_widget ( True ) # Animate the plane sliding along the scene for t in np . linspace ( 0. , 2 * np . pi , 120 ): pos = np . cos ( t ) * .8 + .2 ps_plane . set_pose (( 0. , 0. , pos ), ( 0. , 0. , - 1. )) # Take a screenshot at each frame ps . screenshot ( transparent_bg = False ) Slice planes can also be manipulated in the GUI under [View] --> [Slice Planes] , where you can add and remove slice planes and control whether they are active and widgets are visible. When a plane is active in the scene, you can drag the 3D widget to adjust its pose. Additionally, for each structure, [Options] --> [Slice Planes] allows you to toggle whether the slice plane effects that structure. Creating and modifying slice planes SlicePlane add_scene_slice_plane () add slice plane Add a new slice plane to the scene and return it. An arbitrary number of slices planes may be added. remove_last_scene_slice_plane () remove slice plane Remove the most recently created slice plane. SlicePlane . get_name () name Get the unique name of the slice plane. SlicePlane . set_pose ( plane_position , plane_normal ) set pose Set the position and orientation of the slice plane. plane_position is any 3D position which the plane touches (the center of the plane) plane_normal is a vector giving the normal direction of the plane, objects in this negative side of the plane will be culled These input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components. SlicePlane . set_active ( val ) active Set the slice plane to be active or not. If inactive, the slice plane will not have any effect on any structures in the scene, nor will it be shown in the GUI view. SlicePlane . get_active () Test whether the slice plane is active. SlicePlane . set_draw_plane ( val ) draw plane Set the slice plane to draw its plane (as a colored, semi-transparent grid). If False the slice plane will still slice objects, but the plane itself will not be rendered. SlicePlane . get_draw_plane () Test whether the slice plane is drawing its plane. SlicePlane . set_draw_widget ( val ) draw widget Set the slice plane to draw its control widget (a grey and colored cube with handles for translations and rotations). If False the slice plane will still slice objects, but the widget will not be rendered. Note that regardless of this setting, the widget will not be visible in any screenshots by default, because it is treated as part of the GUI interface, like the ImGUI widow panes. SlicePlane . get_draw_widget () Test whether the slice plane is drawing its widget. Per-structure ignore slice planes By default, every slice plane affects all content in the scene. However, we can also make a particular structure ignore a given slice plane, so that it only slices through some of the objects in the scene. This can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_plane = ps . add_scene_slice_plane () ps_mesh . set_ignore_slice_plane ( ps_plane , True ) Structure . set_ignore_slice_plane ( plane , val ) ignore plane Set a slice plane to be ignored by the structure. If val is True the slice plane will be ignored, and if False it will be respected. plane can be passed as a plane object or as a string giving the name of a plane. Structure . get_ignore_slice_plane ( plane ) Test if a slice plane is currently being ignored by the structure. plane can be passed as a plane object or as a string giving the name of a plane. Cull whole elements For some structures, slice planes can be set to discretely cull away whole elements, rather than slicing directly through the middle of an element. This option can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_plane = ps . add_scene_slice_plane () ps_mesh . set_cull_whole_elements ( False ) Structure . set_cull_whole_elements ( val ) set cull whole elements If True , slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Note that not all structures may support culling whole elements. If not supported, this setting will do nothing. Structure . get_cull_whole_elements () Test whether the cull whole elements setting is applied. Inspecting volume meshes Slice planes can also inspect volume meshes, rendering a surface where the structure is cut by the plane. Not only does this help to visualize the interior of the shape, but scalar and color quantities can be drawn along the plane to better inspect values on the interior of the mesh. This can also be set in the UI under [View] --> [Slice Planes] --> [Inspect] . This option will only be available when there is at least one volume mesh in the scene. If the volume mesh has a vertex scalar or vertex color quantity enabled, it will be automatically drawn on the inspecting slice plane. SlicePlane . set_volume_mesh_to_inspect ( meshNameStr ) Give the name of a volume mesh to inspect. Pass the empty string \"\" to clear the inspection. SlicePlane . get_volume_mesh_to_inspect () Get the volume mesh being inspected. Returns a string.","title":"Slice Planes"},{"location":"features/slice_planes/#creating-and-modifying-slice-planes","text":"SlicePlane add_scene_slice_plane ()","title":"Creating and modifying slice planes"},{"location":"features/slice_planes/#add-slice-plane","text":"Add a new slice plane to the scene and return it. An arbitrary number of slices planes may be added. remove_last_scene_slice_plane ()","title":"add slice plane"},{"location":"features/slice_planes/#remove-slice-plane","text":"Remove the most recently created slice plane. SlicePlane . get_name ()","title":"remove slice plane"},{"location":"features/slice_planes/#name","text":"Get the unique name of the slice plane. SlicePlane . set_pose ( plane_position , plane_normal )","title":"name"},{"location":"features/slice_planes/#set-pose","text":"Set the position and orientation of the slice plane. plane_position is any 3D position which the plane touches (the center of the plane) plane_normal is a vector giving the normal direction of the plane, objects in this negative side of the plane will be culled These input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components. SlicePlane . set_active ( val )","title":"set pose"},{"location":"features/slice_planes/#active","text":"Set the slice plane to be active or not. If inactive, the slice plane will not have any effect on any structures in the scene, nor will it be shown in the GUI view. SlicePlane . get_active () Test whether the slice plane is active. SlicePlane . set_draw_plane ( val )","title":"active"},{"location":"features/slice_planes/#draw-plane","text":"Set the slice plane to draw its plane (as a colored, semi-transparent grid). If False the slice plane will still slice objects, but the plane itself will not be rendered. SlicePlane . get_draw_plane () Test whether the slice plane is drawing its plane. SlicePlane . set_draw_widget ( val )","title":"draw plane"},{"location":"features/slice_planes/#draw-widget","text":"Set the slice plane to draw its control widget (a grey and colored cube with handles for translations and rotations). If False the slice plane will still slice objects, but the widget will not be rendered. Note that regardless of this setting, the widget will not be visible in any screenshots by default, because it is treated as part of the GUI interface, like the ImGUI widow panes. SlicePlane . get_draw_widget () Test whether the slice plane is drawing its widget.","title":"draw widget"},{"location":"features/slice_planes/#per-structure-ignore-slice-planes","text":"By default, every slice plane affects all content in the scene. However, we can also make a particular structure ignore a given slice plane, so that it only slices through some of the objects in the scene. This can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_plane = ps . add_scene_slice_plane () ps_mesh . set_ignore_slice_plane ( ps_plane , True ) Structure . set_ignore_slice_plane ( plane , val )","title":"Per-structure ignore slice planes"},{"location":"features/slice_planes/#ignore-plane","text":"Set a slice plane to be ignored by the structure. If val is True the slice plane will be ignored, and if False it will be respected. plane can be passed as a plane object or as a string giving the name of a plane. Structure . get_ignore_slice_plane ( plane ) Test if a slice plane is currently being ignored by the structure. plane can be passed as a plane object or as a string giving the name of a plane.","title":"ignore plane"},{"location":"features/slice_planes/#cull-whole-elements","text":"For some structures, slice planes can be set to discretely cull away whole elements, rather than slicing directly through the middle of an element. This option can be set in the GUI for each structure under [Options] --> [Slice Planes] , or programatically with the function below. ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_plane = ps . add_scene_slice_plane () ps_mesh . set_cull_whole_elements ( False ) Structure . set_cull_whole_elements ( val )","title":"Cull whole elements"},{"location":"features/slice_planes/#set-cull-whole-elements","text":"If True , slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Note that not all structures may support culling whole elements. If not supported, this setting will do nothing. Structure . get_cull_whole_elements () Test whether the cull whole elements setting is applied.","title":"set cull whole elements"},{"location":"features/slice_planes/#inspecting-volume-meshes","text":"Slice planes can also inspect volume meshes, rendering a surface where the structure is cut by the plane. Not only does this help to visualize the interior of the shape, but scalar and color quantities can be drawn along the plane to better inspect values on the interior of the mesh. This can also be set in the UI under [View] --> [Slice Planes] --> [Inspect] . This option will only be available when there is at least one volume mesh in the scene. If the volume mesh has a vertex scalar or vertex color quantity enabled, it will be automatically drawn on the inspecting slice plane. SlicePlane . set_volume_mesh_to_inspect ( meshNameStr ) Give the name of a volume mesh to inspect. Pass the empty string \"\" to clear the inspection. SlicePlane . get_volume_mesh_to_inspect () Get the volume mesh being inspected. Returns a string.","title":"Inspecting volume meshes"},{"location":"features/transparency/","text":"The Polyscope rendering framework supports transparency to visualize complicated data with nested internal structures. Example: register a surface mesh and render it with transparency import polyscope as ps ps . init () # Add a mesh with transparency # ... load verts and faces ... ps_mesh = ps . register_surface_mesh ( \"mesh\" , verts , faces , transparency = 0.7 ) # As soon as any structure has transparency set, the transparency mode # is automatically changed to 'pretty' (depth peeling). It can be further # changed like: ps . set_transparency_mode ( 'simple' ) # take screenshot from the current camera view, # which will have transparency according to the structure ps . screenshot ( \"test_image.png\" , True ); # open the GUI ps . show ( 3 ) Transparency modes In computer graphics, rendering scenes with transparent content is surprisingly difficult and often computationally expensive. Polyscope supports three different modes for transparent rendering: 'none' is the default, which does not use any transparency and ignores any related settings. 'simple' uses an approximation which takes a weighted average of objects in view. The benefit is that this method is efficient, only slightly more expensive than normal rendering. However, it ignores the relative depth of different objects, and thus can yield noticeable and confusing artifacts on complex scenes. Generally, this method should only be used when rendering performance is a concern (i.e., if the view is otherwise too laggy to use). 'pretty' implements expensive-but-accurate \u201ctrue\u201d transparency, which properly accounts for objects at different depths. This mode is implemented using depth peeling , which internally renders the scene many times to generate each frame. Because many internal render passes are needed, this mode may be dramatically more expensive than normal rendering, leading to a laggy interface. The parameter configured with set_transparency_render_passes() controls the number passes performed (default: 8 ); smaller values will reduce the performance hit, whereas larger values may be necessary to resolve complex scenes. The modes are set via set_transparency_mode . Initially, the transparency mode is set to 'none' . However, if the transparency of any object is modified while the mode is 'none' , the mode will be automatically updated to 'pretty' so that the effect is visible. Any ground plane reflections are disabled when using transparency. The transparency mode can also be changed in the GUI in the [Appearance] --> [Transparency] menu. set_transparency_mode ( mode_str ) Set the mode used for transparent rendering. One of 'none' , 'simple' , or 'pretty' (see above for explanation). Default: 'none' . Automatically updated when a transparency value is set for some structure. set_transparency_render_passes ( n ) The number of passes used for 'pretty' mode. Lower values will reduce the performance impact, but larger values may be necessary to resolve transparency in complex scenes. Default: 8 . Setting structure transparency Transparency is controlled via a real-valued parameter from 0 to 1 , commonly called \u201calpha\u201d. Setting transparency to 1 means completely opaque (the default), whereas 0 means completely transparent. This parameter is specified on a per-structure basis via Structure.set_transparency(val) , or by using a transparency keyword argument when registering the structure. Transparency for each structure can also be modified in the GUI by selecting [Options] --> [Transparency] for the structure. Structure . set_transparency ( val ) Set the transparency for a structure, 1 means completely opaque (the default), whereas 0 means completely transparent. Example: ps_mesh = polyscope . register_surface_mesh ( \"mesh\" , verts , faces ) ps_mesh . set_transparency ( 0.5 )","title":"Transparency"},{"location":"features/transparency/#transparency-modes","text":"In computer graphics, rendering scenes with transparent content is surprisingly difficult and often computationally expensive. Polyscope supports three different modes for transparent rendering: 'none' is the default, which does not use any transparency and ignores any related settings. 'simple' uses an approximation which takes a weighted average of objects in view. The benefit is that this method is efficient, only slightly more expensive than normal rendering. However, it ignores the relative depth of different objects, and thus can yield noticeable and confusing artifacts on complex scenes. Generally, this method should only be used when rendering performance is a concern (i.e., if the view is otherwise too laggy to use). 'pretty' implements expensive-but-accurate \u201ctrue\u201d transparency, which properly accounts for objects at different depths. This mode is implemented using depth peeling , which internally renders the scene many times to generate each frame. Because many internal render passes are needed, this mode may be dramatically more expensive than normal rendering, leading to a laggy interface. The parameter configured with set_transparency_render_passes() controls the number passes performed (default: 8 ); smaller values will reduce the performance hit, whereas larger values may be necessary to resolve complex scenes. The modes are set via set_transparency_mode . Initially, the transparency mode is set to 'none' . However, if the transparency of any object is modified while the mode is 'none' , the mode will be automatically updated to 'pretty' so that the effect is visible. Any ground plane reflections are disabled when using transparency. The transparency mode can also be changed in the GUI in the [Appearance] --> [Transparency] menu. set_transparency_mode ( mode_str ) Set the mode used for transparent rendering. One of 'none' , 'simple' , or 'pretty' (see above for explanation). Default: 'none' . Automatically updated when a transparency value is set for some structure. set_transparency_render_passes ( n ) The number of passes used for 'pretty' mode. Lower values will reduce the performance impact, but larger values may be necessary to resolve transparency in complex scenes. Default: 8 .","title":"Transparency modes"},{"location":"features/transparency/#setting-structure-transparency","text":"Transparency is controlled via a real-valued parameter from 0 to 1 , commonly called \u201calpha\u201d. Setting transparency to 1 means completely opaque (the default), whereas 0 means completely transparent. This parameter is specified on a per-structure basis via Structure.set_transparency(val) , or by using a transparency keyword argument when registering the structure. Transparency for each structure can also be modified in the GUI by selecting [Options] --> [Transparency] for the structure. Structure . set_transparency ( val ) Set the transparency for a structure, 1 means completely opaque (the default), whereas 0 means completely transparent. Example: ps_mesh = polyscope . register_surface_mesh ( \"mesh\" , verts , faces ) ps_mesh . set_transparency ( 0.5 )","title":"Setting structure transparency"},{"location":"installing/","text":"Polyscope supports Python 3.5-3.9 with prebuilt binaries on all major operating systems. At runtime, your environment must support OpenGL >= 3.3 core , and have the ability to open windows in a display. This includes nearly all modern desktop/laptop computers, but not all headless servers and virtual machines. Installing from PyPi with pip python -m pip install polyscope # or maybe python3 -m pip install polyscope Using python -m pip install rather than just pip install helps when your system has multiple version of Python installed, ensuring the correct pip is used. Just be sure python refers to the install of Python you intend to use. Ideally, this install will resolve to a precompiled wheel for your platform\u2014see troubleshooting if not. Otherwise, the setup script will compile the Polyscope C++ library from source, which may take a few minutes, and requires a suitable C++ toolchain (see building from source ). Troubleshooting On common platforms, pip should always be able to install from a binary .whl file. If it fails to select a binary wheel, it will try to compile from source, leading to long install times or compilation errors if your toolchain is not configured. Here are some common fixes: Ensure you\u2019re targeting the latest Polyscope python -m pip install polyscope --upgrade Very old versions of pip may not be able to use the precompiled wheels. Upgrade pip with python -m pip install pip --upgrade . Precompiled wheels are available on pip for Python 3.5-3.9 (aka most common versions), check yours with python --version , and update your Python install if needed. Source installs with PyPI Despite our best efforts, the precompiled binaries still may not work on some platforms. You can intentionally instruct pip to build the library from source using: python -m pip install polyscope --no-binary polyscope This may take a few minutes, and requires a suitable C++ toolchain (see building from source ). Installing from Conda conda install -c conda-forge polyscope Installing manually To manually download the sources: git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py Polyscope can then by installed with pip as python -m pip install . Or manually installed with the setup script using python setup.py install Building from source If a pre-compiled wheel is not available, the setup scripts (either run automatically via pip or manually with setup.py ) will need to compile the underlying C++ library. Your system must have a suitable C++ compiler available to build Polyscope, as well as build tools like CMake installed. The Polyscope C++ repository has a few more details about compiling. Polyscope is a 3D graphics program, so it may be difficult to build on servers without graphics support, or extremely old machines. In particular, OpenGL >= 3.3 core is a strict requirement. Development builds To compile Polyscope locally without setup.py (e.g., if you are developing the library) use git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py mkdir build && cd build cmake .. make -j4 this will generate a file something like polyscope_bindings.cpython-36m-x86_64-linux-gnu.so (the particular name depends on your platform), which contains the low-level bindings to C++ Polyscope. This is a pybind11 build; it can be further customized using any pybind11 CMake options, for instance to choose which version of Python is used. The actual Polyscope python library lives in src/polyscope , which is a wrapper around these low-level bindings. You are now ready to import polyscope , so long as both the compiled bindings and src/polyscope can be found on your PYTHONPATH .","title":"Installing"},{"location":"installing/#installing-from-pypi-with-pip","text":"python -m pip install polyscope # or maybe python3 -m pip install polyscope Using python -m pip install rather than just pip install helps when your system has multiple version of Python installed, ensuring the correct pip is used. Just be sure python refers to the install of Python you intend to use. Ideally, this install will resolve to a precompiled wheel for your platform\u2014see troubleshooting if not. Otherwise, the setup script will compile the Polyscope C++ library from source, which may take a few minutes, and requires a suitable C++ toolchain (see building from source ).","title":"Installing from PyPi with pip"},{"location":"installing/#troubleshooting","text":"On common platforms, pip should always be able to install from a binary .whl file. If it fails to select a binary wheel, it will try to compile from source, leading to long install times or compilation errors if your toolchain is not configured. Here are some common fixes: Ensure you\u2019re targeting the latest Polyscope python -m pip install polyscope --upgrade Very old versions of pip may not be able to use the precompiled wheels. Upgrade pip with python -m pip install pip --upgrade . Precompiled wheels are available on pip for Python 3.5-3.9 (aka most common versions), check yours with python --version , and update your Python install if needed.","title":"Troubleshooting"},{"location":"installing/#source-installs-with-pypi","text":"Despite our best efforts, the precompiled binaries still may not work on some platforms. You can intentionally instruct pip to build the library from source using: python -m pip install polyscope --no-binary polyscope This may take a few minutes, and requires a suitable C++ toolchain (see building from source ).","title":"Source installs with PyPI"},{"location":"installing/#installing-from-conda","text":"conda install -c conda-forge polyscope","title":"Installing from Conda"},{"location":"installing/#installing-manually","text":"To manually download the sources: git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py Polyscope can then by installed with pip as python -m pip install . Or manually installed with the setup script using python setup.py install","title":"Installing manually"},{"location":"installing/#building-from-source","text":"If a pre-compiled wheel is not available, the setup scripts (either run automatically via pip or manually with setup.py ) will need to compile the underlying C++ library. Your system must have a suitable C++ compiler available to build Polyscope, as well as build tools like CMake installed. The Polyscope C++ repository has a few more details about compiling. Polyscope is a 3D graphics program, so it may be difficult to build on servers without graphics support, or extremely old machines. In particular, OpenGL >= 3.3 core is a strict requirement.","title":"Building from source"},{"location":"installing/#development-builds","text":"To compile Polyscope locally without setup.py (e.g., if you are developing the library) use git clone --recursive https://github.com/nmwsharp/polyscope-py.git cd polyscope-py mkdir build && cd build cmake .. make -j4 this will generate a file something like polyscope_bindings.cpython-36m-x86_64-linux-gnu.so (the particular name depends on your platform), which contains the low-level bindings to C++ Polyscope. This is a pybind11 build; it can be further customized using any pybind11 CMake options, for instance to choose which version of Python is used. The actual Polyscope python library lives in src/polyscope , which is a wrapper around these low-level bindings. You are now ready to import polyscope , so long as both the compiled bindings and src/polyscope can be found on your PYTHONPATH .","title":"Development builds"},{"location":"structures/structure_management/","text":"A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields. Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) Then, in a distant part of your code, add a scalar function to it with: ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"some values\" , values ) This avoids the need to pass a reference to the structure you created around your entire codebase. Alternately, one can directly use the handle returned by register_surface_mesh() , instead of keying on a name string. The following structures available in Polyscope. Many more structures are in development! Surface Mesh Point Cloud Curve Network Volume Mesh in progress : Camera View Registering structures Each structure offers a register___(name, ...) function (like register_point_cloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a structure object which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions. Accessing structures Polyscope offers two patterns for calling methods on a registered structure: you can either use the handle returned after structure creation, or refer to the structure by name. import polyscope as ps # register a structure ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # access with the handle ps_mesh . add_scalar_quantity ( \"some values\" , values ) # access by name ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"some values\" , values ) The former is concise and programmatic, while the latter avoids the need to keep track of a variable. As before, each structure offers a get___(name) method, like get_surface_mesh(name) which can be used to get a handle to the structure of that type by name. Removing structures If no longer needed, structures can be removed by name or by handle. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. import polyscope as ps # register a structure and some data ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . add_scalar_quantity ( \"some values\" , values ) # look at it ps . show () # (user exits ui) # remove the structure # (these two forms are equivalent, choose one) ps_mesh . remove () ps . remove_surface_mesh ( \"my_mesh\" ) # actually, just remove everything ps . remove_all_structures () Structure options These basic options are shared by all structures. Structure options are managed as persistent values , and thus will persist if a new structure is registered with the same name. Enabled If a structure is disabled, it will be hidden from view, along with any quantities associated with that structure. Structure . is_enabled () Is the structure enabled? Returns a boolean. Structure . set_enabled ( newVal = True ) Set the structure to be enabled or disabled. Takes a boolean. Can also be set when registering, like register_point_cloud(..., enabled=True) . Transparency Set the transparency parameter for the structure. 1 is fully opaque (the default), and 0 is fully transparent. When the first structure has transparency applied, transparent rendering will be automatically enabled. Transparency can be controlled in the UI via the structure\u2019s [Options] --> [Transparency] menu. Structure . get_transparency () Get the transparency parameter for the structure. Returns a float Structure . set_transparency ( alpha ) Set the transparancy for the structure. Takes a float. Can also be set when registering, like register_point_cloud(..., transparency=0.5) . Transforms Each structure has an associated spatial transform applied to it for display in the scene. The transform encodes a translation, rotation, and scaling represented as a 4x4 homogeneous matrix. Initially this transformation is just the identity transform (it does nothing), but it can be adjusted to position the structures in your scene. The transform can be controlled in the UI via the structure\u2019s [Options] --> [Transform] menu. Structure . center_bounding_box () Set the transformation such that the structure\u2019s bounding box is centered at the world origin. Structure . rescale_to_unit () Set the transformation scaling such that the structure has length scale 1. This makes all structures roughly the same size. Structure . reset_transform () Reset the structure\u2019s transform to be the identity transform (i.e. to do nothing). Structure . set_transparency ( transform ) Set a particular transform matrix. Takes a 4x4 numpy array. Structure . set_position ( vec ) Set the transformation matrix such that structure is transformed to the position vec . Takes a length-3 numpy vector. Structure . translate ( vec ) Translate the transformation matrix by offset vec . Takes a length-3 numpy vector. Structure . get_transform () Get the current transformation matrix. Returns a 4x4 numpy matrix. Structure . get_position () Get the translation component of the transformation matrix, the position to which the structure\u2019s origin is translated. Returns a length-3 numpy vector. Slice planes Options relating to slice planes which may be present in the scene. Slice plane options can be controlled in the UI via the structure\u2019s [Options] --> [Slice Planes] menu. Structure . set_cull_whole_elements ( newVal ) If true , slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Takes a boolean. Note that not all structures may support culling whole elements. If not supported, this setting will do nothing. Default: false. Structure . get_cull_whole_elements () Get whether the cull whole elements setting is applied. Returns a boolean. Structure . set_ignore_slice_plane ( name , newValue ) Set a slice plane to be ignored by the structure. If newValue is true the slice plane will be ignored, and if false it will be respected. Takes a string and a boolean. Structure . get_ignore_slice_plane ( name ) Get if a slice plane is currently being ignored by the structure. Takes a string, returns a boolean.","title":"Structure Management"},{"location":"structures/structure_management/#registering-structures","text":"Each structure offers a register___(name, ...) function (like register_point_cloud() ) which accepts the name of the structure and the data necessary to construct it. These functions will return a structure object which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions.","title":"Registering structures"},{"location":"structures/structure_management/#accessing-structures","text":"Polyscope offers two patterns for calling methods on a registered structure: you can either use the handle returned after structure creation, or refer to the structure by name. import polyscope as ps # register a structure ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # access with the handle ps_mesh . add_scalar_quantity ( \"some values\" , values ) # access by name ps . get_surface_mesh ( \"my mesh\" ) . add_scalar_quantity ( \"some values\" , values ) The former is concise and programmatic, while the latter avoids the need to keep track of a variable. As before, each structure offers a get___(name) method, like get_surface_mesh(name) which can be used to get a handle to the structure of that type by name.","title":"Accessing structures"},{"location":"structures/structure_management/#removing-structures","text":"If no longer needed, structures can be removed by name or by handle. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities. import polyscope as ps # register a structure and some data ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . add_scalar_quantity ( \"some values\" , values ) # look at it ps . show () # (user exits ui) # remove the structure # (these two forms are equivalent, choose one) ps_mesh . remove () ps . remove_surface_mesh ( \"my_mesh\" ) # actually, just remove everything ps . remove_all_structures ()","title":"Removing structures"},{"location":"structures/structure_management/#structure-options","text":"These basic options are shared by all structures. Structure options are managed as persistent values , and thus will persist if a new structure is registered with the same name.","title":"Structure options"},{"location":"structures/structure_management/#enabled","text":"If a structure is disabled, it will be hidden from view, along with any quantities associated with that structure. Structure . is_enabled () Is the structure enabled? Returns a boolean. Structure . set_enabled ( newVal = True ) Set the structure to be enabled or disabled. Takes a boolean. Can also be set when registering, like register_point_cloud(..., enabled=True) .","title":"Enabled"},{"location":"structures/structure_management/#transparency","text":"Set the transparency parameter for the structure. 1 is fully opaque (the default), and 0 is fully transparent. When the first structure has transparency applied, transparent rendering will be automatically enabled. Transparency can be controlled in the UI via the structure\u2019s [Options] --> [Transparency] menu. Structure . get_transparency () Get the transparency parameter for the structure. Returns a float Structure . set_transparency ( alpha ) Set the transparancy for the structure. Takes a float. Can also be set when registering, like register_point_cloud(..., transparency=0.5) .","title":"Transparency"},{"location":"structures/structure_management/#transforms","text":"Each structure has an associated spatial transform applied to it for display in the scene. The transform encodes a translation, rotation, and scaling represented as a 4x4 homogeneous matrix. Initially this transformation is just the identity transform (it does nothing), but it can be adjusted to position the structures in your scene. The transform can be controlled in the UI via the structure\u2019s [Options] --> [Transform] menu. Structure . center_bounding_box () Set the transformation such that the structure\u2019s bounding box is centered at the world origin. Structure . rescale_to_unit () Set the transformation scaling such that the structure has length scale 1. This makes all structures roughly the same size. Structure . reset_transform () Reset the structure\u2019s transform to be the identity transform (i.e. to do nothing). Structure . set_transparency ( transform ) Set a particular transform matrix. Takes a 4x4 numpy array. Structure . set_position ( vec ) Set the transformation matrix such that structure is transformed to the position vec . Takes a length-3 numpy vector. Structure . translate ( vec ) Translate the transformation matrix by offset vec . Takes a length-3 numpy vector. Structure . get_transform () Get the current transformation matrix. Returns a 4x4 numpy matrix. Structure . get_position () Get the translation component of the transformation matrix, the position to which the structure\u2019s origin is translated. Returns a length-3 numpy vector.","title":"Transforms"},{"location":"structures/structure_management/#slice-planes","text":"Options relating to slice planes which may be present in the scene. Slice plane options can be controlled in the UI via the structure\u2019s [Options] --> [Slice Planes] menu. Structure . set_cull_whole_elements ( newVal ) If true , slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Takes a boolean. Note that not all structures may support culling whole elements. If not supported, this setting will do nothing. Default: false. Structure . get_cull_whole_elements () Get whether the cull whole elements setting is applied. Returns a boolean. Structure . set_ignore_slice_plane ( name , newValue ) Set a slice plane to be ignored by the structure. If newValue is true the slice plane will be ignored, and if false it will be respected. Takes a string and a boolean. Structure . get_ignore_slice_plane ( name ) Get if a slice plane is currently being ignored by the structure. Takes a string, returns a boolean.","title":"Slice planes"},{"location":"structures/curve_network/basics/","text":"Curve Networks Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point! Registering a curve network Curve network structures can be registered with Polyscope by passing the node position and edge indices. Polyscope also makes it easy to automatically construct lines and loops by just passing edges='line' or edges='loop' . Example: a network of random curves import numpy as np import polyscope as ps ps . init () # generate some random nodes and edges between them nodes = np . random . rand ( 100 , 3 ) edges = np . random . randint ( 0 , 100 , size = ( 250 , 2 )) # visualize! ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) ps . show () register_curve_network ( name , nodes , edges , enabled = None , radius = None , color = None , material = None ) Add a new curve network structure to Polyscope. name string, a name for the structure nodes , an Nx3 numpy float array of node locations (or Nx2 for 2D) edges , an Ex2 numpy integer array of edge connections, as 0-based indices in to the nodes array, OR the string line / loop , to generate node connectivity as a line or loop, respectively. Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the nodes and edges relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the network as rgb in [0,1] material string, name of material to use for network if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D node positions are also supported, see 2D data . Updating a curve network The locations of the nodes in a curve network can be updated with the member function update_node_positions(newPositions) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). CurveNetwork . update_node_positions ( newPos ) Update the node positions in a curve network structure. newPos must be valid input as to initially construct the nodes of the network, with the same number of nodes as the network curently has. Options Options control the appearance of the curve network. These options can also be passed as keyword arguments to the initial register_curve_network() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? radius size of rendered nodes/edges get_radius () set_radius ( newVal , relative = True ) yes color default color for the network get_color () set_color ( newVal ) yes material material for structure get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the curve network network = polyscope . register_curve_network ( \"my net\" , nodes , edges ) network . set_enabled ( False ) # disable network . set_enabled () # default is true network . set_radius ( 0.02 ) # radius is relative to a scene length scale by default network . set_radius ( 1.7 , relative = False ) # radius in absolute world units network . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] network . set_material ( \"candy\" ) network . set_transparency ( 0.5 ) # alternately: ps . register_curve_network ( \"my net 2\" , nodes , edges , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ), transparency = 0.5 )","title":"Basics"},{"location":"structures/curve_network/basics/#curve-networks","text":"Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network. Try clicking on a node or edge to see the data associated with that point!","title":"Curve Networks"},{"location":"structures/curve_network/basics/#registering-a-curve-network","text":"Curve network structures can be registered with Polyscope by passing the node position and edge indices. Polyscope also makes it easy to automatically construct lines and loops by just passing edges='line' or edges='loop' . Example: a network of random curves import numpy as np import polyscope as ps ps . init () # generate some random nodes and edges between them nodes = np . random . rand ( 100 , 3 ) edges = np . random . randint ( 0 , 100 , size = ( 250 , 2 )) # visualize! ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) ps . show () register_curve_network ( name , nodes , edges , enabled = None , radius = None , color = None , material = None ) Add a new curve network structure to Polyscope. name string, a name for the structure nodes , an Nx3 numpy float array of node locations (or Nx2 for 2D) edges , an Ex2 numpy integer array of edge connections, as 0-based indices in to the nodes array, OR the string line / loop , to generate node connectivity as a line or loop, respectively. Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the nodes and edges relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the network as rgb in [0,1] material string, name of material to use for network if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D node positions are also supported, see 2D data .","title":"Registering a curve network"},{"location":"structures/curve_network/basics/#updating-a-curve-network","text":"The locations of the nodes in a curve network can be updated with the member function update_node_positions(newPositions) . All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite). CurveNetwork . update_node_positions ( newPos ) Update the node positions in a curve network structure. newPos must be valid input as to initially construct the nodes of the network, with the same number of nodes as the network curently has.","title":"Updating a curve network"},{"location":"structures/curve_network/basics/#options","text":"Options control the appearance of the curve network. These options can also be passed as keyword arguments to the initial register_curve_network() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? radius size of rendered nodes/edges get_radius () set_radius ( newVal , relative = True ) yes color default color for the network get_color () set_color ( newVal ) yes material material for structure get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the curve network network = polyscope . register_curve_network ( \"my net\" , nodes , edges ) network . set_enabled ( False ) # disable network . set_enabled () # default is true network . set_radius ( 0.02 ) # radius is relative to a scene length scale by default network . set_radius ( 1.7 , relative = False ) # radius in absolute world units network . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] network . set_material ( \"candy\" ) network . set_transparency ( 0.5 ) # alternately: ps . register_curve_network ( \"my net 2\" , nodes , edges , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ), transparency = 0.5 )","title":"Options"},{"location":"structures/curve_network/color_quantities/","text":"Visualize color rgb-valued data at the nodes or edges of a curve network. Example: import numpy as np import polyscope as ps ps . init () # register a curve network N_node = 100 N_edge = 250 nodes = np . random . rand ( N_node , 3 ) edges = np . random . randint ( 0 , N_node , size = ( N_edge , 2 )) ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) # visualize some random colors per-node vals_node = np . random . rand ( N_node , 3 ) ps_net . add_color_quantity ( \"rand vals\" , vals_node , enabled = True ) # visualize some random colors per-edge vals_edge = np . random . rand ( N_edge , 3 ) ps_net . add_color_quantity ( \"rand vals2\" , vals_edge , defined_on = 'edges' ) # view the network with all of these quantities ps . show () CurveNetwork . add_color_quantity ( name , values , defined_on = 'nodes' , enabled = None ) Add a scalar quantity to the network. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at nodes/edges defined_on string, one of nodes or edges , is this data a color per-node or a value per-edge? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Color Quantities"},{"location":"structures/curve_network/scalar_quantities/","text":"Visualize scalar valued data at the nodes or edges of a curve network. Example: import numpy as np import polyscope as ps ps . init () # register a curve network N_node = 100 N_edge = 250 nodes = np . random . rand ( N_node , 3 ) edges = np . random . randint ( 0 , N_node , size = ( N_edge , 2 )) ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) # visualize some random data per-node vals_node = np . random . rand ( N_node ) ps_net . add_scalar_quantity ( \"rand vals\" , vals_node , enabled = True ) # visualize some random data per-edge vals_edge = np . random . rand ( N_edge ) ps_net . add_scalar_quantity ( \"rand vals2\" , vals_edge , defined_on = 'edges' ) # as always, we can customize the initial appearance ps_net . add_scalar_quantity ( \"rand vals2 opt\" , vals_edge , defined_on = 'edges' , enabled = True , vminmax = ( - 3. , 3. ), cmap = 'reds' ) # view the network with all of these quantities ps . show () CurveNetwork . add_scalar_quantity ( name , values , defined_on = 'nodes' , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the network. name string, a name for the quantity values a length N numpy array, scalars at nodes/edges defined_on string, one of nodes or edges , is this data a value per-node or a value per-edge? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) datatype , one of standard , symmetric , or magnitude , affects default colormap and map range vminmax , a 2-tuple of floats, specifying the min and max range to colormap in to cmap , which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Scalar Quantities"},{"location":"structures/curve_network/vector_quantities/","text":"Visualize vector-valued data at the nodes or edges of a curve network. Example: import numpy as np import polyscope as ps ps . init () # register a curve network N_node = 100 N_edge = 250 nodes = np . random . rand ( N_node , 3 ) edges = np . random . randint ( 0 , N_node , size = ( N_edge , 2 )) ps_net = ps . register_curve_network ( \"my network\" , nodes , edges ) # visualize some random vectors per-node vecs_node = np . random . rand ( N_node , 3 ) ps_net . add_vector_quantity ( \"rand vecs\" , vecs_node , enabled = True ) # visualize some random vectors per-edge vecs_edge = np . random . rand ( N_edge , 3 ) ps_net . add_vector_quantity ( \"rand vecs edge\" , vecs_edge , defined_on = 'edges' ) # set radius/length/color of the vectors ps_net . add_vector_quantity ( \"rand vecs opt\" , vecs_node , radius = 0.001 , length = 0.005 , color = ( 0.2 , 0.5 , 0.5 )) # ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space ps_net . add_vector_quantity ( \"vecs ambient\" , vecs_node , vectortype = 'ambient' ) # view the network with all of these quantities ps . show () CurveNetwork . add_vector_quantity ( name , values , defined_on = 'nodes' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the network. name string, a name for the quantity values an Nx3 numpy array, vectors at nodes/edges (or Nx2 for 2D data) defined_on string, one of nodes or edges , is this data a vector per-node or a vector per-edge? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Vector Quantities"},{"location":"structures/point_cloud/basics/","text":"Point Clouds Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point. Registering a point cloud Example: a point cloud of random points import numpy as np import polyscope as ps ps . init () # generate some points points = np . random . rand ( 100 , 3 ) # visualize! ps_cloud = ps . register_point_cloud ( \"my points\" , points ) ps . show () # with some options ps_cloud_opt = ps . register_point_cloud ( \"my points\" , points , radius = 0.02 , point_render_mode = 'quad' ) ps . show () register_point_cloud ( name , points , enabled = None , radius = None , point_render_mode = None , color = None , material = None ) Add a new point cloud structure to Polyscope. name is the name for the structure, as a string points is an N x 3 numpy array of point locations Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the points relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the points as rgb in [0,1] material string, name of material to use for cloud if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D point clouds are also supported, see 2D data . Updating a point cloud The locations of the points in a point cloud can be updated with the member function update_point_positions(newPositions) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). Example: update positions (continued from above) new_pos = np . random . rand ( 100 , 3 ) ps_cloud . update_point_positions ( new_pos ) ps . show () PointCloud . update_point_positions ( newPos ) Update the point positions in a point cloud structure. newPos must be valid input as to initially construct a point cloud, with the same number of points. Point render mode By default, Polyscope renders point clouds with a sphere for each point. However, for large point clouds (for instance, > 500,000 points, or on low-end hardware), this sphere rendering may become prohibitively expensive and lead to a laggy interface. As an alternative, points can be rendered as a small quad per-point, which is more efficient (for instance, it renders in real-time with 20,000,000+ points on my mid-range GPU). The point render mode setting specifies which style is used: sphere a small sphere is drawn for each point (default) quad a small quad is drawn for each point PointCloud . set_point_render_mode ( newVal ) Set the the rendering method used to draw each point. Pass the string name of the style to use. One of 'sphere' (default) or 'quad' . As usual, this can also be set as a keyword argument when the point cloud is registered, like register_point_cloud ( 'my points' , data , point_render_mode = 'quad' ) . There is also a corresponding get_point_render_mode() . Options Options control the appearance of the cloud. These options can also be passed as keyword arguments to the initial register_point_cloud() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? point radius size of rendered points get_radius () set_radius ( newVal , relative = True ) yes point color default color for points get_color () set_color ( newVal ) yes point render mode how to draw points get_point_render_mode () set_point_render_mode ( newVal ) yes material material for point get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the point cloud cloud = polyscope . register_point_cloud ( \"my points\" , points ) cloud . set_enabled ( False ) # disable cloud . set_enabled () # default is true cloud . set_radius ( 0.02 ) # radius is relative to a scene length scale by default cloud . set_radius ( 1.7 , relative = False ) # radius in absolute world units cloud . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] cloud . set_material ( \"candy\" ) cloud . set_transparency ( 0.5 ) # alternately: ps . register_point_cloud ( \"my points 2\" , points , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ) transparency = 0.5 )","title":"Basics"},{"location":"structures/point_cloud/basics/#point-clouds","text":"Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points. As always, try clicking on a point to see the data associated with that point.","title":"Point Clouds"},{"location":"structures/point_cloud/basics/#registering-a-point-cloud","text":"Example: a point cloud of random points import numpy as np import polyscope as ps ps . init () # generate some points points = np . random . rand ( 100 , 3 ) # visualize! ps_cloud = ps . register_point_cloud ( \"my points\" , points ) ps . show () # with some options ps_cloud_opt = ps . register_point_cloud ( \"my points\" , points , radius = 0.02 , point_render_mode = 'quad' ) ps . show () register_point_cloud ( name , points , enabled = None , radius = None , point_render_mode = None , color = None , material = None ) Add a new point cloud structure to Polyscope. name is the name for the structure, as a string points is an N x 3 numpy array of point locations Additional optional keyword arguments: enabled boolean, is the structure enabled initially radius float, a size for the points relative to the scene length scale (use set_radius(val, relative=False) for absolute units) color float 3-tuple, default color values for the points as rgb in [0,1] material string, name of material to use for cloud if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D point clouds are also supported, see 2D data .","title":"Registering a point cloud"},{"location":"structures/point_cloud/basics/#updating-a-point-cloud","text":"The locations of the points in a point cloud can be updated with the member function update_point_positions(newPositions) . All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one). Example: update positions (continued from above) new_pos = np . random . rand ( 100 , 3 ) ps_cloud . update_point_positions ( new_pos ) ps . show () PointCloud . update_point_positions ( newPos ) Update the point positions in a point cloud structure. newPos must be valid input as to initially construct a point cloud, with the same number of points.","title":"Updating a point cloud"},{"location":"structures/point_cloud/basics/#point-render-mode","text":"By default, Polyscope renders point clouds with a sphere for each point. However, for large point clouds (for instance, > 500,000 points, or on low-end hardware), this sphere rendering may become prohibitively expensive and lead to a laggy interface. As an alternative, points can be rendered as a small quad per-point, which is more efficient (for instance, it renders in real-time with 20,000,000+ points on my mid-range GPU). The point render mode setting specifies which style is used: sphere a small sphere is drawn for each point (default) quad a small quad is drawn for each point PointCloud . set_point_render_mode ( newVal ) Set the the rendering method used to draw each point. Pass the string name of the style to use. One of 'sphere' (default) or 'quad' . As usual, this can also be set as a keyword argument when the point cloud is registered, like register_point_cloud ( 'my points' , data , point_render_mode = 'quad' ) . There is also a corresponding get_point_render_mode() .","title":"Point render mode"},{"location":"structures/point_cloud/basics/#options","text":"Options control the appearance of the cloud. These options can also be passed as keyword arguments to the initial register_point_cloud() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? point radius size of rendered points get_radius () set_radius ( newVal , relative = True ) yes point color default color for points get_color () set_color ( newVal ) yes point render mode how to draw points get_point_render_mode () set_point_render_mode ( newVal ) yes material material for point get_material () set_material ( newVal ) yes Example: set options which affect the appearance of the point cloud cloud = polyscope . register_point_cloud ( \"my points\" , points ) cloud . set_enabled ( False ) # disable cloud . set_enabled () # default is true cloud . set_radius ( 0.02 ) # radius is relative to a scene length scale by default cloud . set_radius ( 1.7 , relative = False ) # radius in absolute world units cloud . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] cloud . set_material ( \"candy\" ) cloud . set_transparency ( 0.5 ) # alternately: ps . register_point_cloud ( \"my points 2\" , points , enabled = False , material = 'candy' , radius = 0.02 , color = ( 1. , 0. , 0. ) transparency = 0.5 )","title":"Options"},{"location":"structures/point_cloud/color_quantities/","text":"Visualize color rgb-valued data at the points of a point cloud. Example: import numpy as np import polyscope as ps ps . init () # register a point cloud N = 100 points = np . random . rand ( N , 3 ) ps_cloud = ps . register_point_cloud ( \"my points\" , points , enabled = True ) # generate some random color per-point vals = np . random . rand ( N , 3 ) # basic color visualization ps_cloud . add_color_quantity ( \"rand colors\" , vals ) ps . show () PointCloud . add_color_quantity ( name , values , enabled = None ) Add a color quantity to the point cloud. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at points Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Color Quantities"},{"location":"structures/point_cloud/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the points of a point cloud. Example: import numpy as np import polyscope as ps ps . init () # register a point cloud N = 100 points = np . random . rand ( N , 3 ) ps_cloud = ps . register_point_cloud ( \"my points\" , points ) # generate some random data per-point vals = np . random . rand ( N ) # basic visualization ps_cloud . add_scalar_quantity ( \"rand vals\" , vals ) # manually specify a range for colormapping ps_cloud . add_scalar_quantity ( \"rand vals with range\" , vals , vminmax = ( - 5. , 5. ), enabled = True ) # use a different colormap ps_cloud . add_scalar_quantity ( \"rand vals with range\" , vals , cmap = 'blues' ) # use the 'datatype' to specify default visualization semantics vals_gaussian = np . random . normal ( size = N ) ps_cloud . add_scalar_quantity ( \"gaussian vals symmetric\" , vals_gaussian , datatype = 'symmetric' ) # view the point cloud with all of these quantities ps . show () PointCloud . add_scalar_quantity ( name , values , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the point cloud. name string, a name for the quantity values a length N numpy array, scalars at points Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used) datatype , one of standard , symmetric , or magnitude , affects default colormap and map range vminmax , a 2-tuple of floats, specifying the min and max range to colormap in to cmap , which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Scalar Quantities"},{"location":"structures/point_cloud/variable_radius/","text":"By default, all points in the cloud have the same radius. However, any point cloud scalar quantity can be additionally interpreted as the radius of the points. This can also be set manually in the GUI via the point cloud [Options] \u2013> [Variable Radius]. Example: import polyscope as ps import numpy as np # ... setup, register a point cloud, etc ... // Get a reference to your point cloud ps_cloud = ps . get_point_cloud ( \"your point cloud name\" ) # Add a random scalar quantity N = ps_cloud . n_points () vals = np . random . rand ( N ) ps_cloud . add_scalar_quantity ( \"test_vals\" , vals ) # Set the quantity as the point size ps_cloud . set_point_radius_quantity ( \"test_vals\" ) ps . show () # Clear it out, go back to default constant size ps_cloud . clear_point_radius_quantity () ps . show () # Set the quantity as the size using actual world-coordinate units, # rather than auto-scaling the size ps_cloud . set_point_radius_quantity ( \"test_vals\" , autoscale = False ) ps . show () Any negative values in the scalar quantity will be clamped to 0 . By default, values will be rescaled such that the largest corresponds to the size from the point radius option (thus, using any constant scalar quantity will make the radii identical to the default value with no radius set). This automatic scaling can be disabled by setting autoscale=False below. Reproducing radius in world units Remember that point clouds always have a per-structure radius parameter which sets a radius for all of the points in the point cloud (and can be adjusted via a slider in the GUI, or via radius=0.1 / set_radius() ). This per-structure parameter makes things a little more complicated when also setting length via a scalar quantity as described here. By default, the structure radius parameter is still respected. The variable radius from the quantity first scaled such that the largest value is 1. , and then is multiplied by the structure parameter to get the actual radius used for the points. This usually gives a reasonable visualization, but makes it difficult to set a precise radius in world units. To properly reproduce a radius in world-coordinate units, you can circumvent autoscaling like cloud.set_point_radius_quantity(q, autoscale=False) . This will prevent the auto-scaling of the radii, and also ignore the structure\u2019s point radius parameter. def self.bound_cloud.set_point_radius_quantity(quantity_name, autoscale) def self.bound_cloud.clear_point_radius_quantity() PointCloud . set_point_radius_quantity ( quantity_name , autoscale = True ) Set the point radius from a quantity by name. The quantity must be a point cloud scalar quantity add to this cloud. When using a radius which is a physical length in world coordinates, set autoscale to False to skip rescaling and ignore the structure\u2019s point radius parameter. PointCloud . clear_point_radius_quantity () Clear the point radius quantity and return to using the constant radius.","title":"Variable Radius"},{"location":"structures/point_cloud/vector_quantities/","text":"Visualize vector-valued data at the points of a point cloud. Example: import numpy as np import polyscope as ps ps . init () # register a point cloud N = 100 points = np . random . rand ( N , 3 ) ps_cloud = ps . register_point_cloud ( \"my points\" , points ) # generate some random vectors per-point vecs = np . random . rand ( N , 3 ) # basic visualization ps_cloud . add_vector_quantity ( \"rand vecs\" , vecs , enabled = True ) # set radius/length/color of the vectors ps_cloud . add_vector_quantity ( \"rand vecs\" , vecs , radius = 0.001 , length = 0.005 , color = ( 0.2 , 0.5 , 0.5 )) # ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space ps_cloud . add_vector_quantity ( \"vecs ambient\" , vecs , vectortype = 'ambient' ) # view the point cloud with all of these quantities ps . show () PointCloud . add_vector_quantity ( name , values , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the point cloud. name string, a name for the quantity values an Nx3 numpy array, vectors at points (or Nx2 for 2D data) Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Vector Quantities"},{"location":"structures/surface_mesh/basics/","text":"Surface Meshes Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold, and all faces need not have the same degree. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element. Registering a surface mesh Example: registering a mesh import numpy as np import polyscope as ps ps . init () vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces # visualize! ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps . show () Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. register_surface_mesh ( name , vertices , faces , enabled = None , color = None , edge_color = None , smooth_shade = None , edge_width = None , material = None ) Add a new surface mesh structure to Polyscope. name string, a name for the structure vertices , an Nx3 numpy float array of vertex locations (or Nx2 for 2D) faces , an FxD numpy integer array of faces, as 0-based indices in to the vertices array, OR a plain python list-of-lists of indices (or really, anything twice-iterable which yields integers). The latter option enables meshes where not all faces have the same degree. Additional optional keyword arguments: enabled boolean, is the structure enabled initially color float 3-tuple, default color values for the mesh as rgb in [0,1] edge_color float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set edge_width too) edge_width float, width of edges in rendered mesh; default sets 0 to disable edges, 1 is a reasonable value to enable smooth_shade boolean, if True use smooth shading (default: False for flat shading) material string, name of material to use for the mesh if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D vertex positions are also supported, see 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everyone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering. Updating a mesh The locations of the vertices in a mesh can be updated with the member function update_vertex_positions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). SurfaceMesh . update_vertex_positions ( newPos ) Update the vertex positions in a surface mesh structure. newPos must be valid input as to initially construct the vertex positions, with the same number of vertices. Back face policies The faces of a mesh are implicitly given an outward orientation by the order in which the vertices are listed. The standard convention, which Polyscope respects, is that a counter-clockwise ordering of vertices defines the \u201coutward\u201d direction. Faces which are viewed from behind are referred to as back faces ; they can arise when a surface is viewed from the inside, or if a mesh is not properly oriented. Polyscope offers several options for how back faces are displayed. identical all faces are always rendered identically, whether viewed from the front or back different back faces are shaded slightly darker, so they can be distinguished (this is the default) custom back faces are shaded with a configurable color cull back faces are culled, and not rendered at all The choice of these policies can be set as an option for each surface mesh structure, either in the GUI via [Options] -> [Back Face Policy] or programmatically with the function below or when a mesh is registered. SurfaceMesh . set_back_face_policy ( val ) Set the policy for rendering oppositely-oriented back faces. newPolicy is string giving the new policy, one of identical , different , custom , or cull as described above You can also set back_face_policy='cull' when registering a mesh. There is also a corresponding SurfaceMesh.get_back_face_policy() . SurfaceMesh . set_back_face_color ( val ) Set the color to be used for custom back face coloring as a 3-tuple of floats on [0,1]. Has no effect unless the back face policy is custom . There is also a corresponding get_back_face_color() . Options Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial register_surface_mesh() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? surface color the color of the mesh get_color () set_color ( val ) yes edge color the color of the edges of the mesh get_edge_color () set_edge_color ( val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges get_edge_width () set_edge_width ( val ) yes shade smooth use smooth shading along faces or simple flat faces get_smoooth_shade () set_smooth_shade ( isSmooth ) yes material material for structure get_material () set_material ( newVal ) yes back face policy what back face policy to use get_back_face_policy () set_back_face_policy ( val ) yes back face color back face color for the custom policy get_back_face_color () set_back_face_color ( val ) yes Example: set options which affect the appearance of the mesh import numpy as np import polyscope as ps vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . set_enabled ( False ) # disable ps_mesh . set_enabled () # default is true ps_mesh . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] ps_mesh . set_edge_color (( 0.8 , 0.8 , 0.8 )) ps_mesh . set_edge_width ( 1.0 ) ps_mesh . set_smooth_shade ( True ) ps_mesh . set_material ( \"candy\" ) ps_mesh . set_transparency ( 0.5 ) # alternately: ps . register_surface_mesh ( \"my mesh2\" , vertices , faces , enabled = False , color = ( 1. , 0. , 0. ), edge_color = (( 0.8 , 0.8 , 0.8 )), edge_width = 1.0 , smooth_shade = True , material = 'candy' , transparency = 0.5 )","title":"Basics"},{"location":"structures/surface_mesh/basics/#surface-meshes","text":"Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/etc of the mesh. Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold, and all faces need not have the same degree. As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element.","title":"Surface Meshes"},{"location":"structures/surface_mesh/basics/#registering-a-surface-mesh","text":"Example: registering a mesh import numpy as np import polyscope as ps ps . init () vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces # visualize! ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps . show () Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face. register_surface_mesh ( name , vertices , faces , enabled = None , color = None , edge_color = None , smooth_shade = None , edge_width = None , material = None ) Add a new surface mesh structure to Polyscope. name string, a name for the structure vertices , an Nx3 numpy float array of vertex locations (or Nx2 for 2D) faces , an FxD numpy integer array of faces, as 0-based indices in to the vertices array, OR a plain python list-of-lists of indices (or really, anything twice-iterable which yields integers). The latter option enables meshes where not all faces have the same degree. Additional optional keyword arguments: enabled boolean, is the structure enabled initially color float 3-tuple, default color values for the mesh as rgb in [0,1] edge_color float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set edge_width too) edge_width float, width of edges in rendered mesh; default sets 0 to disable edges, 1 is a reasonable value to enable smooth_shade boolean, if True use smooth shading (default: False for flat shading) material string, name of material to use for the mesh if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. 2D vertex positions are also supported, see 2D data . Element ordering Polyscope quantities are ordered arrays of data, but not everyone can agree on the ordering of elements in a mesh. See indexing conventions . The default ordering is probably the same as yours for data on vertices, faces, and corners . However, data on edges and halfedges is much more likely to require setting an ordering.","title":"Registering a surface mesh"},{"location":"structures/surface_mesh/basics/#updating-a-mesh","text":"The locations of the vertices in a mesh can be updated with the member function update_vertex_positions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). SurfaceMesh . update_vertex_positions ( newPos ) Update the vertex positions in a surface mesh structure. newPos must be valid input as to initially construct the vertex positions, with the same number of vertices.","title":"Updating a mesh"},{"location":"structures/surface_mesh/basics/#back-face-policies","text":"The faces of a mesh are implicitly given an outward orientation by the order in which the vertices are listed. The standard convention, which Polyscope respects, is that a counter-clockwise ordering of vertices defines the \u201coutward\u201d direction. Faces which are viewed from behind are referred to as back faces ; they can arise when a surface is viewed from the inside, or if a mesh is not properly oriented. Polyscope offers several options for how back faces are displayed. identical all faces are always rendered identically, whether viewed from the front or back different back faces are shaded slightly darker, so they can be distinguished (this is the default) custom back faces are shaded with a configurable color cull back faces are culled, and not rendered at all The choice of these policies can be set as an option for each surface mesh structure, either in the GUI via [Options] -> [Back Face Policy] or programmatically with the function below or when a mesh is registered. SurfaceMesh . set_back_face_policy ( val ) Set the policy for rendering oppositely-oriented back faces. newPolicy is string giving the new policy, one of identical , different , custom , or cull as described above You can also set back_face_policy='cull' when registering a mesh. There is also a corresponding SurfaceMesh.get_back_face_policy() . SurfaceMesh . set_back_face_color ( val ) Set the color to be used for custom back face coloring as a 3-tuple of floats on [0,1]. Has no effect unless the back face policy is custom . There is also a corresponding get_back_face_color() .","title":"Back face policies"},{"location":"structures/surface_mesh/basics/#options","text":"Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial register_surface_mesh() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? surface color the color of the mesh get_color () set_color ( val ) yes edge color the color of the edges of the mesh get_edge_color () set_edge_color ( val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges get_edge_width () set_edge_width ( val ) yes shade smooth use smooth shading along faces or simple flat faces get_smoooth_shade () set_smooth_shade ( isSmooth ) yes material material for structure get_material () set_material ( newVal ) yes back face policy what back face policy to use get_back_face_policy () set_back_face_policy ( val ) yes back face color back face color for the custom policy get_back_face_color () set_back_face_color ( val ) yes Example: set options which affect the appearance of the mesh import numpy as np import polyscope as ps vertices = np . random . rand ( 100 , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , 100 , size = ( 250 , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) ps_mesh . set_enabled ( False ) # disable ps_mesh . set_enabled () # default is true ps_mesh . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] ps_mesh . set_edge_color (( 0.8 , 0.8 , 0.8 )) ps_mesh . set_edge_width ( 1.0 ) ps_mesh . set_smooth_shade ( True ) ps_mesh . set_material ( \"candy\" ) ps_mesh . set_transparency ( 0.5 ) # alternately: ps . register_surface_mesh ( \"my mesh2\" , vertices , faces , enabled = False , color = ( 1. , 0. , 0. ), edge_color = (( 0.8 , 0.8 , 0.8 )), edge_width = 1.0 , smooth_shade = True , material = 'candy' , transparency = 0.5 )","title":"Options"},{"location":"structures/surface_mesh/color_quantities/","text":"Visualize color rgb-valued data at the elements of a surface mesh. Example: import numpy as np import polyscope as ps ps . init () N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # visualize some random data per-vertex colors_vert = np . random . rand ( N_vert , 3 ) ps_mesh . add_color_quantity ( \"rand colors\" , colors_vert , enabled = True ) # visualize some random data per-face colors_face = np . random . rand ( N_face , 3 ) ps_mesh . add_color_quantity ( \"rand colors2\" , colors_face , defined_on = 'faces' ) # view the mesh with all of these quantities ps . show () SurfaceMesh . add_color_quantity ( name , values , defined_on = 'vertices' , enabled = None ) Add a scalar quantity to the network. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at vertices/faces defined_on string, one of vertices or faces , is this data a color per vertex or a color per face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Color Quantities"},{"location":"structures/surface_mesh/count_quantities/","text":"Count quantities store integers defined at just a few elements of a mesh, rather than at every element. These useful for visualizing, e.g., singularities of a vector field at vertices. TODO TODO document count quantities. See polyscope/surface_mesh.h for add signatures.","title":"Count quantities"},{"location":"structures/surface_mesh/distance_quantities/","text":"Visualize distance-valued data at the elements of a surface mesh. Distance quantities are basically scalars, but are visualized with alternating stripes to show distance contours. Example: import numpy as np import polyscope as ps ps . init () N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) dists = # your distances, a length N_vert array # visualize the distance ps_mesh . add_distance_quantity ( \"distances\" , dists , enabled = True , stripe_size = 0.01 ) # use defaults for signed distances ps_mesh . add_distance_quantity ( \"signed distances\" , dists , signed = True ) # view the mesh with these quantities ps . show () SurfaceMesh . add_distance_quantity ( name , values , defined_on = 'vertices' , enabled = None , signed = False , vminmax = None , stripe_size = None , stripe_size_relative = True , cmap = None ) Add a distance quantity to the mesh. name string, a name for the quantity values a length N numpy array, distance scalars defined_on for now, only 'vertices' is supported signed boolean, if true the data is assumed to represent signed distances, and symmetric ranges/colormaps are used by default Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) vminmax a 2-tuple of floats, specifying the min and max range to colormap in to stripe_size float, the width of stripes in the visualization stripe_size_relative boolean, if true stripe_size is interpreted relative to the scene length scale, otherwise absolute cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Distance Quantities"},{"location":"structures/surface_mesh/indexing_convention/","text":"Default ordering Polyscope abstracts over data types by accepting generic ordered arrays of data to visualize. Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in a mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering. Vertices The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_vertex_permutation ( perm , expected_size = None ) Set a non-standard ordering for vertex-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Faces The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_face_permutation ( perm , expected_size = None ) Set a non-standard ordering for face-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Edges The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_edge_permutation ( perm , expected_size = None ) Set a non-standard ordering for edge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Halfedges The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_halfedge_permutation ( perm , expected_size = None ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. Corners The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_corner_permutation ( perm , expected_size = None ) Set a non-standard ordering for corner-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added. All at once As a convenience, you can alternately use a single function which passes all permutations needed at the same time. This might ease writing a single helper function which defines any necessary permutations for the mesh convention in your codebase. SurfaceMesh . set_all_permutations ( vertex_perm = None , vertex_perm_size = None , face_perm = None , face_perm_size = None , edge_perm = None , edge_perm_size = None , corner_perm = None , corner_perm_size = None , halfedge_perm = None , halfedge_perm_size = None ) Any non- None keyword arguments will simply be forwarded to the appropriate set_XXX_permutation() variant as above.","title":"Indexing Convention"},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","text":"Polyscope abstracts over data types by accepting generic ordered arrays of data to visualize. Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i^\\textrm{th} i^\\textrm{th} edge in a mesh? Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d (this is probably the case for quantities defined on vertices and faces), you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element (say, edges), visualizations of data on edges will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements. This section describes the remedy: you can give the mesh a permutation, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation p should be an array of integers, such that if i is the i^\\textrm{th} i^\\textrm{th} element in the default ordering, p[i] gives the index under your convention. Your data arrays will then be indexed as data [ p [ i ]] when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as data [ p [ i ]] is always a valid access; if the size of your index space is different, a size can also be passed in. The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.","title":"Default ordering"},{"location":"structures/surface_mesh/indexing_convention/#vertices","text":"The first argument when registering a surface mesh with Polyscope is a list of vertex positions. The ordering of vertices in this list is the default ordering vertices. Arrays of vertex-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_vertex_permutation ( perm , expected_size = None ) Set a non-standard ordering for vertex-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Vertices"},{"location":"structures/surface_mesh/indexing_convention/#faces","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The ordering of faces in this list is the default ordering faces. Arrays of face-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_face_permutation ( perm , expected_size = None ) Set a non-standard ordering for face-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Faces"},{"location":"structures/surface_mesh/indexing_convention/#edges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit edge (vertex_A, vertex_B), if neither it nor the // equivalent edge (vertex_B, vertex_A) has been emitted already } } The default ordering of edges is the order in which they would be emitted by this loop. Arrays of edge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_edge_permutation ( perm , expected_size = None ) Set a non-standard ordering for edge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Edges"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; size_t vertex_B = face [ ( i + 1 ) % faceDegree ]; // emit halfedge (vertex_A, vertex_B) } } The default ordering of halfedges is the order in which they would be emitted by this loop. Arrays of halfedge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_halfedge_permutation ( perm , expected_size = None ) Set a non-standard ordering for halfedge-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Halfedges"},{"location":"structures/surface_mesh/indexing_convention/#corners","text":"The second argument when registering a surface mesh with Polyscope is a list of face indices. The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face. More formally, the ordering is equivalent to the following C++ code: std :: vector < std :: vector < size_t >> faceIndices ; for ( std :: vector < size_t > face : faceIndices ) { size_t faceDegree = face . size (); for ( size_t i = 0 ; i < faceDegree ; i ++ ) { size_t vertex_A = face [ i ]; // emit corner in this face incident on vertex_A } } The default ordering of corners is the order in which they would be emitted by this loop. Arrays of corner-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below. SurfaceMesh . set_corner_permutation ( perm , expected_size = None ) Set a non-standard ordering for corner-valued data on a mesh. The argument perm should be an array of integers. If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in perm . Must be set before any quantites are added.","title":"Corners"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","text":"As a convenience, you can alternately use a single function which passes all permutations needed at the same time. This might ease writing a single helper function which defines any necessary permutations for the mesh convention in your codebase. SurfaceMesh . set_all_permutations ( vertex_perm = None , vertex_perm_size = None , face_perm = None , face_perm_size = None , edge_perm = None , edge_perm_size = None , corner_perm = None , corner_perm_size = None , halfedge_perm = None , halfedge_perm_size = None ) Any non- None keyword arguments will simply be forwarded to the appropriate set_XXX_permutation() variant as above.","title":"All at once"},{"location":"structures/surface_mesh/misc_quantities/","text":"Surface Graph Quantity The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph. Options Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes radius the radius the graph is drawn with double getRadius () setRadius ( double val , bool isRelative = true ) yes color the color to draw the graph with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Misc quantities"},{"location":"structures/surface_mesh/misc_quantities/#surface-graph-quantity","text":"The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity. Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes. Example : drawing mesh\u2019s dual with geometry-central . #include \"polyscope/surface_mesh.h\" // geometry-central things geom -> requireFaceIndices (); std :: vector < Vector3 > positions ; std :: vector < std :: array < size_t , 2 >> edgeInds ; // Build the node positions for ( Face f : mesh -> faces ()) { // Compute center for face Vector3 c = Vector3 :: zero (); for ( Vertex v : f . adjacentVertices ()) { c += geom -> inputVertexPositions [ v ]; } c /= f . degree (); positions . push_back ( c ); } // Build the edge indices for ( Edge e : mesh -> edges ()) { // Connect the nodes from the two faces adjacent to each edge size_t fa = geom -> faceIndices [ e . halfedge (). face ()]; size_t fb = geom -> faceIndices [ e . halfedge (). twin (). face ()]; edgeInds . push_back ({ fa , fb }); } polyscope :: getSurfaceMesh ( \"my mesh\" ) -> addSurfaceGraphQuantity ( \"dual graph\" , positions , edgeInds ); SurfaceMesh :: addSurfaceGraphQuantity ( std :: string name , const P & nodes , const E & edges ) Add a new surface graph quantity to the structure. nodes is the list of 3D positions for the graph nodes. The type should be adaptable to a list of float -valued 3-vectors. edges is the list of edges for the graph, where each entry is two 0-based indices in to the nodes array. The type should be adaptable to a list of size_t -valued 2-vectors (aka pairs of indices). The resulting class has color and radius fields which can be set to adjust the appearance of the resulting graph.","title":"Surface Graph Quantity"},{"location":"structures/surface_mesh/misc_quantities/#options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? bool isEnabled () setEnabled ( bool newVal ) yes radius the radius the graph is drawn with double getRadius () setRadius ( double val , bool isRelative = true ) yes color the color to draw the graph with glm :: vec3 getVectorColor () setVectorColor ( glm :: vec3 val ) yes (all setters return this to support chaining. setEnabled() returns generic quantity, so chain it last)","title":"Options"},{"location":"structures/surface_mesh/parameterization_quantities/","text":"A parameterization is a set of 2D coordinates associated with a mesh, often referred to as \u201cUV coordinates\u201d. This sections details several functions for visualizing such parameterizations. Example: import numpy as np import polyscope as ps ps . init () N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # parameterization per vertex param_vert = np . random . rand ( N_vert , 2 ) ps_mesh . add_parameterization_quantity ( \"rand param\" , param_vert , enabled = True ) # parameterization per corner param_corner = np . random . rand ( ps_mesh . n_corners (), 2 ) ps_mesh . add_parameterization_quantity ( \"rand param corner\" , param_corner , defined_on = 'corners' ) # use options to customize visualization ps_mesh . add_parameterization_quantity ( \"rand param corner2\" , param_corner , defined_on = 'corners' , coords_type = 'world' , viz_style = 'local_rad' ) # with custom checker/grid color cA = ( 0.1 , 0.2 , 0.3 ) cB = ( 0.4 , 0.5 , 0.6 ) ps_mesh . add_parameterization_quantity ( \"rand param corner3\" , param_corner , defined_on = 'corners' , coords_type = 'unit' , viz_style = 'grid' , grid_colors = ( cA , cB )) # view the mesh with all of these quantities ps . show () Adding SurfaceMesh . add_parameterization_quantity ( name , values , defined_on = 'vertices' , coords_type = 'unit' , enabled = None , viz_style = None , grid_colors = None , checker_colors = None , checker_size = None , cmap = None ) Add a parameterization quantity to the mesh. name string, a name for the quantity values an Nx2 numpy array, coordinates at vertices/corners defined_on one of 'vertices','corners' , is this a coordinate per vertex or per corner? coords_type string, one of 'unit' , 'world' (see below) Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) viz_style string, one of 'checker' , 'grid' , 'local_check' , 'local_rad' (see below) grid_colors 2-tuple of rgb colors, used to color the grid visualization checker_colors 2-tuple of rgb colors, used to color the checkerboard visualization checker_size float, the size of checkers/grid/stripes cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set. Options Styles Several styles are available for how a parameterization is displayed. The viz_style option determines how parameterizations are visualized: checker : a two-color checker pattern grid : a two-color grid with thin lines local_check : a checkerboard over a radial colormap, centered around (0,0) local_rad : distance stripes over a radial colormap, centered around (0,0) Types The coords_type options determines how parameter coordinates are interpreted for scaling: unit : UV coords are assumed to lie on the [0,1] interval world : UV coords are assumed to be scaled like the world-space positions of the mesh","title":"Parameterization Quantities"},{"location":"structures/surface_mesh/parameterization_quantities/#adding","text":"SurfaceMesh . add_parameterization_quantity ( name , values , defined_on = 'vertices' , coords_type = 'unit' , enabled = None , viz_style = None , grid_colors = None , checker_colors = None , checker_size = None , cmap = None ) Add a parameterization quantity to the mesh. name string, a name for the quantity values an Nx2 numpy array, coordinates at vertices/corners defined_on one of 'vertices','corners' , is this a coordinate per vertex or per corner? coords_type string, one of 'unit' , 'world' (see below) Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) viz_style string, one of 'checker' , 'grid' , 'local_check' , 'local_rad' (see below) grid_colors 2-tuple of rgb colors, used to color the grid visualization checker_colors 2-tuple of rgb colors, used to color the checkerboard visualization checker_size float, the size of checkers/grid/stripes cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Adding"},{"location":"structures/surface_mesh/parameterization_quantities/#options","text":"","title":"Options"},{"location":"structures/surface_mesh/parameterization_quantities/#styles","text":"Several styles are available for how a parameterization is displayed. The viz_style option determines how parameterizations are visualized: checker : a two-color checker pattern grid : a two-color grid with thin lines local_check : a checkerboard over a radial colormap, centered around (0,0) local_rad : distance stripes over a radial colormap, centered around (0,0)","title":"Styles"},{"location":"structures/surface_mesh/parameterization_quantities/#types","text":"The coords_type options determines how parameter coordinates are interpreted for scaling: unit : UV coords are assumed to lie on the [0,1] interval world : UV coords are assumed to be scaled like the world-space positions of the mesh","title":"Types"},{"location":"structures/surface_mesh/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the elements of a surface mesh. Example: import numpy as np import polyscope as ps ps . init () N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # visualize some random data per-vertex vals_vert = np . random . rand ( N_vert ) ps_mesh . add_scalar_quantity ( \"rand vals\" , vals_vert , enabled = True ) # visualize some random data per-face vals_face = np . random . rand ( N_face ) ps_mesh . add_scalar_quantity ( \"rand vals2\" , vals_face , defined_on = 'faces' ) # visualize some random data per-edge (halfedges are also supported) vals_edge = np . random . rand ( ps_mesh . n_edges ()) ps_mesh . add_scalar_quantity ( \"rand vals3\" , vals_edge , defined_on = 'edges' ) # as always, we can customize the initial appearance ps_mesh . add_scalar_quantity ( \"rand vals3 opt\" , vals_edge , defined_on = 'edges' , enabled = True , vminmax = ( - 3. , 3. ), cmap = 'reds' ) # view the mesh with all of these quantities ps . show () SurfaceMesh . add_scalar_quantity ( name , values , defined_on = 'vertices' , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the mesh. name string, a name for the quantity values a length N numpy array, scalars at vertices/faces/etc defined_on one of 'vertices','faces','edges','halfedges' , is this data a value per vertex or a value per face, etc? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) datatype one of standard , symmetric , or magnitude , affects default colormap and map range vminmax a 2-tuple of floats, specifying the min and max range to colormap in to cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Scalar Quantities"},{"location":"structures/surface_mesh/vector_quantities/","text":"Visualize vector-valued data at the elements of a surface mesh. Example: import numpy as np import polyscope as ps ps . init () # register a surface mesh N_vert = 100 N_face = 250 vertices = np . random . rand ( N_vert , 3 ) # (V,3) vertex position array faces = np . random . randint ( 0 , N_vert , size = ( N_face , 3 )) # (F,3) array of indices # for triangular faces ps_mesh = ps . register_surface_mesh ( \"my mesh\" , vertices , faces ) # visualize some random vectors per vertex vecs_vert = np . random . rand ( N_vert , 3 ) ps_mesh . add_vector_quantity ( \"rand vecs\" , vecs_vert , enabled = True ) # set radius/length/color of the vectors ps_mesh . add_vector_quantity ( \"rand vecs opt\" , vecs_vert , radius = 0.001 , length = 0.005 , color = ( 0.2 , 0.5 , 0.5 )) # ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space ps_mesh . add_vector_quantity ( \"vecs ambient\" , vecs_vert , vectortype = 'ambient' ) # view the mesh with all of these quantities ps . show () SurfaceMesh . add_vector_quantity ( name , values , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the mesh. name string, a name for the quantity values an Nx3 numpy array, vectors at vertices/faces (or Nx2 for 2D data) defined_on string, one of vertices or faces , is this data a vector per-vertex or a vector per-face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set. Tangent vectors Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element. Specifying the tangent basis Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for each mesh element. SurfaceMesh . set_vertex_tangent_basisX ( vectors ) Specify the tangent coordinate system at vertices, by giving the direction of the x-axis of the basis. vectors is an Vx3 (or Vx2 for 2D) array of one 3D vector at each vertex, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal. SurfaceMesh . set_face_tangent_basisX ( vectors ) Specify the tangent coordinate system at faces, by giving the direction of the x-axis of the basis. vectors is an Fx3 (or Fx2 for 2D) array of one 3D vector at each face, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal. Adding intrinsic tangent vectors In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh . add_intrinsic_vector_quantity ( name , values , n_sym = 1 , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None , ribbon = None ) Add a vector quantity to the mesh. Remember to specify your tangent basis first! name string, a name for the quantity values an Nx2 numpy array, of tangent vectors at vertices/faces n_sym is a symmetry order for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. defined_on string, one of vertices or faces , is this data a vector per-vertex or a vector per-face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set. One forms One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh . add_one_form_vector_quantity ( name , values , orientations , enabled = None , length = None , radius = None , color = None , ribbon = None ) Add a one-form vector quantity to the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. name string, a name for the quantity values a length n_edges numpy float array, integrated 1-form values at edges orientations a length n_edges numpy boolean array. 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Vector Quantities"},{"location":"structures/surface_mesh/vector_quantities/#tangent-vectors","text":"Tangent vectors lie flat against the surface of the mesh. They are expressed as 2D vectors with X-Y coordinates in some basis frame at each mesh element.","title":"Tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#specifying-the-tangent-basis","text":"Tangent vectors are defined with respect to a coordinate frame at each vertex (resp., face). Before adding any tangent vector quantities, you probably need to tell Polyscope what this coordinate frame looks like. To do so, pass an array of the x-axis vectors (in 3D) for each mesh element. SurfaceMesh . set_vertex_tangent_basisX ( vectors ) Specify the tangent coordinate system at vertices, by giving the direction of the x-axis of the basis. vectors is an Vx3 (or Vx2 for 2D) array of one 3D vector at each vertex, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal. SurfaceMesh . set_face_tangent_basisX ( vectors ) Specify the tangent coordinate system at faces, by giving the direction of the x-axis of the basis. vectors is an Fx3 (or Fx2 for 2D) array of one 3D vector at each face, giving the direction of the x-axis of the basis. The rest of the basis will be computed from the normal.","title":"Specifying the tangent basis"},{"location":"structures/surface_mesh/vector_quantities/#adding-intrinsic-tangent-vectors","text":"In these function names, intrinsic vector is a fancy synonym for tangent vector, which indicates that the vectors lie in the surface itself, not the containing 3D space. SurfaceMesh . add_intrinsic_vector_quantity ( name , values , n_sym = 1 , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None , ribbon = None ) Add a vector quantity to the mesh. Remember to specify your tangent basis first! name string, a name for the quantity values an Nx2 numpy array, of tangent vectors at vertices/faces n_sym is a symmetry order for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non- 1 value, n distinct vectors will be displayed at each element. This function presumes a \u201cpower\u201d-representation for symmetric fields, which the inputs result from raising symmetric vectors to the n\u2019th power. defined_on string, one of vertices or faces , is this data a vector per-vertex or a vector per-face? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Adding intrinsic tangent vectors"},{"location":"structures/surface_mesh/vector_quantities/#one-forms","text":"One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices. SurfaceMesh . add_one_form_vector_quantity ( name , values , orientations , enabled = None , length = None , radius = None , color = None , ribbon = None ) Add a one-form vector quantity to the mesh. Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects. name string, a name for the quantity values a length n_edges numpy float array, integrated 1-form values at edges orientations a length n_edges numpy boolean array. 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. These booleans should be true if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise. Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors ribbon boolean, if true show the traced ribbon visualization if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"One forms"},{"location":"structures/volume_mesh/basics/","text":"Volume Meshes Volumetric meshes, such as tetrahedral ( tet ) and hexahedral ( hex , cube-like) meshes, represent a region of 3D space. Polyscope can display tet and hex meshes, including those which have a mix of hex and tet elements. We\u2019ll use the term cell to refer generically to a tet or hex in a volume mesh. As always, Polyscope can also handle scalar, color, or vector quantities associated with the vertices or cells of the mesh, and you can click on the mesh elements to inspect values. Your browser does not support the video tag. Registering a volume mesh Example : registering a tetrahedral mesh import polyscope as ps import numpy as np import igl verts , tets , _ = igl . read_mesh ( \"my_mesh.mesh\" ) ps_vol = ps . register_volume_mesh ( \"test volume mesh\" , verts , tets = tets ) n_vert = verts . shape [ 0 ] n_cell = tets . shape [ 0 ] # Add a scalar function on vertices data_vert = np . random . rand ( n_vert ) ps_vol . add_scalar_quantity ( \"my vertex val\" , data_vert ) # you can also access the structure by name ps . get_volume_mesh ( \"test volume mesh\" ) . add_scalar_quantity ( \"my vertex val\" , data_vert ) # Add a scalar function on cells (with some options set) data_cell = np . random . rand ( n_cell ) ps_vol . add_scalar_quantity ( \"my cell val\" , data_cell , defined_on = 'cells' , vminmax = ( - 3. , 3. ), cmap = 'blues' ) # Show the GUI ps . show () Volume meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each cell. There are a few different argument variants to register meshes with tets, hexes, or a mix of the two. register_volume_mesh ( name , vertices , tets = None , hexes = None , mixed_cells = None , enabled = None , color = None , interior_color = None , edge_color = None , edge_width = None , material = None ) Add a new volume mesh structure to Polyscope. name string, a name for the structure vertices an Nx3 numpy float array of vertex locations The elements are specified by a combination of the following arguments: tets a Tx4 numpy integer array of tetrahedra, as 0-based indices in to the vertices array hexes a Hx8 numpy integer array of hexahedra, as 0-based indices in to the vertices array mixed_cells a Mx8 numpy integer array which may contain a mix of tetrahedra and hexahedra. For any rows which are tets and thus have just 4 indices, the remaining indices should be set to any negative value. You may pass in tets , hexes , or both to specify the connectivty. Alternately, mixed_cells may be used. However, it is not supported to specify both tets / hexes and mixed_cells . For the purposes of element ordering, when tets and hexes are both passed, the cells are presumed to be ordered with all tetrahedral cells coming first, then hexahedral cells. Additional optional keyword arguments: enabled boolean, is the structure enabled initially color float 3-tuple, default color values for the outside of the mesh as rgb in [0,1] interior_color float 3-tuple, default color values for the inside of the mesh as rgb in [0,1] edge_color float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set edge_width too) edge_width float, width of edges in rendered mesh; default sets 0 to disable edges, 1 is a reasonable value to enable material string, name of material to use for the mesh if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. No support for 2D Unlike other structures, 2D volume meshes are not supported; they don\u2019t make much sense (see 2D data ). Updating a mesh The locations of the vertices in a mesh can be updated with the member function update_vertex_positions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). VolumeMesh . update_vertex_positions ( newPos ) Update the vertex positions in a volume mesh structure. newPos must be valid input to initially construct the vertex positions, with the same number of vertices. Slice planes Slice planes are particularly useful for inspecting the internal structure of a volume mesh, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details. Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details. Options Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial register_volume_mesh() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? color the color of the outside of the volume get_color () set_color ( val ) yes interior color the color of the inside of the volume get_interior_color () set_interior_color ( val ) yes edge color the color of the edges of the mesh get_edge_color () set_edge_color ( val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges get_edge_width () set_edge_width ( val ) yes material what material to use get_material () set_material ( name ) yes Example : set options which affect the appearance of the mesh import numpy as np import polyscope as ps # a simple inline mesh verts = np . array ([ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ 1 , 1 , 0 ], [ 0 , 1 , 0 ], [ 0 , 0 , 1 ], [ 1 , 0 , 1 ], [ 1 , 1 , 1 ], [ 0 , 1 , 1 ], [ 1 , 1 , 1.5 ] ]) cells = np . array ([ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ], [ 7 , 5 , 6 , 8 , - 1 , - 1 , - 1 , - 1 ], ]) ps_vol = ps . register_volume_mesh ( \"test volume mesh\" , verts , mixed_cells = cells ) ps_vol . set_enabled ( False ) # disable ps_vol . set_enabled () # default is true ps_vol . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] ps_vol . set_interior_color (( 0.4 , 0.7 , 0.9 )) ps_vol . set_edge_color (( 0.8 , 0.8 , 0.8 )) ps_vol . set_edge_width ( 1.0 ) ps_vol . set_material ( \"wax\" ) ps_vol . set_transparency ( 0.5 ) # alternately: ps . register_volume_mesh ( \"test volume mesh 2\" , verts , mixed_cells = cells , enabled = False , color = ( 1. , 0. , 0. ), interior_color = ( 0. , 1. , 0. ), edge_color = (( 0.8 , 0.8 , 0.8 )), edge_width = 1.0 , material = 'candy' , transparency = 0.5 ) ps . show ()","title":"Basics"},{"location":"structures/volume_mesh/basics/#volume-meshes","text":"Volumetric meshes, such as tetrahedral ( tet ) and hexahedral ( hex , cube-like) meshes, represent a region of 3D space. Polyscope can display tet and hex meshes, including those which have a mix of hex and tet elements. We\u2019ll use the term cell to refer generically to a tet or hex in a volume mesh. As always, Polyscope can also handle scalar, color, or vector quantities associated with the vertices or cells of the mesh, and you can click on the mesh elements to inspect values. Your browser does not support the video tag.","title":"Volume Meshes"},{"location":"structures/volume_mesh/basics/#registering-a-volume-mesh","text":"Example : registering a tetrahedral mesh import polyscope as ps import numpy as np import igl verts , tets , _ = igl . read_mesh ( \"my_mesh.mesh\" ) ps_vol = ps . register_volume_mesh ( \"test volume mesh\" , verts , tets = tets ) n_vert = verts . shape [ 0 ] n_cell = tets . shape [ 0 ] # Add a scalar function on vertices data_vert = np . random . rand ( n_vert ) ps_vol . add_scalar_quantity ( \"my vertex val\" , data_vert ) # you can also access the structure by name ps . get_volume_mesh ( \"test volume mesh\" ) . add_scalar_quantity ( \"my vertex val\" , data_vert ) # Add a scalar function on cells (with some options set) data_cell = np . random . rand ( n_cell ) ps_vol . add_scalar_quantity ( \"my cell val\" , data_cell , defined_on = 'cells' , vminmax = ( - 3. , 3. ), cmap = 'blues' ) # Show the GUI ps . show () Volume meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each cell. There are a few different argument variants to register meshes with tets, hexes, or a mix of the two. register_volume_mesh ( name , vertices , tets = None , hexes = None , mixed_cells = None , enabled = None , color = None , interior_color = None , edge_color = None , edge_width = None , material = None ) Add a new volume mesh structure to Polyscope. name string, a name for the structure vertices an Nx3 numpy float array of vertex locations The elements are specified by a combination of the following arguments: tets a Tx4 numpy integer array of tetrahedra, as 0-based indices in to the vertices array hexes a Hx8 numpy integer array of hexahedra, as 0-based indices in to the vertices array mixed_cells a Mx8 numpy integer array which may contain a mix of tetrahedra and hexahedra. For any rows which are tets and thus have just 4 indices, the remaining indices should be set to any negative value. You may pass in tets , hexes , or both to specify the connectivty. Alternately, mixed_cells may be used. However, it is not supported to specify both tets / hexes and mixed_cells . For the purposes of element ordering, when tets and hexes are both passed, the cells are presumed to be ordered with all tetrahedral cells coming first, then hexahedral cells. Additional optional keyword arguments: enabled boolean, is the structure enabled initially color float 3-tuple, default color values for the outside of the mesh as rgb in [0,1] interior_color float 3-tuple, default color values for the inside of the mesh as rgb in [0,1] edge_color float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set edge_width too) edge_width float, width of edges in rendered mesh; default sets 0 to disable edges, 1 is a reasonable value to enable material string, name of material to use for the mesh if not specified, these optional parameters will assume a reasonable default value, or a persistant value if previously set. No support for 2D Unlike other structures, 2D volume meshes are not supported; they don\u2019t make much sense (see 2D data ).","title":"Registering a volume mesh"},{"location":"structures/volume_mesh/basics/#updating-a-mesh","text":"The locations of the vertices in a mesh can be updated with the member function update_vertex_positions(newPositions) . All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite). VolumeMesh . update_vertex_positions ( newPos ) Update the vertex positions in a volume mesh structure. newPos must be valid input to initially construct the vertex positions, with the same number of vertices.","title":"Updating a mesh"},{"location":"structures/volume_mesh/basics/#slice-planes","text":"Slice planes are particularly useful for inspecting the internal structure of a volume mesh, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details. Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.","title":"Slice planes"},{"location":"structures/volume_mesh/basics/#options","text":"Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial register_volume_mesh() , as noted above. See structure management for options common to all structures such as enabling/disabling, transforms, and transparency. Parameter Meaning Getter Setter Persistent? color the color of the outside of the volume get_color () set_color ( val ) yes interior color the color of the inside of the volume get_interior_color () set_interior_color ( val ) yes edge color the color of the edges of the mesh get_edge_color () set_edge_color ( val ) yes edge width how thick to draw mesh edges, use 0. to disable and 1. for reasonable edges get_edge_width () set_edge_width ( val ) yes material what material to use get_material () set_material ( name ) yes Example : set options which affect the appearance of the mesh import numpy as np import polyscope as ps # a simple inline mesh verts = np . array ([ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ 1 , 1 , 0 ], [ 0 , 1 , 0 ], [ 0 , 0 , 1 ], [ 1 , 0 , 1 ], [ 1 , 1 , 1 ], [ 0 , 1 , 1 ], [ 1 , 1 , 1.5 ] ]) cells = np . array ([ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ], [ 7 , 5 , 6 , 8 , - 1 , - 1 , - 1 , - 1 ], ]) ps_vol = ps . register_volume_mesh ( \"test volume mesh\" , verts , mixed_cells = cells ) ps_vol . set_enabled ( False ) # disable ps_vol . set_enabled () # default is true ps_vol . set_color (( 0.3 , 0.6 , 0.8 )) # rgb triple on [0,1] ps_vol . set_interior_color (( 0.4 , 0.7 , 0.9 )) ps_vol . set_edge_color (( 0.8 , 0.8 , 0.8 )) ps_vol . set_edge_width ( 1.0 ) ps_vol . set_material ( \"wax\" ) ps_vol . set_transparency ( 0.5 ) # alternately: ps . register_volume_mesh ( \"test volume mesh 2\" , verts , mixed_cells = cells , enabled = False , color = ( 1. , 0. , 0. ), interior_color = ( 0. , 1. , 0. ), edge_color = (( 0.8 , 0.8 , 0.8 )), edge_width = 1.0 , material = 'candy' , transparency = 0.5 ) ps . show ()","title":"Options"},{"location":"structures/volume_mesh/color_quantities/","text":"Visualize color rgb-valued data at the elements of a volume mesh. Example : showing a color value at cells (here, random values) # ... initialization, create mesh ... ps_vol = ps . register_volume_mesh ( \"test volume mesh\" , verts , tets = tets ) n_vert = verts . shape [ 0 ] n_cell = tets . shape [ 0 ] # Add a color function on cells (with some options set) colors = np . random . rand ( n_cell , 3 ) ps_vol . add_color_quantity ( \"my color\" , colors , defined_on = 'cells' , enabled = True ) # Show the GUI ps . show () Add colors to elements VolumeMesh . add_color_quantity ( name , values , defined_on = 'vertices' , enabled = None ) Add a scalar quantity to the network. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at vertices/cells defined_on string, one of vertices or cells , is this data a color per vertex or a color per cell? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Color Quantities"},{"location":"structures/volume_mesh/color_quantities/#add-colors-to-elements","text":"VolumeMesh . add_color_quantity ( name , values , defined_on = 'vertices' , enabled = None ) Add a scalar quantity to the network. name string, a name for the quantity values an Nx3 numpy array, with rgb [0,1] colors at vertices/cells defined_on string, one of vertices or cells , is this data a color per vertex or a color per cell? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Add colors to elements"},{"location":"structures/volume_mesh/scalar_quantities/","text":"Visualize scalar (real or integer)-valued data at the elements of a volume mesh. Example : showing a scalar on vertices (here, random values) # ... initialization, create mesh ... ps_vol = ps . register_volume_mesh ( \"test volume mesh\" , verts , tets = tets ) n_vert = verts . shape [ 0 ] n_cell = tets . shape [ 0 ] # Add a scalar function on vertices data_vert = np . random . rand ( n_vert ) ps_vol . add_scalar_quantity ( \"my vertex val\" , data_vert ) # Add a scalar function on cells (with some options set) data_cell = np . random . rand ( n_cell ) ps_vol . add_scalar_quantity ( \"my cell val\" , data_cell , defined_on = 'cells' , vminmax = ( - 3. , 3. ), cmap = 'blues' , enabled = True ) // Show the GUI ps . show () Add scalars to elements VolumeMesh . add_scalar_quantity ( self , name , values , defined_on = 'vertices' , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the mesh. name string, a name for the quantity values a length N numpy array, scalars at vertices/cells defined_on one of 'vertices','cells' , is this data a value per vertex or a value per cell? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) datatype one of standard , symmetric , or magnitude , affects default colormap and map range vminmax a 2-tuple of floats, specifying the min and max range to colormap in to cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set. Inspecting with slice planes Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.","title":"Scalar Quantities"},{"location":"structures/volume_mesh/scalar_quantities/#add-scalars-to-elements","text":"VolumeMesh . add_scalar_quantity ( self , name , values , defined_on = 'vertices' , enabled = None , datatype = \"standard\" , vminmax = None , cmap = None ) Add a scalar quantity to the mesh. name string, a name for the quantity values a length N numpy array, scalars at vertices/cells defined_on one of 'vertices','cells' , is this data a value per vertex or a value per cell? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used) datatype one of standard , symmetric , or magnitude , affects default colormap and map range vminmax a 2-tuple of floats, specifying the min and max range to colormap in to cmap string, which colormap to use if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Add scalars to elements"},{"location":"structures/volume_mesh/scalar_quantities/#inspecting-with-slice-planes","text":"Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.","title":"Inspecting with slice planes"},{"location":"structures/volume_mesh/vector_quantities/","text":"Visualize vector-valued data at the elements of a volume mesh. Example : showing vectors on vertices (here random vectors) # ... initialization, create mesh ... ps_vol = ps . register_volume_mesh ( \"test volume mesh\" , verts , tets = tets ) n_vert = verts . shape [ 0 ] n_cell = tets . shape [ 0 ] # Add vectors on vertices (with some options set) vecs = np . random . rand ( n_vert , 3 ) ps_vol . add_vector ( \"my color\" , vecs , enabled = True , vectortype = 'ambient' ) # Show the GUI ps . show () Add vectors to elements VolumeMesh . add_vector_quantity ( name , values , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the mesh. name string, a name for the quantity values an Nx3 numpy array, vectors at vertices/cells defined_on string, one of vertices or cells , is this data a vector per-vertex or a vector per-cell? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Vector Quantities"},{"location":"structures/volume_mesh/vector_quantities/#add-vectors-to-elements","text":"VolumeMesh . add_vector_quantity ( name , values , defined_on = 'vertices' , enabled = None , vectortype = \"standard\" , length = None , radius = None , color = None ) Add a vector quantity to the mesh. name string, a name for the quantity values an Nx3 numpy array, vectors at vertices/cells defined_on string, one of vertices or cells , is this data a vector per-vertex or a vector per-cell? Additional optional keyword arguments: enabled boolean, whether the quantity is initially enabled vectortype , one of standard or ambient . Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates length float, a (relative) length for the vectors radius float, a (relative) radius for the vectors color 3-tuple, color for the vectors if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.","title":"Add vectors to elements"}]}